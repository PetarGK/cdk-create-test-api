{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./main.ts","webpack:///./node_modules/decimal.js/decimal.js","webpack:///./node_modules/dynamodb-geo/dist/GeoDataManager.js","webpack:///./node_modules/dynamodb-geo/dist/GeoDataManagerConfiguration.js","webpack:///./node_modules/dynamodb-geo/dist/dynamodb/DynamoDBManager.js","webpack:///./node_modules/dynamodb-geo/dist/index.js","webpack:///./node_modules/dynamodb-geo/dist/model/Covering.js","webpack:///./node_modules/dynamodb-geo/dist/model/GeohashRange.js","webpack:///./node_modules/dynamodb-geo/dist/s2/S2Manager.js","webpack:///./node_modules/dynamodb-geo/dist/s2/S2Util.js","webpack:///./node_modules/dynamodb-geo/dist/util/GeoTableUtil.js","webpack:///./node_modules/long/dist/long.js","webpack:///./node_modules/nodes2ts/dist/Interval.js","webpack:///./node_modules/nodes2ts/dist/MutableInteger.js","webpack:///./node_modules/nodes2ts/dist/R1Interval.js","webpack:///./node_modules/nodes2ts/dist/R2Vector.js","webpack:///./node_modules/nodes2ts/dist/S1Angle.js","webpack:///./node_modules/nodes2ts/dist/S1Interval.js","webpack:///./node_modules/nodes2ts/dist/S2.js","webpack:///./node_modules/nodes2ts/dist/S2Cap.js","webpack:///./node_modules/nodes2ts/dist/S2Cell.js","webpack:///./node_modules/nodes2ts/dist/S2CellId.js","webpack:///./node_modules/nodes2ts/dist/S2CellUnion.js","webpack:///./node_modules/nodes2ts/dist/S2EdgeUtil.js","webpack:///./node_modules/nodes2ts/dist/S2LatLng.js","webpack:///./node_modules/nodes2ts/dist/S2LatLngRect.js","webpack:///./node_modules/nodes2ts/dist/S2Metric.js","webpack:///./node_modules/nodes2ts/dist/S2Point.js","webpack:///./node_modules/nodes2ts/dist/S2Projections.js","webpack:///./node_modules/nodes2ts/dist/S2RegionCoverer.js","webpack:///./node_modules/nodes2ts/dist/decimal.js","webpack:///./node_modules/nodes2ts/dist/decimal_augmentation.js","webpack:///./node_modules/nodes2ts/dist/export.js","webpack:///external \"aws-sdk\""],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb,8CAA8C,cAAc;AAC5D,YAAY,mBAAO,CAAC,wBAAS;AAC7B;AACA,eAAe,mBAAO,CAAC,+DAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC,iBAAiB;AACjB;AACA;AACA,OAAO;AACP,qBAAqB;AACrB,iBAAiB;AACjB,wBAAwB,UAAU,qCAAqC,cAAc;AACrF,wBAAwB;AACxB,WAAW;AACX;AACA;AACA,KAAK,YAAY;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2CAA2C,mxH;;;;;;;;;;;AC3C3C;AACA,CAAC;AACD;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,gBAAgB,EAAE;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C,OAAO;AACjD;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET,gDAAgD,IAAI,OAAO,IAAI;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,KAAK;AACf;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,eAAe,GAAG;;AAElB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,UAAU;AACpB;AACA;;AAEA;AACA;;AAEA,wCAAwC,0BAA0B;AAClE;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,sBAAsB,cAAc;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,KAAK;AACtB;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,6BAA6B,OAAO;;AAEpC;AACA,uBAAuB,OAAO;;AAE9B;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU,iBAAiB;;AAE3B;AACA,UAAU,aAAa;;AAEvB;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,gBAAgB;;AAEzC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,UAAU,eAAe;AACzB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET,gDAAgD,IAAI,OAAO,IAAI;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,KAAK;;AAErB;AACA,iBAAiB,UAAU;AAC3B;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU,UAAU;;AAEpB;AACA;;AAEA;AACA,sBAAsB,SAAS;;AAE/B;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B,WAAW,OAAO;AAClB;AACA,iDAAiD,GAAG;AACpD,+CAA+C,GAAG;AAClD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG,SAAS,GAAG;AAC5B;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,mCAAmC,GAAG;AACtC,qCAAqC,GAAG;AACxC,4CAA4C,GAAG;AAC/C,0CAA0C,GAAG;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,UAAU,cAAc;;AAExB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,SAAS;;AAE3B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,UAAU;AACpB,6BAA6B,QAAQ;AACrC;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,mBAAmB,KAAK;AACxB;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA,YAAY,uBAAuB;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,uBAAuB;;AAExC;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,WAAW;;AAE3B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,8BAA8B,SAAS;AACvC;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,SAAS;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;;AAEA;AACA,0BAA0B,SAAS;;AAEnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe;;AAEf;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;AACA,uBAAuB,SAAS;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,eAAe;AACxC;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,YAAY,aAAa;;AAEzB;AACA,yBAAyB,SAAS;AAClC;;AAEA;AACA;;;AAGA;AACA;AACA,UAAU,KAAK;AACf;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA;;AAEA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,eAAe,0BAA0B;;AAEzC;AACA,0BAA0B,gCAAgC;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA,OAAO;AACP;AACA;;AAEA,YAAY,KAAK;AACjB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,KAAK;AACf;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,gBAAgB;;AAE5B;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,cAAc;;AAE3C;AACA,6BAA6B,SAAS;;AAEtC;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA,mCAAmC,cAAc;;AAEjD;AACA,qCAAqC,SAAS;AAC9C,aAAa;AACb;AACA;AACA;;AAEA;AACA,SAAS;AACT,gBAAgB,KAAK;AACrB;AACA,SAAS;AACT,uCAAuC,MAAM;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB;AACA,0BAA0B,6BAA6B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,sBAAsB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,wBAAwB;AACxB;AACA;AACA;AACA,wBAAwB;AACxB,0BAA0B;;AAE1B;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,YAAY,OAAO;;AAEnB;AACA,KAAK;AACL;;AAEA,YAAY,OAAO;AACnB;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA,YAAY,OAAO;;AAEnB;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL,YAAY,OAAO;AACnB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,aAAa;;AAEvB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,YAAY,aAAa;;AAEzB;AACA,4BAA4B,SAAS;;AAErC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;AACA,MAAM,IAAyC;AAC/C,IAAI,mCAAO;AACX;AACA,KAAK;AAAA,oGAAC;;AAEN;AACA,GAAG,MAAM,EAyBN;AACH,CAAC;;;;;;;;;;;;;ACnsJY;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,wBAAwB,mBAAO,CAAC,gGAA4B;AAC5D,kBAAkB,mBAAO,CAAC,wEAAgB;AAC1C,eAAe,mBAAO,CAAC,kEAAa;AACpC,iBAAiB,mBAAO,CAAC,wDAAU;AACnC,iBAAiB,mBAAO,CAAC,4EAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,eAAe;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,0CAA0C;AACjH,oEAAoE,oBAAoB;AACxF;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,0CAA0C;AACjH,oEAAoE,oBAAoB;AACxF;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,0CAA0C;AACjH;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8DAA8D,EAAE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAwD,EAAE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,oEAAoE,oBAAoB;AACxF;AACA;AACA,iFAAiF,WAAW;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qDAAqD,qDAAqD,mEAAmE,EAAE,EAAE,EAAE;AACnL;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC3Ua;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,wDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC9Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,yEAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA;AACA;AACA,sCAAsC,0BAA0B;AAChE;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,6CAA6C,qBAAqB,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,oDAAoD,0BAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+BAA+B,8EAA8E,EAAE;AACrJ,+DAA+D;AAC/D;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8BAA8B,yBAAyB;AACvD,SAAS;AACT;AACA,kCAAkC;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,qCAAqC,gDAAgD;AACrJ,wDAAwD,0BAA0B;AAClF;AACA,qBAAqB;AACrB;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACjKa;AACb,8CAA8C,cAAc;AAC5D,uBAAuB,mBAAO,CAAC,4EAAkB;AACjD;AACA,oCAAoC,mBAAO,CAAC,sGAA+B;AAC3E;AACA,qBAAqB,mBAAO,CAAC,kFAAqB;AAClD;;;;;;;;;;;;;ACPa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,8EAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACpBa;AACb,8CAA8C,cAAc;AAC5D,oCAAoC,mBAAO,CAAC,uGAAgC;AAC5E,kBAAkB,mBAAO,CAAC,yEAAiB;AAC3C,WAAW,mBAAO,CAAC,8CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+BAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACtFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,wDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACrCa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,wDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACnCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iEAAiE;AAClF,iBAAiB,kEAAkE;AACnF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;ACpFA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,IAA6C;AAC/D,QAAQ,iCAAO,EAAE,oCAAE,OAAO;AAAA;AAAA;AAAA,oGAAC;AAC3B,wBAAwB,EAGkD;;AAE1E,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA,2BAA2B;;AAE3B;AACA,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB,8CAA8C;AACnF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,sBAAsB,8CAA8C;AACnF,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+EAA+E,kBAAkB;AACjG;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,qFAAqF,qBAAqB;AAC1G;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,qFAAqF,oBAAoB;AACzG;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,8FAA8F,2BAA2B;AACzH;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,wFAAwF,uBAAuB;AAC/G;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iGAAiG,8BAA8B;AAC/H;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6EAA6E,mBAAmB;AAChG;AACA,eAAe,oBAAoB;AACnC,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,kBAAkB;AACzE;AACA,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mFAAmF,oBAAoB;AACvG;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gFAAgF,oBAAoB;AACpG;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,mBAAmB;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE,kBAAkB;AAC1F;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oEAAoE,kBAAkB;AACtF;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iGAAiG,qBAAqB;AACtH;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iHAAiH,sBAAsB;AACvI;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,4GAA4G,8BAA8B;AAC1I;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACxrCY;AACb,WAAW,mBAAO,CAAC,gDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oC;;;;;;;;;;;;ACtBa;AACb;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,0C;;;;;;;;;;;;ACRa;AACb;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,iBAAiB,mBAAO,CAAC,4DAAY;AACrC,WAAW,mBAAO,CAAC,gDAAM;AACzB,gBAAgB,mBAAO,CAAC,0DAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;AChLa;AACb,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,WAAW,mBAAO,CAAC,gDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oC;;;;;;;;;;;;ACtJa;AACb,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,WAAW,mBAAO,CAAC,gDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;AChFa;AACb;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,iBAAiB,mBAAO,CAAC,4DAAY;AACrC,WAAW,mBAAO,CAAC,gDAAM;AACzB;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;ACnZa;AACb,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,iBAAiB,mBAAO,CAAC,4DAAY;AACrC;AACA,WAAW,mBAAO,CAAC,8CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD,QAAQ,gCAAgC;AACxC;AACA;AACA,QAAQ,kBAAkB;AAC1B;AACA,QAAQ,mBAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,8B;;;;;;;;;;;;ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;AACb,WAAW,mBAAO,CAAC,gDAAM;AACzB,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,qBAAqB,mBAAO,CAAC,oEAAgB;AAC7C,iBAAiB,mBAAO,CAAC,4DAAY;AACrC,mBAAmB,mBAAO,CAAC,gEAAc;AACzC,mBAAmB,mBAAO,CAAC,gEAAc;AACzC,WAAW,mBAAO,CAAC,8CAAM;AACzB,gBAAgB,mBAAO,CAAC,0DAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,iC;;;;;;;;;;;;AClZa;AACb,WAAW,mBAAO,CAAC,8CAAM;AACzB,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,iBAAiB,mBAAO,CAAC,4DAAY;AACrC,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,iBAAiB,mBAAO,CAAC,4DAAY;AACrC,sBAAsB,mBAAO,CAAC,sEAAiB;AAC/C,iBAAiB,mBAAO,CAAC,4DAAY;AACrC,uBAAuB,mBAAO,CAAC,wEAAkB;AACjD,WAAW,mBAAO,CAAC,gDAAM;AACzB,qBAAqB,mBAAO,CAAC,oEAAgB;AAC7C,mBAAmB,mBAAO,CAAC,gEAAc;AACzC,mBAAmB,mBAAO,CAAC,gEAAc;AACzC,cAAc,mBAAO,CAAC,sDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA,yFAAyF;AACzF;AACA,gHAAgH;AAChH;AACA,gHAAgH;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,qBAAqB;AACrB,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yCAAyC,EAAE;AAC1E,+BAA+B,6DAA6D,EAAE;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,0BAA0B;AAC1B;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;;;;;;AC/WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;AACb;AACA,WAAW,mBAAO,CAAC,8CAAM;AACzB,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,iBAAiB,mBAAO,CAAC,4DAAY;AACrC,WAAW,mBAAO,CAAC,gDAAM;AACzB,uBAAuB,mBAAO,CAAC,wEAAkB;AACjD,iBAAiB,mBAAO,CAAC,4DAAY;AACrC,gBAAgB,mBAAO,CAAC,0DAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0BAA0B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,0BAA0B;AAC1B;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;ACt6Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAO,CAAC,8CAAM;AACzB,iBAAiB,mBAAO,CAAC,4DAAY;AACrC,eAAe,mBAAO,CAAC,wDAAU;AACjC,sBAAsB,mBAAO,CAAC,sEAAiB;AAC/C,qBAAqB,mBAAO,CAAC,oEAAgB;AAC7C,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,WAAW,mBAAO,CAAC,gDAAM;AACzB,cAAc,mBAAO,CAAC,sDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,kBAAkB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kDAAkD,2BAA2B;AAC7E;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0BAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uBAAuB,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;ACtgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;AACb,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,WAAW,mBAAO,CAAC,gDAAM;AACzB,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,gBAAgB,mBAAO,CAAC,0DAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,QAAQ,+BAA+B;AACvC;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yCAAyC;AAC1E;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;ACnxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;AACb,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,WAAW,mBAAO,CAAC,gDAAM;AACzB,gBAAgB,mBAAO,CAAC,0DAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,gBAAgB,WAAW;AAC3B;AACA,6CAA6C;AAC7C,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA,SAAS;AACT,2CAA2C,yDAAyD,EAAE;AACtG,4CAA4C,6DAA6D,EAAE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oC;;;;;;;;;;;;ACvMa;AACb,mBAAmB,mBAAO,CAAC,gEAAc;AACzC,mBAAmB,mBAAO,CAAC,gEAAc;AACzC,iBAAiB,mBAAO,CAAC,4DAAY;AACrC,WAAW,mBAAO,CAAC,gDAAM;AACzB,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,mBAAmB,mBAAO,CAAC,gEAAc;AACzC,cAAc,mBAAO,CAAC,sDAAS;AAC/B,gBAAgB,mBAAO,CAAC,0DAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,yCAAyC;AACzC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,mFAAmF,EAAE;AAChL,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,wC;;;;;;;;;;;;AC7lBa;AACb,WAAW,mBAAO,CAAC,gDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oC;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;AACb,iBAAiB,mBAAO,CAAC,4DAAY;AACrC,cAAc,mBAAO,CAAC,wDAAY;AAClC,WAAW,mBAAO,CAAC,gDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAO,CAAC,gDAAM;AACzB,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,iBAAiB,mBAAO,CAAC,4DAAY;AACrC;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA,CAAC;AACD;AACA,yC;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;AACb,eAAe,mBAAO,CAAC,wDAAU;AACjC,iBAAiB,mBAAO,CAAC,4DAAY;AACrC,oBAAoB,mBAAO,CAAC,kEAAe;AAC3C,sBAAsB,mBAAO,CAAC,sEAAiB;AAC/C,gBAAgB,mBAAO,CAAC,0DAAW;AACnC;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B,wBAAwB;AACzE,kCAAkC;AAClC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4CAA4C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4CAA4C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,qDAAqD,EAAE;AAC1H;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,2C;;;;;;;;;;;;ACnba;AACb,mBAAO,CAAC,oFAAwB;AAChC,kBAAkB,mBAAO,CAAC,wDAAY;AACtC,mC;;;;;;;;;;;;ACHa;AACb,gD;;;;;;;;;;;;ACDa;AACb;AACA;AACA;AACA,cAAc,mBAAO,CAAC,sDAAS;AAC/B,SAAS,mBAAO,CAAC,4DAAY;AAC7B,SAAS,mBAAO,CAAC,wEAAkB;AACnC,SAAS,mBAAO,CAAC,gEAAc;AAC/B,SAAS,mBAAO,CAAC,4DAAY;AAC7B,SAAS,mBAAO,CAAC,0DAAW;AAC5B,SAAS,mBAAO,CAAC,gEAAc;AAC/B,SAAS,mBAAO,CAAC,gDAAM;AACvB,SAAS,mBAAO,CAAC,sDAAS;AAC1B,SAAS,mBAAO,CAAC,wDAAU;AAC3B,SAAS,mBAAO,CAAC,4DAAY;AAC7B,SAAS,mBAAO,CAAC,kEAAe;AAChC;AACA;AACA,SAAS,mBAAO,CAAC,4DAAY;AAC7B,SAAS,mBAAO,CAAC,oEAAgB;AACjC;AACA,SAAS,mBAAO,CAAC,0DAAW;AAC5B,SAAS,mBAAO,CAAC,sEAAiB;AAClC,SAAS,mBAAO,CAAC,0EAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB,EAAE;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;;;;;ACpDA,oC","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./main.ts\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AWS = require('aws-sdk');\nconst ddb = new AWS.DynamoDB();\nconst ddbGeo = require('dynamodb-geo');\nconst config = new ddbGeo.GeoDataManagerConfiguration(ddb, 'offers');\nconfig.hashKeyLength = 7;\nconst myGeoTableManager = new ddbGeo.GeoDataManager(config);\nconst setupTable = async () => {\n    // Use GeoTableUtil to help construct a CreateTableInput.\n    const createTableInput = ddbGeo.GeoTableUtil.getCreateTableRequest(config);\n    // Tweak the schema as desired\n    createTableInput.ProvisionedThroughput.ReadCapacityUnits = 5;\n    console.log('Creating table with schema:');\n    console.dir(createTableInput, { depth: null });\n    // Create the table\n    await ddb.createTable(createTableInput).promise();\n};\nexports.handler = async () => {\n    //await setupTable();\n    /*\n    await myGeoTableManager.putPoint({\n      RangeKeyValue: { S: '1234' }, // Use this to ensure uniqueness of the hash/range pairs.\n      GeoPoint: { // An object specifying latitutde and longitude as plain numbers. Used to build the geohash, the hashkey and geojson data\n          latitude: 51.51,\n          longitude: -0.13\n      },\n      PutItemInput: { // Passed through to the underlying DynamoDB.putItem request. TableName is filled in for you.\n          Item: { // The primary key, geohash and geojson data is filled in for you\n              country: { S: 'UK' }, // Specify attribute values using { type: value } objects, like the DynamoDB API.\n              capital: { S: 'London' }\n          },\n          // ... Anything else to pass through to `putItem`, eg ConditionExpression\n      }\n    }).promise();*/\n    return await myGeoTableManager.queryRadius({\n        RadiusInMeter: 100000,\n        CenterPoint: {\n            latitude: 51.509953,\n            longitude: -0.130373\n        }\n    });\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm1haW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDL0IsTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUE7QUFDOUIsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFBO0FBRXRDLE1BQU0sTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLDJCQUEyQixDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQTtBQUNwRSxNQUFNLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQTtBQUN4QixNQUFNLGlCQUFpQixHQUFHLElBQUksTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQTtBQUMzRCxNQUFNLFVBQVUsR0FBRyxLQUFLLElBQUksRUFBRTtJQUU1Qix5REFBeUQ7SUFDekQsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBRTFFLDhCQUE4QjtJQUM5QixnQkFBZ0IsQ0FBQyxxQkFBcUIsQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLENBQUE7SUFFNUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFBO0lBQzFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQTtJQUU5QyxtQkFBbUI7SUFDbkIsTUFBTSxHQUFHLENBQUMsV0FBVyxDQUFDLGdCQUFnQixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDcEQsQ0FBQyxDQUFBO0FBRVksUUFBQSxPQUFPLEdBQUcsS0FBSyxJQUFvQixFQUFFO0lBQzlDLHFCQUFxQjtJQUNyQjs7Ozs7Ozs7Ozs7Ozs7bUJBY2U7SUFFZixPQUFPLE1BQU0saUJBQWlCLENBQUMsV0FBVyxDQUFDO1FBQ3pDLGFBQWEsRUFBRSxNQUFNO1FBQ3JCLFdBQVcsRUFBRTtZQUNULFFBQVEsRUFBRSxTQUFTO1lBQ25CLFNBQVMsRUFBRSxDQUFDLFFBQVE7U0FDdkI7S0FDRixDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBBV1MgPSByZXF1aXJlKCdhd3Mtc2RrJyk7XG5jb25zdCBkZGIgPSBuZXcgQVdTLkR5bmFtb0RCKCkgXG5jb25zdCBkZGJHZW8gPSByZXF1aXJlKCdkeW5hbW9kYi1nZW8nKVxuXG5jb25zdCBjb25maWcgPSBuZXcgZGRiR2VvLkdlb0RhdGFNYW5hZ2VyQ29uZmlndXJhdGlvbihkZGIsICdvZmZlcnMnKVxuY29uZmlnLmhhc2hLZXlMZW5ndGggPSA3XG5jb25zdCBteUdlb1RhYmxlTWFuYWdlciA9IG5ldyBkZGJHZW8uR2VvRGF0YU1hbmFnZXIoY29uZmlnKVxuY29uc3Qgc2V0dXBUYWJsZSA9IGFzeW5jICgpID0+IHtcblxuICAvLyBVc2UgR2VvVGFibGVVdGlsIHRvIGhlbHAgY29uc3RydWN0IGEgQ3JlYXRlVGFibGVJbnB1dC5cbiAgY29uc3QgY3JlYXRlVGFibGVJbnB1dCA9IGRkYkdlby5HZW9UYWJsZVV0aWwuZ2V0Q3JlYXRlVGFibGVSZXF1ZXN0KGNvbmZpZylcblxuICAvLyBUd2VhayB0aGUgc2NoZW1hIGFzIGRlc2lyZWRcbiAgY3JlYXRlVGFibGVJbnB1dC5Qcm92aXNpb25lZFRocm91Z2hwdXQuUmVhZENhcGFjaXR5VW5pdHMgPSA1XG4gIFxuICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgdGFibGUgd2l0aCBzY2hlbWE6JylcbiAgY29uc29sZS5kaXIoY3JlYXRlVGFibGVJbnB1dCwgeyBkZXB0aDogbnVsbCB9KVxuICBcbiAgLy8gQ3JlYXRlIHRoZSB0YWJsZVxuICBhd2FpdCBkZGIuY3JlYXRlVGFibGUoY3JlYXRlVGFibGVJbnB1dCkucHJvbWlzZSgpO1xufVxuXG5leHBvcnQgY29uc3QgaGFuZGxlciA9IGFzeW5jICgpIDogUHJvbWlzZSA8YW55PiA9PiB7XG4gICAgLy9hd2FpdCBzZXR1cFRhYmxlKCk7XG4gICAgLypcbiAgICBhd2FpdCBteUdlb1RhYmxlTWFuYWdlci5wdXRQb2ludCh7XG4gICAgICBSYW5nZUtleVZhbHVlOiB7IFM6ICcxMjM0JyB9LCAvLyBVc2UgdGhpcyB0byBlbnN1cmUgdW5pcXVlbmVzcyBvZiB0aGUgaGFzaC9yYW5nZSBwYWlycy5cbiAgICAgIEdlb1BvaW50OiB7IC8vIEFuIG9iamVjdCBzcGVjaWZ5aW5nIGxhdGl0dXRkZSBhbmQgbG9uZ2l0dWRlIGFzIHBsYWluIG51bWJlcnMuIFVzZWQgdG8gYnVpbGQgdGhlIGdlb2hhc2gsIHRoZSBoYXNoa2V5IGFuZCBnZW9qc29uIGRhdGFcbiAgICAgICAgICBsYXRpdHVkZTogNTEuNTEsXG4gICAgICAgICAgbG9uZ2l0dWRlOiAtMC4xM1xuICAgICAgfSxcbiAgICAgIFB1dEl0ZW1JbnB1dDogeyAvLyBQYXNzZWQgdGhyb3VnaCB0byB0aGUgdW5kZXJseWluZyBEeW5hbW9EQi5wdXRJdGVtIHJlcXVlc3QuIFRhYmxlTmFtZSBpcyBmaWxsZWQgaW4gZm9yIHlvdS5cbiAgICAgICAgICBJdGVtOiB7IC8vIFRoZSBwcmltYXJ5IGtleSwgZ2VvaGFzaCBhbmQgZ2VvanNvbiBkYXRhIGlzIGZpbGxlZCBpbiBmb3IgeW91XG4gICAgICAgICAgICAgIGNvdW50cnk6IHsgUzogJ1VLJyB9LCAvLyBTcGVjaWZ5IGF0dHJpYnV0ZSB2YWx1ZXMgdXNpbmcgeyB0eXBlOiB2YWx1ZSB9IG9iamVjdHMsIGxpa2UgdGhlIER5bmFtb0RCIEFQSS5cbiAgICAgICAgICAgICAgY2FwaXRhbDogeyBTOiAnTG9uZG9uJyB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyAuLi4gQW55dGhpbmcgZWxzZSB0byBwYXNzIHRocm91Z2ggdG8gYHB1dEl0ZW1gLCBlZyBDb25kaXRpb25FeHByZXNzaW9uXG4gICAgICB9XG4gICAgfSkucHJvbWlzZSgpOyovXG5cbiAgICByZXR1cm4gYXdhaXQgbXlHZW9UYWJsZU1hbmFnZXIucXVlcnlSYWRpdXMoe1xuICAgICAgUmFkaXVzSW5NZXRlcjogMTAwMDAwLFxuICAgICAgQ2VudGVyUG9pbnQ6IHtcbiAgICAgICAgICBsYXRpdHVkZTogNTEuNTA5OTUzLFxuICAgICAgICAgIGxvbmdpdHVkZTogLTAuMTMwMzczXG4gICAgICB9XG4gICAgfSk7XG59OyJdfQ==","/*! decimal.js v6.0.0 https://github.com/MikeMcl/decimal.js/LICENCE */\r\n;(function (globalScope) {\r\n  'use strict';\r\n\r\n\r\n  /*\r\n   *  decimal.js v6.0.0\r\n   *  An arbitrary-precision Decimal type for JavaScript.\r\n   *  https://github.com/MikeMcl/decimal.js\r\n   *  Copyright (c) 2016 Michael Mclaughlin <M8ch88l@gmail.com>\r\n   *  MIT Expat Licence\r\n   */\r\n\r\n\r\n  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\r\n\r\n\r\n    // The maximum exponent magnitude.\r\n    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\r\n  var EXP_LIMIT = 9e15,                      // 0 to 9e15\r\n\r\n    // The limit on the value of `precision`, and on the value of the first argument to\r\n    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n    MAX_DIGITS = 1e9,                        // 0 to 1e9\r\n\r\n    // Base conversion alphabet.\r\n    NUMERALS = '0123456789abcdef',\r\n\r\n    // The natural logarithm of 10 (1025 digits).\r\n    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',\r\n\r\n    // Pi (1025 digits).\r\n    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\r\n\r\n\r\n    // The initial configuration properties of the Decimal constructor.\r\n    Decimal = {\r\n\r\n      // These values must be integers within the stated ranges (inclusive).\r\n      // Most of these values can be changed at run-time using `Decimal.config`.\r\n\r\n      // The maximum number of significant digits of the result of a calculation or base conversion.\r\n      // E.g. `Decimal.config({ precision: 20 });`\r\n      precision: 20,                         // 1 to MAX_DIGITS\r\n\r\n      // The rounding mode used when rounding to `precision`.\r\n      //\r\n      // ROUND_UP         0 Away from zero.\r\n      // ROUND_DOWN       1 Towards zero.\r\n      // ROUND_CEIL       2 Towards +Infinity.\r\n      // ROUND_FLOOR      3 Towards -Infinity.\r\n      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      //\r\n      // E.g.\r\n      // `Decimal.rounding = 4;`\r\n      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\r\n      rounding: 4,                           // 0 to 8\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP         0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\r\n      // FLOOR      3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN  6 The IEEE 754 remainder function.\r\n      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\r\n      //\r\n      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\r\n      // division (9) are commonly used for the modulus operation. The other rounding modes can also\r\n      // be used, but they may not give useful results.\r\n      modulo: 1,                             // 0 to 9\r\n\r\n      // The exponent value at and beneath which `toString` returns exponential notation.\r\n      // JavaScript numbers: -7\r\n      toExpNeg: -7,                          // 0 to -EXP_LIMIT\r\n\r\n      // The exponent value at and above which `toString` returns exponential notation.\r\n      // JavaScript numbers: 21\r\n      toExpPos:  21,                         // 0 to EXP_LIMIT\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // JavaScript numbers: -324  (5e-324)\r\n      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // JavaScript numbers: 308  (1.7976931348623157e+308)\r\n      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      crypto: void 0                         // true/false/undefined\r\n    },\r\n\r\n\r\n  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\r\n\r\n\r\n    inexact, noConflict, quadrant,\r\n    cryptoObject = typeof crypto != 'undefined' ? crypto : null,\r\n    external = true,\r\n\r\n    decimalError = '[DecimalError] ',\r\n    invalidArgument = decimalError + 'Invalid argument: ',\r\n    precisionLimitExceeded = decimalError + 'Precision limit exceeded',\r\n\r\n    mathfloor = Math.floor,\r\n    mathpow = Math.pow,\r\n\r\n    isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,\r\n    isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,\r\n    isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,\r\n    isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n\r\n    BASE = 1e7,\r\n    LOG_BASE = 7,\r\n    MAX_SAFE_INTEGER = 9007199254740991,\r\n\r\n    LN10_PRECISION = LN10.length - 1,\r\n    PI_PRECISION = PI.length - 1,\r\n\r\n    // Decimal.prototype object\r\n    P = {};\r\n\r\n\r\n  // Decimal prototype methods\r\n\r\n\r\n  /*\r\n   *  absoluteValue             abs\r\n   *  ceil\r\n   *  comparedTo                cmp\r\n   *  cosine                    cos\r\n   *  cubeRoot                  cbrt\r\n   *  decimalPlaces             dp\r\n   *  dividedBy                 div\r\n   *  dividedToIntegerBy        divToInt\r\n   *  equals                    eq\r\n   *  floor\r\n   *  greaterThan               gt\r\n   *  greaterThanOrEqualTo      gte\r\n   *  hyperbolicCosine          cosh\r\n   *  hyperbolicSine            sinh\r\n   *  hyperbolicTangent         tanh\r\n   *  inverseCosine             acos\r\n   *  inverseHyperbolicCosine   acosh\r\n   *  inverseHyperbolicSine     asinh\r\n   *  inverseHyperbolicTangent  atanh\r\n   *  inverseSine               asin\r\n   *  inverseTangent            atan\r\n   *  isFinite\r\n   *  isInteger                 isInt\r\n   *  isNaN\r\n   *  isNegative                isNeg\r\n   *  isPositive                isPos\r\n   *  isZero\r\n   *  lessThan                  lt\r\n   *  lessThanOrEqualTo         lte\r\n   *  logarithm                 log\r\n   *  [maximum]                 [max]\r\n   *  [minimum]                 [min]\r\n   *  minus                     sub\r\n   *  modulo                    mod\r\n   *  naturalExponential        exp\r\n   *  naturalLogarithm          ln\r\n   *  negated                   neg\r\n   *  plus                      add\r\n   *  precision                 sd\r\n   *  round\r\n   *  sine                      sin\r\n   *  squareRoot                sqrt\r\n   *  tangent                   tan\r\n   *  times                     mul\r\n   *  toBinary\r\n   *  toDecimalPlaces           toDP\r\n   *  toExponential\r\n   *  toFixed\r\n   *  toFraction\r\n   *  toHexadecimal             toHex\r\n   *  toNearest\r\n   *  toNumber\r\n   *  toOctal\r\n   *  toPower                   pow\r\n   *  toPrecision\r\n   *  toSignificantDigits       toSD\r\n   *  toString\r\n   *  truncated                 trunc\r\n   *  valueOf                   toJSON\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of this Decimal.\r\n   *\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of positive Infinity.\r\n   *\r\n   */\r\n  P.ceil = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if the value of this Decimal is greater than the value of `y`,\r\n   *  -1    if the value of this Decimal is less than the value of `y`,\r\n   *   0    if they have the same value,\r\n   *   NaN  if the value of either Decimal is NaN.\r\n   *\r\n   */\r\n  P.comparedTo = P.cmp = function (y) {\r\n    var i, j, xdL, ydL,\r\n      x = this,\r\n      xd = x.d,\r\n      yd = (y = new x.constructor(y)).d,\r\n      xs = x.s,\r\n      ys = y.s;\r\n\r\n    // Either NaN or ±Infinity?\r\n    if (!xd || !yd) {\r\n      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Either zero?\r\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\r\n\r\n    // Signs differ?\r\n    if (xs !== ys) return xs;\r\n\r\n    // Compare exponents.\r\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\r\n\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\r\n      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * cos(0)         = 1\r\n   * cos(-0)        = 1\r\n   * cos(Infinity)  = NaN\r\n   * cos(-Infinity) = NaN\r\n   * cos(NaN)       = NaN\r\n   *\r\n   */\r\n  P.cosine = P.cos = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.d) return new Ctor(NaN);\r\n\r\n    // cos(0) = cos(-0) = 1\r\n    if (!x.d[0]) return new Ctor(1);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *\r\n   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   *  cbrt(0)  =  0\r\n   *  cbrt(-0) = -0\r\n   *  cbrt(1)  =  1\r\n   *  cbrt(-1) = -1\r\n   *  cbrt(N)  =  N\r\n   *  cbrt(-I) = -I\r\n   *  cbrt(I)  =  I\r\n   *\r\n   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n   *\r\n   */\r\n  P.cubeRoot = P.cbrt = function () {\r\n    var e, m, n, r, rep, s, sd, t, t3, t3plusx,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = x.s * Math.pow(x.s * x, 1 / 3);\r\n\r\n     // Math.cbrt underflow/overflow?\r\n     // Pass x to Math.pow as integer, then adjust the exponent of the result.\r\n    if (!s || Math.abs(s) == 1 / 0) {\r\n      n = digitsToString(x.d);\r\n      e = x.e;\r\n\r\n      // Adjust n exponent so it is a multiple of 3 away from x exponent.\r\n      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');\r\n      s = Math.pow(n, 1 / 3);\r\n\r\n      // Rarely, e may be one less than the result exponent value.\r\n      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n      r.s = x.s;\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Halley's method.\r\n    // TODO? Compare Newton's method.\r\n    for (;;) {\r\n      t = r;\r\n      t3 = t.times(t).times(t);\r\n      t3plusx = t3.plus(x);\r\n      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\r\n        // , i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of decimal places of the value of this Decimal.\r\n   *\r\n   */\r\n  P.decimalPlaces = P.dp = function () {\r\n    var w,\r\n      d = this.d,\r\n      n = NaN;\r\n\r\n    if (d) {\r\n      w = d.length - 1;\r\n      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      w = d[w];\r\n      if (w) for (; w % 10 == 0; w /= 10) n--;\r\n      if (n < 0) n = 0;\r\n    }\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedBy = P.div = function (y) {\r\n    return divide(this, new this.constructor(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedToIntegerBy = P.divToInt = function (y) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.equals = P.eq = function (y) {\r\n    return this.cmp(y) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of negative Infinity.\r\n   *\r\n   */\r\n  P.floor = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 3);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n   * false.\r\n   *\r\n   */\r\n  P.greaterThan = P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  P.greaterThanOrEqualTo = P.gte = function (y) {\r\n    var k = this.cmp(y);\r\n    return k == 1 || k === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [1, Infinity]\r\n   *\r\n   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n   *\r\n   * cosh(0)         = 1\r\n   * cosh(-0)        = 1\r\n   * cosh(Infinity)  = Infinity\r\n   * cosh(-Infinity) = Infinity\r\n   * cosh(NaN)       = NaN\r\n   *\r\n   *  x        time taken (ms)   result\r\n   * 1000      9                 9.8503555700852349694e+433\r\n   * 10000     25                4.4034091128314607936e+4342\r\n   * 100000    171               1.4033316802130615897e+43429\r\n   * 1000000   3817              1.5166076984010437725e+434294\r\n   * 10000000  abandoned after 2 minute wait\r\n   *\r\n   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicCosine = P.cosh = function () {\r\n    var k, n, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      one = new Ctor(1);\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\r\n    if (x.isZero()) return one;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\r\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    // TODO? Estimation reused from cosine() and may not be optimal here.\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      n = Math.pow(4, -k).toString();\r\n    } else {\r\n      k = 16;\r\n      n = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\r\n\r\n    // Reverse argument reduction\r\n    var cosh2_x,\r\n      i = k,\r\n      d8 = new Ctor(8);\r\n    for (; i--;) {\r\n      cosh2_x = x.times(x);\r\n      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\r\n    }\r\n\r\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n   *\r\n   * sinh(0)         = 0\r\n   * sinh(-0)        = -0\r\n   * sinh(Infinity)  = Infinity\r\n   * sinh(-Infinity) = -Infinity\r\n   * sinh(NaN)       = NaN\r\n   *\r\n   * x        time taken (ms)\r\n   * 10       2 ms\r\n   * 100      5 ms\r\n   * 1000     14 ms\r\n   * 10000    82 ms\r\n   * 100000   886 ms            1.4033316802130615897e+43429\r\n   * 200000   2613 ms\r\n   * 300000   5407 ms\r\n   * 400000   8824 ms\r\n   * 500000   13026 ms          8.7080643612718084129e+217146\r\n   * 1000000  48543 ms\r\n   *\r\n   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicSine = P.sinh = function () {\r\n    var k, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n    } else {\r\n\r\n      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\r\n      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\r\n      // 3 multiplications and 1 addition\r\n\r\n      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\r\n      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\r\n      // 4 multiplications and 2 additions\r\n\r\n      // Estimate the optimum number of times to use the argument reduction.\r\n      k = 1.4 * Math.sqrt(len);\r\n      k = k > 16 ? 16 : k | 0;\r\n\r\n      x = x.times(Math.pow(5, -k));\r\n\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n\r\n      // Reverse argument reduction\r\n      var sinh2_x,\r\n        d5 = new Ctor(5),\r\n        d16 = new Ctor(16),\r\n        d20 = new Ctor(20);\r\n      for (; k--;) {\r\n        sinh2_x = x.times(x);\r\n        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\r\n      }\r\n    }\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * tanh(x) = sinh(x) / cosh(x)\r\n   *\r\n   * tanh(0)         = 0\r\n   * tanh(-0)        = -0\r\n   * tanh(Infinity)  = 1\r\n   * tanh(-Infinity) = -1\r\n   * tanh(NaN)       = NaN\r\n   *\r\n   */\r\n  P.hyperbolicTangent = P.tanh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 7;\r\n    Ctor.rounding = 1;\r\n\r\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n   * this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [0, pi]\r\n   *\r\n   * acos(x) = pi/2 - asin(x)\r\n   *\r\n   * acos(0)       = pi/2\r\n   * acos(-0)      = pi/2\r\n   * acos(1)       = 0\r\n   * acos(-1)      = pi\r\n   * acos(1/2)     = pi/3\r\n   * acos(-1/2)    = 2*pi/3\r\n   * acos(|x| > 1) = NaN\r\n   * acos(NaN)     = NaN\r\n   *\r\n   */\r\n  P.inverseCosine = P.acos = function () {\r\n    var halfPi,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      k = x.abs().cmp(1),\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n      return k === 0\r\n        // |x| is 1\r\n        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)\r\n        // |x| > 1 or x is NaN\r\n        : new Ctor(NaN);\r\n    }\r\n\r\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.asin();\r\n    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return halfPi.minus(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [1, Infinity]\r\n   * Range: [0, Infinity]\r\n   *\r\n   * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n   *\r\n   * acosh(x < 1)     = NaN\r\n   * acosh(NaN)       = NaN\r\n   * acosh(Infinity)  = Infinity\r\n   * acosh(-Infinity) = NaN\r\n   * acosh(0)         = NaN\r\n   * acosh(-0)        = NaN\r\n   * acosh(1)         = 0\r\n   * acosh(-1)        = NaN\r\n   *\r\n   */\r\n  P.inverseHyperbolicCosine = P.acosh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\r\n    if (!x.isFinite()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).minus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n   *\r\n   * asinh(NaN)       = NaN\r\n   * asinh(Infinity)  = Infinity\r\n   * asinh(-Infinity) = -Infinity\r\n   * asinh(0)         = 0\r\n   * asinh(-0)        = -0\r\n   *\r\n   */\r\n  P.inverseHyperbolicSine = P.asinh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).plus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n   *\r\n   * atanh(|x| > 1)   = NaN\r\n   * atanh(NaN)       = NaN\r\n   * atanh(Infinity)  = NaN\r\n   * atanh(-Infinity) = NaN\r\n   * atanh(0)         = 0\r\n   * atanh(-0)        = -0\r\n   * atanh(1)         = Infinity\r\n   * atanh(-1)        = -Infinity\r\n   *\r\n   */\r\n  P.inverseHyperbolicTangent = P.atanh = function () {\r\n    var pr, rm, wpr, xsd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    xsd = x.sd();\r\n\r\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\r\n\r\n    Ctor.precision = wpr = xsd - x.e;\r\n\r\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\r\n\r\n    Ctor.precision = pr + 4;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.ln();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(0.5);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n   *\r\n   * asin(0)       = 0\r\n   * asin(-0)      = -0\r\n   * asin(1/2)     = pi/6\r\n   * asin(-1/2)    = -pi/6\r\n   * asin(1)       = pi/2\r\n   * asin(-1)      = -pi/2\r\n   * asin(|x| > 1) = NaN\r\n   * asin(NaN)     = NaN\r\n   *\r\n   * TODO? Compare performance of Taylor series.\r\n   *\r\n   */\r\n  P.inverseSine = P.asin = function () {\r\n    var halfPi, k,\r\n      pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    k = x.abs().cmp(1);\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n\r\n      // |x| is 1\r\n      if (k === 0) {\r\n        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        halfPi.s = x.s;\r\n        return halfPi;\r\n      }\r\n\r\n      // |x| > 1 or x is NaN\r\n      return new Ctor(NaN);\r\n    }\r\n\r\n    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n   *\r\n   * atan(0)         = 0\r\n   * atan(-0)        = -0\r\n   * atan(1)         = pi/4\r\n   * atan(-1)        = -pi/4\r\n   * atan(Infinity)  = pi/2\r\n   * atan(-Infinity) = -pi/2\r\n   * atan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.inverseTangent = P.atan = function () {\r\n    var i, j, k, n, px, t, r, wpr, x2,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (!x.isFinite()) {\r\n      if (!x.s) return new Ctor(NaN);\r\n      if (pr + 4 <= PI_PRECISION) {\r\n        r = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        r.s = x.s;\r\n        return r;\r\n      }\r\n    } else if (x.isZero()) {\r\n      return new Ctor(x);\r\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\r\n      r = getPi(Ctor, pr + 4, rm).times(0.25);\r\n      r.s = x.s;\r\n      return r;\r\n    }\r\n\r\n    Ctor.precision = wpr = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\r\n\r\n    // Argument reduction\r\n    // Ensure |x| < 0.42\r\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\r\n\r\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\r\n\r\n    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\r\n\r\n    external = false;\r\n\r\n    j = Math.ceil(wpr / LOG_BASE);\r\n    n = 1;\r\n    x2 = x.times(x);\r\n    r = new Ctor(x);\r\n    px = x;\r\n\r\n    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n    for (; i !== -1;) {\r\n      px = px.times(x2);\r\n      t = r.minus(px.div(n += 2));\r\n\r\n      px = px.times(x2);\r\n      r = t.plus(px.div(n += 2));\r\n\r\n      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);\r\n    }\r\n\r\n    if (k) r = r.times(2 << (k - 1));\r\n\r\n    external = true;\r\n\r\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n   *\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.d;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is an integer, otherwise return false.\r\n   *\r\n   */\r\n  P.isInteger = P.isInt = function () {\r\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is NaN, otherwise return false.\r\n   *\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is negative, otherwise return false.\r\n   *\r\n   */\r\n  P.isNegative = P.isNeg = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is positive, otherwise return false.\r\n   *\r\n   */\r\n  P.isPositive = P.isPos = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n   *\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.d && this.d[0] === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThan = P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThanOrEqualTo = P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * If no base is specified, return log[10](arg).\r\n   *\r\n   * log[base](arg) = ln(arg) / ln(base)\r\n   *\r\n   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n   * otherwise:\r\n   *\r\n   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n   * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n   *\r\n   * log[-b](a)       = NaN\r\n   * log[0](a)        = NaN\r\n   * log[1](a)        = NaN\r\n   * log[NaN](a)      = NaN\r\n   * log[Infinity](a) = NaN\r\n   * log[b](0)        = -Infinity\r\n   * log[b](-0)       = -Infinity\r\n   * log[b](-a)       = NaN\r\n   * log[b](1)        = 0\r\n   * log[b](Infinity) = Infinity\r\n   * log[b](NaN)      = NaN\r\n   *\r\n   * [base] {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  P.logarithm = P.log = function (base) {\r\n    var isBase10, d, denominator, k, inf, num, sd, r,\r\n      arg = this,\r\n      Ctor = arg.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding,\r\n      guard = 5;\r\n\r\n    // Default base is 10.\r\n    if (base == null) {\r\n      base = new Ctor(10);\r\n      isBase10 = true;\r\n    } else {\r\n      base = new Ctor(base);\r\n      d = base.d;\r\n\r\n      // Return NaN if base is negative, or non-finite, or is 0 or 1.\r\n      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\r\n\r\n      isBase10 = base.eq(10);\r\n    }\r\n\r\n    d = arg.d;\r\n\r\n    // Is arg negative, non-finite, 0 or 1?\r\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\r\n      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\r\n    }\r\n\r\n    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\r\n    // integer power of 10.\r\n    if (isBase10) {\r\n      if (d.length > 1) {\r\n        inf = true;\r\n      } else {\r\n        for (k = d[0]; k % 10 === 0;) k /= 10;\r\n        inf = k !== 1;\r\n      }\r\n    }\r\n\r\n    external = false;\r\n    sd = pr + guard;\r\n    num = naturalLogarithm(arg, sd);\r\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n\r\n    // The result will have 5 rounding digits.\r\n    r = divide(num, denominator, sd, 1);\r\n\r\n    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\r\n    // calculate 10 further digits.\r\n    //\r\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\r\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\r\n    // further digits, the last 14 are nines, round up and assume the result is exact.\r\n    // Also assume the result is exact if the last 14 are zero.\r\n    //\r\n    // Example of a result that will be incorrectly rounded:\r\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\r\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\r\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\r\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\r\n    // place is still 2.6.\r\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\r\n\r\n      do {\r\n        sd += 10;\r\n        num = naturalLogarithm(arg, sd);\r\n        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n        r = divide(num, denominator, sd, 1);\r\n\r\n        if (!inf) {\r\n\r\n          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\r\n          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\r\n            r = finalise(r, pr + 1, 0);\r\n          }\r\n\r\n          break;\r\n        }\r\n      } while (checkRoundingDigits(r.d, k += 10, rm));\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.max = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'lt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.min = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'gt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return y negated if x is finite and y is ±Infinity.\r\n      else if (x.d) y.s = -y.s;\r\n\r\n      // Return x if y is finite and x is ±Infinity.\r\n      // Return x if both are ±Infinity with different signs.\r\n      // Return NaN if both are ±Infinity with the same sign.\r\n      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n    // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.plus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return y negated if x is zero and y is non-zero.\r\n      if (yd[0]) y.s = -y.s;\r\n\r\n      // Return x if y is zero and x is non-zero.\r\n      else if (xd[0]) y = new Ctor(x);\r\n\r\n      // Return zero if both are zero.\r\n      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.\r\n      else return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    e = mathfloor(y.e / LOG_BASE);\r\n    xe = mathfloor(x.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    k = xe - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (k) {\r\n      xLTy = k < 0;\r\n\r\n      if (xLTy) {\r\n        d = xd;\r\n        k = -k;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = xe;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Numbers with massively different exponents would result in a very high number of\r\n      // zeros needing to be prepended, but this can be avoided while still ensuring correct\r\n      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\r\n      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\r\n\r\n      if (k > i) {\r\n        k = i;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      d.reverse();\r\n      for (i = k; i--;) d.push(0);\r\n      d.reverse();\r\n\r\n    // Base 1e7 exponents equal.\r\n    } else {\r\n\r\n      // Check digits to determine which is the bigger number.\r\n\r\n      i = xd.length;\r\n      len = yd.length;\r\n      xLTy = i < len;\r\n      if (xLTy) len = i;\r\n\r\n      for (i = 0; i < len; i++) {\r\n        if (xd[i] != yd[i]) {\r\n          xLTy = xd[i] < yd[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      k = 0;\r\n    }\r\n\r\n    if (xLTy) {\r\n      d = xd;\r\n      xd = yd;\r\n      yd = d;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    len = xd.length;\r\n\r\n    // Append zeros to `xd` if shorter.\r\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\r\n    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\r\n\r\n    // Subtract yd from xd.\r\n    for (i = yd.length; i > k;) {\r\n\r\n      if (xd[--i] < yd[i]) {\r\n        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\r\n        --xd[j];\r\n        xd[i] += BASE;\r\n      }\r\n\r\n      xd[i] -= yd[i];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xd[--len] === 0;) xd.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xd[0] === 0; xd.shift()) --e;\r\n\r\n    // Zero?\r\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * The result depends on the modulo mode.\r\n   *\r\n   */\r\n  P.modulo = P.mod = function (y) {\r\n    var q,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.\r\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\r\n\r\n    // Return x if y is ±Infinity or x is ±0.\r\n    if (!y.d || x.d && !x.d[0]) {\r\n      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\r\n    }\r\n\r\n    // Prevent rounding of intermediate calculations.\r\n    external = false;\r\n\r\n    if (Ctor.modulo == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // result = x - q * y    where  0 <= result < abs(y)\r\n      q = divide(x, y.abs(), 0, 3, 1);\r\n      q.s *= y.s;\r\n    } else {\r\n      q = divide(x, y, 0, Ctor.modulo, 1);\r\n    }\r\n\r\n    q = q.times(y);\r\n\r\n    external = true;\r\n\r\n    return x.minus(q);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalExponential = P.exp = function () {\r\n    return naturalExponential(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalLogarithm = P.ln = function () {\r\n    return naturalLogarithm(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n   * -1.\r\n   *\r\n   */\r\n  P.negated = P.neg = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = -x.s;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var carry, d, e, i, k, len, pr, rm, xd, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return x if y is finite and x is ±Infinity.\r\n      // Return x if both are ±Infinity with the same sign.\r\n      // Return NaN if both are ±Infinity with different signs.\r\n      // Return y if x is finite and y is ±Infinity.\r\n      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n     // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.minus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return x if y is zero.\r\n      // Return y if y is non-zero.\r\n      if (!yd[0]) y = new Ctor(x);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    k = mathfloor(x.e / LOG_BASE);\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    i = k - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (i) {\r\n\r\n      if (i < 0) {\r\n        d = xd;\r\n        i = -i;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = k;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\r\n      k = Math.ceil(pr / LOG_BASE);\r\n      len = k > len ? k + 1 : len + 1;\r\n\r\n      if (i > len) {\r\n        i = len;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\r\n      d.reverse();\r\n      for (; i--;) d.push(0);\r\n      d.reverse();\r\n    }\r\n\r\n    len = xd.length;\r\n    i = yd.length;\r\n\r\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\r\n    if (len - i < 0) {\r\n      i = len;\r\n      d = yd;\r\n      yd = xd;\r\n      xd = d;\r\n    }\r\n\r\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\r\n    for (carry = 0; i;) {\r\n      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\r\n      xd[i] %= BASE;\r\n    }\r\n\r\n    if (carry) {\r\n      xd.unshift(carry);\r\n      ++e;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    for (len = xd.length; xd[--len] == 0;) xd.pop();\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of significant digits of the value of this Decimal.\r\n   *\r\n   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n   *\r\n   */\r\n  P.precision = P.sd = function (z) {\r\n    var k,\r\n      x = this;\r\n\r\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\r\n\r\n    if (x.d) {\r\n      k = getPrecision(x.d);\r\n      if (z && x.e + 1 > k) k = x.e + 1;\r\n    } else {\r\n      k = NaN;\r\n    }\r\n\r\n    return k;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n   * rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.round = function () {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   *\r\n   * sin(0)         = 0\r\n   * sin(-0)        = -0\r\n   * sin(Infinity)  = NaN\r\n   * sin(-Infinity) = NaN\r\n   * sin(NaN)       = NaN\r\n   *\r\n   */\r\n  P.sine = P.sin = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N)  =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I)  =  I\r\n   *  sqrt(0)  =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, sd, r, rep, t,\r\n      x = this,\r\n      d = x.d,\r\n      e = x.e,\r\n      s = x.s,\r\n      Ctor = x.constructor;\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !d || !d[0]) {\r\n      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\r\n    }\r\n\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+x);\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = digitsToString(d);\r\n\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(n);\r\n      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '1e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Newton-Raphson iteration.\r\n    for (;;) {\r\n      t = r;\r\n      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\r\n        // 4999, i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * tan(0)         = 0\r\n   * tan(-0)        = -0\r\n   * tan(Infinity)  = NaN\r\n   * tan(-Infinity) = NaN\r\n   * tan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.tangent = P.tan = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.sin();\r\n    x.s = 1;\r\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var carry, e, i, k, r, rL, t, xdL, ydL,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      xd = x.d,\r\n      yd = (y = new Ctor(y)).d;\r\n\r\n    y.s *= x.s;\r\n\r\n     // If either is NaN, ±Infinity or ±0...\r\n    if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd\r\n\r\n        // Return NaN if either is NaN.\r\n        // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.\r\n        ? NaN\r\n\r\n        // Return ±Infinity if either is ±Infinity.\r\n        // Return ±0 if either is ±0.\r\n        : !xd || !yd ? y.s / 0 : y.s * 0);\r\n    }\r\n\r\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Ensure xd points to the longer array.\r\n    if (xdL < ydL) {\r\n      r = xd;\r\n      xd = yd;\r\n      yd = r;\r\n      rL = xdL;\r\n      xdL = ydL;\r\n      ydL = rL;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    r = [];\r\n    rL = xdL + ydL;\r\n    for (i = rL; i--;) r.push(0);\r\n\r\n    // Multiply!\r\n    for (i = ydL; --i >= 0;) {\r\n      carry = 0;\r\n      for (k = xdL + i; k > i;) {\r\n        t = r[k] + yd[i] * xd[k - i - 1] + carry;\r\n        r[k--] = t % BASE | 0;\r\n        carry = t / BASE | 0;\r\n      }\r\n\r\n      r[k] = (r[k] + carry) % BASE | 0;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; !r[--rL];) r.pop();\r\n\r\n    if (carry) ++e;\r\n    else r.shift();\r\n\r\n    // Remove trailing zeros.\r\n    for (i = r.length; !r[--i];) r.pop();\r\n\r\n    y.d = r;\r\n    y.e = getBase10Exponent(r, e);\r\n\r\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toBinary = function (sd, rm) {\r\n    return toStringBinary(this, 2, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n   *\r\n   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toDecimalPlaces = P.toDP = function (dp, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n    if (dp === void 0) return x;\r\n\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    return finalise(x, dp + x.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in exponential notation rounded to\r\n   * `dp` fixed decimal places using rounding mode `rounding`.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x, true);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), dp + 1, rm);\r\n      str = finiteToString(x, true, dp + 1);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n   * omitted.\r\n   *\r\n   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   * (-0).toFixed(3) is '0.000'.\r\n   * (-0.5).toFixed(0) is '-0'.\r\n   *\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var str, y,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      y = finalise(new Ctor(x), dp + x.e + 1, rm);\r\n      str = finiteToString(y, false, dp + y.e + 1);\r\n    }\r\n\r\n    // To determine whether to add the minus sign look at the value before it was rounded,\r\n    // i.e. look at `x` rather than `y`.\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n   * numerator and an integer denominator.\r\n   *\r\n   * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n   * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n   * value necessary to represent the number exactly.\r\n   *\r\n   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n   *\r\n   */\r\n  P.toFraction = function (maxD) {\r\n    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,\r\n      x = this,\r\n      xd = x.d,\r\n      Ctor = x.constructor;\r\n\r\n    if (!xd) return new Ctor(x);\r\n\r\n    n1 = d0 = new Ctor(1);\r\n    d1 = n0 = new Ctor(0);\r\n\r\n    d = new Ctor(d1);\r\n    e = d.e = getPrecision(xd) - x.e - 1;\r\n    k = e % LOG_BASE;\r\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\r\n\r\n    if (maxD == null) {\r\n\r\n      // d is 10**e, the minimum max-denominator needed.\r\n      maxD = e > 0 ? d : n1;\r\n    } else {\r\n      n = new Ctor(maxD);\r\n      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\r\n      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;\r\n    }\r\n\r\n    external = false;\r\n    n = new Ctor(digitsToString(xd));\r\n    pr = Ctor.precision;\r\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\r\n\r\n    for (;;)  {\r\n      q = divide(n, d, 0, 1, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.cmp(maxD) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      d2 = n1;\r\n      n1 = n0.plus(q.times(d2));\r\n      n0 = d2;\r\n      d2 = d;\r\n      d = n.minus(q.times(d2));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1?\r\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1\r\n        ? [n1, d1] : [n0, d0];\r\n\r\n    Ctor.precision = pr;\r\n    external = true;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toHexadecimal = P.toHex = function (sd, rm) {\r\n    return toStringBinary(this, 16, sd, rm);\r\n  };\r\n\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal whose value is the nearest multiple of the magnitude of `y` to the value\r\n   * of this Decimal.\r\n   *\r\n   * If the value of this Decimal is equidistant from two multiples of `y`, the rounding mode `rm`,\r\n   * or `Decimal.rounding` if `rm` is omitted, determines the direction of the nearest multiple.\r\n   *\r\n   * In the context of this method, rounding mode 4 (ROUND_HALF_UP) is the same as rounding mode 0\r\n   * (ROUND_UP), and so on.\r\n   *\r\n   * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n   * or `y` is NaN, in which case the return value will be also be NaN.\r\n   *\r\n   * The return value is not affected by the value of `precision`.\r\n   *\r\n   * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toNearest() rounding mode not an integer: {rm}'\r\n   * 'toNearest() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toNearest = function (y, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (y == null) {\r\n\r\n      // If x is not finite, return x.\r\n      if (!x.d) return x;\r\n\r\n      y = new Ctor(1);\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      y = new Ctor(y);\r\n      if (rm !== void 0) checkInt32(rm, 0, 8);\r\n\r\n      // If x is not finite, return x if y is not NaN, else NaN.\r\n      if (!x.d) return y.s ? x : y;\r\n\r\n      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\r\n      if (!y.d) {\r\n        if (y.s) y.s = x.s;\r\n        return y;\r\n      }\r\n    }\r\n\r\n    // If y is not zero, calculate the nearest multiple of y to x.\r\n    if (y.d[0]) {\r\n      external = false;\r\n      if (rm < 4) rm = [4, 5, 7, 8][rm];\r\n      x = divide(x, y, 0, rm, 1).times(y);\r\n      external = true;\r\n      finalise(x);\r\n\r\n    // If y is zero, return zero with the sign of x.\r\n    } else {\r\n      y.s = x.s;\r\n      x = y;\r\n    }\r\n\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Decimal converted to a number primitive.\r\n   * Zero keeps its sign.\r\n   *\r\n   */\r\n  P.toNumber = function () {\r\n    return +this;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toOctal = function (sd, rm) {\r\n    return toStringBinary(this, 8, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n   * to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * ECMAScript compliant.\r\n   *\r\n   *   pow(x, NaN)                           = NaN\r\n   *   pow(x, ±0)                            = 1\r\n\r\n   *   pow(NaN, non-zero)                    = NaN\r\n   *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n   *   pow(abs(x) > 1, -Infinity)            = +0\r\n   *   pow(abs(x) == 1, ±Infinity)           = NaN\r\n   *   pow(abs(x) < 1, +Infinity)            = +0\r\n   *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n   *   pow(+Infinity, y > 0)                 = +Infinity\r\n   *   pow(+Infinity, y < 0)                 = +0\r\n   *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n   *   pow(-Infinity, even integer > 0)      = +Infinity\r\n   *   pow(-Infinity, odd integer < 0)       = -0\r\n   *   pow(-Infinity, even integer < 0)      = +0\r\n   *   pow(+0, y > 0)                        = +0\r\n   *   pow(+0, y < 0)                        = +Infinity\r\n   *   pow(-0, odd integer > 0)              = -0\r\n   *   pow(-0, even integer > 0)             = +0\r\n   *   pow(-0, odd integer < 0)              = -Infinity\r\n   *   pow(-0, even integer < 0)             = +Infinity\r\n   *   pow(finite x < 0, finite non-integer) = NaN\r\n   *\r\n   * For non-integer or very large exponents pow(x, y) is calculated using\r\n   *\r\n   *   x^y = exp(y*ln(x))\r\n   *\r\n   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n   * probability of an incorrectly rounded result\r\n   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n   * i.e. 1 in 250,000,000,000,000\r\n   *\r\n   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n   *\r\n   * y {number|string|Decimal} The power to which to raise this Decimal.\r\n   *\r\n   */\r\n  P.toPower = P.pow = function (y) {\r\n    var e, k, pr, r, rm, sign, yIsInt,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      yn = +(y = new Ctor(y));\r\n\r\n    // Either ±Infinity, NaN or ±0?\r\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return  new Ctor(mathpow(+x, yn));\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (x.eq(1)) return x;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (y.eq(1)) return finalise(x, pr, rm);\r\n\r\n    e = mathfloor(y.e / LOG_BASE);\r\n    k = y.d.length - 1;\r\n    yIsInt = e >= k;\r\n    sign = x.s;\r\n\r\n    if (!yIsInt) {\r\n      if (sign < 0) return new Ctor(NaN);\r\n\r\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\r\n    } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\r\n      r = intPow(Ctor, x, k, pr);\r\n      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\r\n    }\r\n\r\n    // Result is negative if x is negative and the last digit of integer y is odd.\r\n    sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;\r\n\r\n    // Estimate result exponent.\r\n    // x^y = 10^e,  where e = y * log10(x)\r\n    // log10(x) = log10(x_significand) + x_exponent\r\n    // log10(x_significand) = ln(x_significand) / ln(10)\r\n    k = mathpow(+x, yn);\r\n    e = k == 0 || !isFinite(k)\r\n      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))\r\n      : new Ctor(k + '').e;\r\n\r\n    // Estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\r\n\r\n    // Overflow/underflow?\r\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? sign / 0 : 0);\r\n\r\n    external = false;\r\n    Ctor.rounding = x.s = 1;\r\n\r\n    // Estimate the extra guard digits needed to ensure five correct rounding digits from\r\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\r\n    // new Decimal(2.32456).pow('2087987436534566.46411')\r\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\r\n    k = Math.min(12, (e + '').length);\r\n\r\n    // r = x^y = exp(y*ln(x))\r\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\r\n\r\n    // Truncate to the required precision plus five rounding digits.\r\n    r = finalise(r, pr + 5, 1);\r\n\r\n    // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\r\n    // the result.\r\n    if (checkRoundingDigits(r.d, pr, rm)) {\r\n      e = pr + 10;\r\n\r\n      // Truncate to the increased precision plus five rounding digits.\r\n      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\r\n\r\n      // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\r\n      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\r\n        r = finalise(r, pr + 1, 0);\r\n      }\r\n    }\r\n\r\n    r.s = sign;\r\n    external = true;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), sd, rm);\r\n      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n   * omitted.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toSD() digits out of range: {sd}'\r\n   * 'toSD() digits not an integer: {sd}'\r\n   * 'toSD() rounding mode not an integer: {rm}'\r\n   * 'toSD() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toSignificantDigits = P.toSD = function (sd, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    }\r\n\r\n    return finalise(new Ctor(x), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   *\r\n   * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n   *\r\n   */\r\n  P.toString = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n   *\r\n   */\r\n  P.truncated = P.trunc = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   * Unlike `toString`, negative zero will include the minus sign.\r\n   *\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n  // Add aliases to match BigDecimal method names.\r\n  // P.add = P.plus;\r\n  P.subtract = P.minus;\r\n  P.multiply = P.times;\r\n  P.divide = P.div;\r\n  P.remainder = P.mod;\r\n  P.compareTo = P.cmp;\r\n  P.negate = P.neg;\r\n   */\r\n\r\n\r\n  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\r\n\r\n\r\n  /*\r\n   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n   *                           finiteToString, naturalExponential, naturalLogarithm\r\n   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n   *  convertBase              toStringBinary, parseOther\r\n   *  cos                      P.cos\r\n   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n   *                           taylorSeries, atan2, parseOther\r\n   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n   *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n   *                           naturalLogarithm, ceil, floor, round, trunc\r\n   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n   *                           toStringBinary\r\n   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n   *  getLn10                  P.logarithm, naturalLogarithm\r\n   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n   *  getPrecision             P.precision, P.toFraction\r\n   *  getZeroString            digitsToString, finiteToString\r\n   *  intPow                   P.toPower, parseOther\r\n   *  isOdd                    toLessThanHalfPi\r\n   *  maxOrMin                 max, min\r\n   *  naturalExponential       P.naturalExponential, P.toPower\r\n   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n   *                           P.toPower, naturalExponential\r\n   *  nonFiniteToString        finiteToString, toStringBinary\r\n   *  parseDecimal             Decimal\r\n   *  parseOther               Decimal\r\n   *  sin                      P.sin\r\n   *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n   *  toLessThanHalfPi         P.cos, P.sin\r\n   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n   *  truncate                 intPow\r\n   *\r\n   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n   *                           naturalLogarithm, config, parseOther, random, Decimal\r\n   */\r\n\r\n\r\n  function digitsToString(d) {\r\n    var i, k, ws,\r\n      indexOfLastWord = d.length - 1,\r\n      str = '',\r\n      w = d[0];\r\n\r\n    if (indexOfLastWord > 0) {\r\n      str += w;\r\n      for (i = 1; i < indexOfLastWord; i++) {\r\n        ws = d[i] + '';\r\n        k = LOG_BASE - ws.length;\r\n        if (k) str += getZeroString(k);\r\n        str += ws;\r\n      }\r\n\r\n      w = d[i];\r\n      ws = w + '';\r\n      k = LOG_BASE - ws.length;\r\n      if (k) str += getZeroString(k);\r\n    } else if (w === 0) {\r\n      return '0';\r\n    }\r\n\r\n    // Remove trailing zeros of last w.\r\n    for (; w % 10 === 0;) w /= 10;\r\n\r\n    return str + w;\r\n  }\r\n\r\n\r\n  function checkInt32(i, min, max) {\r\n    if (i !== ~~i || i < min || i > max) {\r\n      throw Error(invalidArgument + i);\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n   * `repeating == null` if caller is `log` or `pow`,\r\n   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n   */\r\n  function checkRoundingDigits(d, i, rm, repeating) {\r\n    var di, k, r, rd;\r\n\r\n    // Get the length of the first word of the array d.\r\n    for (k = d[0]; k >= 10; k /= 10) --i;\r\n\r\n    // Is the rounding digit in the first word of d?\r\n    if (--i < 0) {\r\n      i += LOG_BASE;\r\n      di = 0;\r\n    } else {\r\n      di = Math.ceil((i + 1) / LOG_BASE);\r\n      i %= LOG_BASE;\r\n    }\r\n\r\n    // i is the index (0 - 6) of the rounding digit.\r\n    // E.g. if within the word 3487563 the first rounding digit is 5,\r\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\r\n    k = mathpow(10, LOG_BASE - i);\r\n    rd = d[di] % k | 0;\r\n\r\n    if (repeating == null) {\r\n      if (i < 3) {\r\n        if (i == 0) rd = rd / 100 | 0;\r\n        else if (i == 1) rd = rd / 10 | 0;\r\n        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\r\n      } else {\r\n        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||\r\n            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\r\n      }\r\n    } else {\r\n      if (i < 4) {\r\n        if (i == 0) rd = rd / 1000 | 0;\r\n        else if (i == 1) rd = rd / 100 | 0;\r\n        else if (i == 2) rd = rd / 10 | 0;\r\n        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\r\n      } else {\r\n        r = ((repeating || rm < 4) && rd + 1 == k ||\r\n        (!repeating && rm > 3) && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\r\n      }\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  // Convert string of `baseIn` to an array of numbers of `baseOut`.\r\n  // Eg. convertBase('255', 10, 16) returns [15, 15].\r\n  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\r\n  function convertBase(str, baseIn, baseOut) {\r\n    var j,\r\n      arr = [0],\r\n      arrL,\r\n      i = 0,\r\n      strL = str.length;\r\n\r\n    for (; i < strL;) {\r\n      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;\r\n      arr[0] += NUMERALS.indexOf(str.charAt(i++));\r\n      for (j = 0; j < arr.length; j++) {\r\n        if (arr[j] > baseOut - 1) {\r\n          if (arr[j + 1] === void 0) arr[j + 1] = 0;\r\n          arr[j + 1] += arr[j] / baseOut | 0;\r\n          arr[j] %= baseOut;\r\n        }\r\n      }\r\n    }\r\n\r\n    return arr.reverse();\r\n  }\r\n\r\n\r\n  /*\r\n   * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function cosine(Ctor, x) {\r\n    var k, y,\r\n      len = x.d.length;\r\n\r\n    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\r\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      y = Math.pow(4, -k).toString();\r\n    } else {\r\n      k = 16;\r\n      y = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    Ctor.precision += k;\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\r\n\r\n    // Reverse argument reduction\r\n    for (var i = k; i--;) {\r\n      var cos2x = x.times(x);\r\n      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\r\n    }\r\n\r\n    Ctor.precision -= k;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Perform division in the specified base.\r\n   */\r\n  var divide = (function () {\r\n\r\n    // Assumes non-zero x and k, and hence non-zero result.\r\n    function multiplyInteger(x, k, base) {\r\n      var temp,\r\n        carry = 0,\r\n        i = x.length;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        temp = x[i] * k + carry;\r\n        x[i] = temp % base | 0;\r\n        carry = temp / base | 0;\r\n      }\r\n\r\n      if (carry) x.unshift(carry);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, r;\r\n\r\n      if (aL != bL) {\r\n        r = aL > bL ? 1 : -1;\r\n      } else {\r\n        for (i = r = 0; i < aL; i++) {\r\n          if (a[i] != b[i]) {\r\n            r = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return r;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1;) a.shift();\r\n    }\r\n\r\n    return function (x, y, pr, rm, dp, base) {\r\n      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,\r\n        yL, yz,\r\n        Ctor = x.constructor,\r\n        sign = x.s == y.s ? 1 : -1,\r\n        xd = x.d,\r\n        yd = y.d;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.\r\n          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :\r\n\r\n          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.\r\n          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\r\n      }\r\n\r\n      if (base) {\r\n        logBase = 1;\r\n        e = x.e - y.e;\r\n      } else {\r\n        base = BASE;\r\n        logBase = LOG_BASE;\r\n        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\r\n      }\r\n\r\n      yL = yd.length;\r\n      xL = xd.length;\r\n      q = new Ctor(sign);\r\n      qd = q.d = [];\r\n\r\n      // Result exponent may be one less than e.\r\n      // The digit array of a Decimal from toStringBinary may have trailing zeros.\r\n      for (i = 0; yd[i] == (xd[i] || 0); i++);\r\n\r\n      if (yd[i] > (xd[i] || 0)) e--;\r\n\r\n      if (pr == null) {\r\n        sd = pr = Ctor.precision;\r\n        rm = Ctor.rounding;\r\n      } else if (dp) {\r\n        sd = pr + (x.e - y.e) + 1;\r\n      } else {\r\n        sd = pr;\r\n      }\r\n\r\n      if (sd < 0) {\r\n        qd.push(1);\r\n        more = true;\r\n      } else {\r\n\r\n        // Convert precision in number of base 10 digits to base 1e7 digits.\r\n        sd = sd / logBase + 2 | 0;\r\n        i = 0;\r\n\r\n        // divisor < 1e7\r\n        if (yL == 1) {\r\n          k = 0;\r\n          yd = yd[0];\r\n          sd++;\r\n\r\n          // k is the carry.\r\n          for (; (i < xL || k) && sd--; i++) {\r\n            t = k * base + (xd[i] || 0);\r\n            qd[i] = t / yd | 0;\r\n            k = t % yd | 0;\r\n          }\r\n\r\n          more = k || i < xL;\r\n\r\n        // divisor >= 1e7\r\n        } else {\r\n\r\n          // Normalise xd and yd so highest order digit of yd is >= base/2\r\n          k = base / (yd[0] + 1) | 0;\r\n\r\n          if (k > 1) {\r\n            yd = multiplyInteger(yd, k, base);\r\n            xd = multiplyInteger(xd, k, base);\r\n            yL = yd.length;\r\n            xL = xd.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xd.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL;) rem[remL++] = 0;\r\n\r\n          yz = yd.slice();\r\n          yz.unshift(0);\r\n          yd0 = yd[0];\r\n\r\n          if (yd[1] >= base / 2) ++yd0;\r\n\r\n          do {\r\n            k = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yd, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, k.\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // k will be how many times the divisor goes into the current remainder.\r\n              k = rem0 / yd0 | 0;\r\n\r\n              //  Algorithm:\r\n              //  1. product = divisor * trial digit (k)\r\n              //  2. if product > remainder: product -= divisor, k--\r\n              //  3. remainder -= product\r\n              //  4. if product was < remainder at 2:\r\n              //    5. compare new remainder and divisor\r\n              //    6. If remainder > divisor: remainder -= divisor, k++\r\n\r\n              if (k > 1) {\r\n                if (k >= base) k = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiplyInteger(yd, k, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                cmp = compare(prod, rem, prodL, remL);\r\n\r\n                // product > remainder.\r\n                if (cmp == 1) {\r\n                  k--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yd, prodL, base);\r\n                }\r\n              } else {\r\n\r\n                // cmp is -1.\r\n                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\r\n                // to avoid it. If k is 1 there is a need to compare yd and rem again below.\r\n                if (k == 0) cmp = k = 1;\r\n                prod = yd.slice();\r\n              }\r\n\r\n              prodL = prod.length;\r\n              if (prodL < remL) prod.unshift(0);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n\r\n              // If product was < previous remainder.\r\n              if (cmp == -1) {\r\n                remL = rem.length;\r\n\r\n                // Compare divisor and new remainder.\r\n                cmp = compare(yd, rem, yL, remL);\r\n\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                if (cmp < 1) {\r\n                  k++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yd, remL, base);\r\n                }\r\n              }\r\n\r\n              remL = rem.length;\r\n            } else if (cmp === 0) {\r\n              k++;\r\n              rem = [0];\r\n            }    // if cmp === 1, k will be 0\r\n\r\n            // Add the next digit, k, to the result array.\r\n            qd[i++] = k;\r\n\r\n            // Update the remainder.\r\n            if (cmp && rem[0]) {\r\n              rem[remL++] = xd[xi] || 0;\r\n            } else {\r\n              rem = [xd[xi]];\r\n              remL = 1;\r\n            }\r\n\r\n          } while ((xi++ < xL || rem[0] !== void 0) && sd--);\r\n\r\n          more = rem[0] !== void 0;\r\n        }\r\n\r\n        // Leading zero?\r\n        if (!qd[0]) qd.shift();\r\n      }\r\n\r\n      // logBase is 1 when divide is being used for base conversion.\r\n      if (logBase == 1) {\r\n        q.e = e;\r\n        inexact = more;\r\n      } else {\r\n\r\n        // To calculate q.e, first get the number of digits of qd[0].\r\n        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\r\n        q.e = i + e * logBase - 1;\r\n\r\n        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n   * Check for over/under-flow.\r\n   */\r\n   function finalise(x, sd, rm, isTruncated) {\r\n    var digits, i, j, k, rd, roundUp, w, xd, xdi,\r\n      Ctor = x.constructor;\r\n\r\n    // Don't round if sd is null or undefined.\r\n    out: if (sd != null) {\r\n      xd = x.d;\r\n\r\n      // Infinity/NaN.\r\n      if (!xd) return x;\r\n\r\n      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // w: the word of xd containing rd, a base 1e7 number.\r\n      // xdi: the index of w within xd.\r\n      // digits: the number of digits of w.\r\n      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\r\n      // they had leading zeros)\r\n      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\r\n\r\n      // Get the length of the first word of the digits array xd.\r\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\r\n      i = sd - digits;\r\n\r\n      // Is the rounding digit in the first word of xd?\r\n      if (i < 0) {\r\n        i += LOG_BASE;\r\n        j = sd;\r\n        w = xd[xdi = 0];\r\n\r\n        // Get the rounding digit at index j of w.\r\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\r\n      } else {\r\n        xdi = Math.ceil((i + 1) / LOG_BASE);\r\n        k = xd.length;\r\n        if (xdi >= k) {\r\n          if (isTruncated) {\r\n\r\n            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\r\n            for (; k++ <= xdi;) xd.push(0);\r\n            w = rd = 0;\r\n            digits = 1;\r\n            i %= LOG_BASE;\r\n            j = i - LOG_BASE + 1;\r\n          } else {\r\n            break out;\r\n          }\r\n        } else {\r\n          w = k = xd[xdi];\r\n\r\n          // Get the number of digits of w.\r\n          for (digits = 1; k >= 10; k /= 10) digits++;\r\n\r\n          // Get the index of rd within w.\r\n          i %= LOG_BASE;\r\n\r\n          // Get the index of rd within w, adjusted for leading zeros.\r\n          // The number of leading zeros of w is given by LOG_BASE - digits.\r\n          j = i - LOG_BASE + digits;\r\n\r\n          // Get the rounding digit at index j of w.\r\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\r\n        }\r\n      }\r\n\r\n      // Are there any non-zero digits after the rounding digit?\r\n      isTruncated = isTruncated || sd < 0 ||\r\n        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\r\n\r\n      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\r\n      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\r\n      // will give 714.\r\n\r\n      roundUp = rm < 4\r\n        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||\r\n            rm == (x.s < 0 ? 8 : 7));\r\n\r\n      if (sd < 1 || !xd[0]) {\r\n        xd.length = 0;\r\n        if (roundUp) {\r\n\r\n          // Convert sd to decimal places.\r\n          sd -= x.e + 1;\r\n\r\n          // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\r\n          x.e = -sd || 0;\r\n        } else {\r\n\r\n          // Zero.\r\n          xd[0] = x.e = 0;\r\n        }\r\n\r\n        return x;\r\n      }\r\n\r\n      // Remove excess digits.\r\n      if (i == 0) {\r\n        xd.length = xdi;\r\n        k = 1;\r\n        xdi--;\r\n      } else {\r\n        xd.length = xdi + 1;\r\n        k = mathpow(10, LOG_BASE - i);\r\n\r\n        // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n        // j > 0 means i > number of leading zeros of w.\r\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\r\n      }\r\n\r\n      if (roundUp) {\r\n        for (;;) {\r\n\r\n          // Is the digit to be rounded up in the first word of xd?\r\n          if (xdi == 0) {\r\n\r\n            // i will be the length of xd[0] before k is added.\r\n            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\r\n            j = xd[0] += k;\r\n            for (k = 1; j >= 10; j /= 10) k++;\r\n\r\n            // if i != k the length has increased.\r\n            if (i != k) {\r\n              x.e++;\r\n              if (xd[0] == BASE) xd[0] = 1;\r\n            }\r\n\r\n            break;\r\n          } else {\r\n            xd[xdi] += k;\r\n            if (xd[xdi] != BASE) break;\r\n            xd[xdi--] = 0;\r\n            k = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove trailing zeros.\r\n      for (i = xd.length; xd[--i] === 0;) xd.pop();\r\n    }\r\n\r\n    if (external) {\r\n\r\n      // Overflow?\r\n      if (x.e > Ctor.maxE) {\r\n\r\n        // Infinity.\r\n        x.d = null;\r\n        x.e = NaN;\r\n\r\n      // Underflow?\r\n      } else if (x.e < Ctor.minE) {\r\n\r\n        // Zero.\r\n        x.e = 0;\r\n        x.d = [0];\r\n        // Ctor.underflow = true;\r\n      } // else Ctor.underflow = false;\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function finiteToString(x, isExp, sd) {\r\n    if (!x.isFinite()) return nonFiniteToString(x);\r\n    var k,\r\n      e = x.e,\r\n      str = digitsToString(x.d),\r\n      len = str.length;\r\n\r\n    if (isExp) {\r\n      if (sd && (k = sd - len) > 0) {\r\n        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\r\n      } else if (len > 1) {\r\n        str = str.charAt(0) + '.' + str.slice(1);\r\n      }\r\n\r\n      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;\r\n    } else if (e < 0) {\r\n      str = '0.' + getZeroString(-e - 1) + str;\r\n      if (sd && (k = sd - len) > 0) str += getZeroString(k);\r\n    } else if (e >= len) {\r\n      str += getZeroString(e + 1 - len);\r\n      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\r\n    } else {\r\n      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\r\n      if (sd && (k = sd - len) > 0) {\r\n        if (e + 1 === len) str += '.';\r\n        str += getZeroString(k);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // Calculate the base 10 exponent from the base 1e7 exponent.\r\n  function getBase10Exponent(digits, e) {\r\n\r\n    // First get the number of digits of the first word of the digits array.\r\n    for (var i = 1, w = digits[0]; w >= 10; w /= 10) i++;\r\n    return i + e * LOG_BASE - 1;\r\n  }\r\n\r\n\r\n   function getLn10(Ctor, sd, pr) {\r\n    if (sd > LN10_PRECISION) {\r\n\r\n      // Reset global state in case the exception is caught.\r\n      external = true;\r\n      if (pr) Ctor.precision = pr;\r\n      throw Error(precisionLimitExceeded);\r\n    }\r\n    return finalise(new Ctor(LN10), sd, 1, true);\r\n  }\r\n\r\n\r\n  function getPi(Ctor, sd, rm) {\r\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\r\n    return finalise(new Ctor(PI), sd, rm, true);\r\n  }\r\n\r\n\r\n  function getPrecision(digits) {\r\n    var w = digits.length - 1,\r\n      len = w * LOG_BASE + 1;\r\n\r\n    w = digits[w];\r\n\r\n    // If non-zero...\r\n    if (w) {\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      for (; w % 10 == 0; w /= 10) len--;\r\n\r\n      // Add the number of digits of the first word.\r\n      for (w = digits[0]; w >= 10; w /= 10) len++;\r\n    }\r\n\r\n    return len;\r\n  }\r\n\r\n\r\n  function getZeroString(k) {\r\n    var zs = '';\r\n    for (; k--;) zs += '0';\r\n    return zs;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n   * integer of type number.\r\n   *\r\n   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n   *\r\n   */\r\n  function intPow(Ctor, x, n, pr) {\r\n    var isTruncated,\r\n      r = new Ctor(1),\r\n\r\n      // Max n of 9007199254740991 takes 53 loop iterations.\r\n      // Maximum digits array length; leaves [28, 34] guard digits.\r\n      k = Math.ceil(pr / LOG_BASE + 4);\r\n\r\n    external = false;\r\n\r\n    for (;;) {\r\n      if (n % 2) {\r\n        r = r.times(x);\r\n        if (truncate(r.d, k)) isTruncated = true;\r\n      }\r\n\r\n      n = mathfloor(n / 2);\r\n      if (n === 0) {\r\n\r\n        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\r\n        n = r.d.length - 1;\r\n        if (isTruncated && r.d[n] === 0) ++r.d[n];\r\n        break;\r\n      }\r\n\r\n      x = x.times(x);\r\n      truncate(x.d, k);\r\n    }\r\n\r\n    external = true;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  function isOdd(n) {\r\n    return n.d[n.d.length - 1] & 1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n   */\r\n  function maxOrMin(Ctor, args, ltgt) {\r\n    var y,\r\n      x = new Ctor(args[0]),\r\n      i = 0;\r\n\r\n    for (; ++i < args.length;) {\r\n      y = new Ctor(args[i]);\r\n      if (!y.s) {\r\n        x = y;\r\n        break;\r\n      } else if (x[ltgt](y)) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   * Taylor/Maclaurin series.\r\n   *\r\n   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n   *\r\n   * Argument reduction:\r\n   *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n   *   exp(x) = exp(x / 2^k)^(2^k)\r\n   *\r\n   * Previously, the argument was initially reduced by\r\n   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n   * found to be slower than just dividing repeatedly by 32 as above.\r\n   *\r\n   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n   *\r\n   *  exp(Infinity)  = Infinity\r\n   *  exp(-Infinity) = 0\r\n   *  exp(NaN)       = NaN\r\n   *  exp(±0)        = 1\r\n   *\r\n   *  exp(x) is non-terminating for any finite, non-zero x.\r\n   *\r\n   *  The result will always be correctly rounded.\r\n   *\r\n   */\r\n  function naturalExponential(x, sd) {\r\n    var denominator, guard, j, pow, sum, t, wpr,\r\n      rep = 0,\r\n      i = 0,\r\n      k = 0,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // 0/NaN/Infinity?\r\n    if (!x.d || !x.d[0] || x.e > 17) {\r\n\r\n      return new Ctor(x.d\r\n        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0\r\n        : x.s ? x.s < 0 ? 0 : x : 0 / 0);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    t = new Ctor(0.03125);\r\n\r\n    // while abs(x) >= 0.1\r\n    while (x.e > -2) {\r\n\r\n      // x = x / 2^5\r\n      x = x.times(t);\r\n      k += 5;\r\n    }\r\n\r\n    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\r\n    // necessary to ensure the first 4 rounding digits are correct.\r\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\r\n    wpr += guard;\r\n    denominator = pow = sum = new Ctor(1);\r\n    Ctor.precision = wpr;\r\n\r\n    for (;;) {\r\n      pow = finalise(pow.times(x), wpr, 1);\r\n      denominator = denominator.times(++i);\r\n      t = sum.plus(divide(pow, denominator, wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        j = k;\r\n        while (j--) sum = finalise(sum.times(sum), wpr, 1);\r\n\r\n        // Check to see if the first 4 rounding digits are [49]999.\r\n        // If so, repeat the summation with a higher precision, otherwise\r\n        // e.g. with precision: 18, rounding: 1\r\n        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n\r\n          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += 10;\r\n            denominator = pow = t = new Ctor(1);\r\n            i = 0;\r\n            rep++;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   *  ln(-n)        = NaN\r\n   *  ln(0)         = -Infinity\r\n   *  ln(-0)        = -Infinity\r\n   *  ln(1)         = 0\r\n   *  ln(Infinity)  = Infinity\r\n   *  ln(-Infinity) = NaN\r\n   *  ln(NaN)       = NaN\r\n   *\r\n   *  ln(n) (n != 1) is non-terminating.\r\n   *\r\n   */\r\n  function naturalLogarithm(y, sd) {\r\n    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,\r\n      n = 1,\r\n      guard = 10,\r\n      x = y,\r\n      xd = x.d,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // Is x negative or Infinity, NaN, 0 or 1?\r\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\r\n      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    Ctor.precision = wpr += guard;\r\n    c = digitsToString(xd);\r\n    c0 = c.charAt(0);\r\n\r\n    if (Math.abs(e = x.e) < 1.5e15) {\r\n\r\n      // Argument reduction.\r\n      // The series converges faster the closer the argument is to 1, so using\r\n      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\r\n      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\r\n      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\r\n      // later be divided by this number, then separate out the power of 10 using\r\n      // ln(a*10^b) = ln(a) + b*ln(10).\r\n\r\n      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\r\n      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\r\n      // max n is 6 (gives 0.7 - 1.3)\r\n      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\r\n        x = x.times(y);\r\n        c = digitsToString(x.d);\r\n        c0 = c.charAt(0);\r\n        n++;\r\n      }\r\n\r\n      e = x.e;\r\n\r\n      if (c0 > 1) {\r\n        x = new Ctor('0.' + c);\r\n        e++;\r\n      } else {\r\n        x = new Ctor(c0 + '.' + c.slice(1));\r\n      }\r\n    } else {\r\n\r\n      // The argument reduction method above may result in overflow if the argument y is a massive\r\n      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\r\n      // function using ln(x*10^e) = ln(x) + e*ln(10).\r\n      t = getLn10(Ctor, wpr + 2, pr).times(e + '');\r\n      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\r\n      Ctor.precision = pr;\r\n\r\n      return sd == null ? finalise(x, pr, rm, external = true) : x;\r\n    }\r\n\r\n    // x1 is x reduced to a value near 1.\r\n    x1 = x;\r\n\r\n    // Taylor series.\r\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\r\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\r\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\r\n    x2 = finalise(x.times(x), wpr, 1);\r\n    denominator = 3;\r\n\r\n    for (;;) {\r\n      numerator = finalise(numerator.times(x2), wpr, 1);\r\n      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        sum = sum.times(2);\r\n\r\n        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\r\n        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\r\n        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\r\n        sum = divide(sum, new Ctor(n), wpr, 1);\r\n\r\n        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\r\n        // been repeated previously) and the first 4 rounding digits 9999?\r\n        // If so, restart the summation with a higher precision, otherwise\r\n        // e.g. with precision: 12, rounding: 1\r\n        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += guard;\r\n            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\r\n            x2 = finalise(x.times(x), wpr, 1);\r\n            denominator = rep = 1;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n      denominator += 2;\r\n    }\r\n  }\r\n\r\n\r\n  // ±Infinity, NaN.\r\n  function nonFiniteToString(x) {\r\n    // Unsigned.\r\n    return String(x.s * x.s / 0);\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from string `str`.\r\n   */\r\n  function parseDecimal(x, str) {\r\n    var e, i, len;\r\n\r\n    // Decimal point?\r\n    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = str.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +str.slice(i + 1);\r\n      str = str.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);\r\n    str = str.slice(i, len);\r\n\r\n    if (str) {\r\n      len -= i;\r\n      x.e = e = e - i - 1;\r\n      x.d = [];\r\n\r\n      // Transform base\r\n\r\n      // e is the base 10 exponent.\r\n      // i is where to slice str to get the first word of the digits array.\r\n      i = (e + 1) % LOG_BASE;\r\n      if (e < 0) i += LOG_BASE;\r\n\r\n      if (i < len) {\r\n        if (i) x.d.push(+str.slice(0, i));\r\n        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\r\n        str = str.slice(i);\r\n        i = LOG_BASE - str.length;\r\n      } else {\r\n        i -= len;\r\n      }\r\n\r\n      for (; i--;) str += '0';\r\n      x.d.push(+str);\r\n\r\n      if (external) {\r\n\r\n        // Overflow?\r\n        if (x.e > x.constructor.maxE) {\r\n\r\n          // Infinity.\r\n          x.d = null;\r\n          x.e = NaN;\r\n\r\n        // Underflow?\r\n        } else if (x.e < x.constructor.minE) {\r\n\r\n          // Zero.\r\n          x.e = 0;\r\n          x.d = [0];\r\n          // x.constructor.underflow = true;\r\n        } // else x.constructor.underflow = false;\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.e = 0;\r\n      x.d = [0];\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n   */\r\n  function parseOther(x, str) {\r\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\r\n\r\n    if (str === 'Infinity' || str === 'NaN') {\r\n      if (!+str) x.s = NaN;\r\n      x.e = NaN;\r\n      x.d = null;\r\n      return x;\r\n    }\r\n\r\n    if (isHex.test(str))  {\r\n      base = 16;\r\n      str = str.toLowerCase();\r\n    } else if (isBinary.test(str))  {\r\n      base = 2;\r\n    } else if (isOctal.test(str))  {\r\n      base = 8;\r\n    } else {\r\n      throw Error(invalidArgument + str);\r\n    }\r\n\r\n    // Is there a binary exponent part?\r\n    i = str.search(/p/i);\r\n\r\n    if (i > 0) {\r\n      p = +str.slice(i + 1);\r\n      str = str.substring(2, i);\r\n    } else {\r\n      str = str.slice(2);\r\n    }\r\n\r\n    // Convert `str` as an integer then divide the result by `base` raised to a power such that the\r\n    // fraction part will be restored.\r\n    i = str.indexOf('.');\r\n    isFloat = i >= 0;\r\n    Ctor = x.constructor;\r\n\r\n    if (isFloat) {\r\n      str = str.replace('.', '');\r\n      len = str.length;\r\n      i = len - i;\r\n\r\n      // log[10](16) = 1.2041... , log[10](88) = 1.9444....\r\n      divisor = intPow(Ctor, new Ctor(base), i, i * 2);\r\n    }\r\n\r\n    xd = convertBase(str, base, BASE);\r\n    xe = xd.length - 1;\r\n\r\n    // Remove trailing zeros.\r\n    for (i = xe; xd[i] === 0; --i) xd.pop();\r\n    if (i < 0) return new Ctor(x.s * 0);\r\n    x.e = getBase10Exponent(xd, xe);\r\n    x.d = xd;\r\n    external = false;\r\n\r\n    // At what precision to perform the division to ensure exact conversion?\r\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\r\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\r\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\r\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\r\n    // Therefore using 4 * the number of digits of str will always be enough.\r\n    if (isFloat) x = divide(x, divisor, len * 4);\r\n\r\n    // Multiply by the binary exponent part if present.\r\n    if (p) x = x.times(Math.abs(p) < 54 ? Math.pow(2, p) : Decimal.pow(2, p));\r\n    external = true;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function sine(Ctor, x) {\r\n    var k,\r\n      len = x.d.length;\r\n\r\n    if (len < 3) return taylorSeries(Ctor, 2, x, x);\r\n\r\n    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\r\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\r\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    k = 1.4 * Math.sqrt(len);\r\n    k = k > 16 ? 16 : k | 0;\r\n\r\n    // Max k before Math.pow precision loss is 22\r\n    x = x.times(Math.pow(5, -k));\r\n    x = taylorSeries(Ctor, 2, x, x);\r\n\r\n    // Reverse argument reduction\r\n    var sin2_x,\r\n      d5 = new Ctor(5),\r\n      d16 = new Ctor(16),\r\n      d20 = new Ctor(20);\r\n    for (; k--;) {\r\n      sin2_x = x.times(x);\r\n      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\r\n  function taylorSeries(Ctor, n, x, y, isHyperbolic) {\r\n    var j, t, u, x2,\r\n      i = 1,\r\n      pr = Ctor.precision,\r\n      k = Math.ceil(pr / LOG_BASE);\r\n\r\n    external = false;\r\n    x2 = x.times(x);\r\n    u = new Ctor(y);\r\n\r\n    for (;;) {\r\n      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      u = isHyperbolic ? y.plus(t) : y.minus(t);\r\n      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      t = u.plus(y);\r\n\r\n      if (t.d[k] !== void 0) {\r\n        for (j = k; t.d[j] === u.d[j] && j--;);\r\n        if (j == -1) break;\r\n      }\r\n\r\n      j = u;\r\n      u = y;\r\n      y = t;\r\n      t = j;\r\n      i++;\r\n    }\r\n\r\n    external = true;\r\n    t.d.length = k + 1;\r\n\r\n    return t;\r\n  }\r\n\r\n\r\n  // Return the absolute value of `x` reduced to less than or equal to half pi.\r\n  function toLessThanHalfPi(Ctor, x) {\r\n    var t,\r\n      isNeg = x.s < 0,\r\n      pi = getPi(Ctor, Ctor.precision, 1),\r\n      halfPi = pi.times(0.5);\r\n\r\n    x = x.abs();\r\n\r\n    if (x.lte(halfPi)) {\r\n      quadrant = isNeg ? 4 : 1;\r\n      return x;\r\n    }\r\n\r\n    t = x.divToInt(pi);\r\n\r\n    if (t.isZero()) {\r\n      quadrant = isNeg ? 3 : 2;\r\n    } else {\r\n      x = x.minus(t.times(pi));\r\n\r\n      // 0 <= x < pi\r\n      if (x.lte(halfPi)) {\r\n        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);\r\n        return x;\r\n      }\r\n\r\n      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);\r\n    }\r\n\r\n    return x.minus(pi).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return the value of Decimal `x` as a string in base `baseOut`.\r\n   *\r\n   * If the optional `sd` argument is present include a binary exponent suffix.\r\n   */\r\n  function toStringBinary(x, baseOut, sd, rm) {\r\n    var base, e, i, k, len, roundUp, str, xd, y,\r\n      Ctor = x.constructor,\r\n      isExp = sd !== void 0;\r\n\r\n    if (isExp) {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    } else {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    }\r\n\r\n    if (!x.isFinite()) {\r\n      str = nonFiniteToString(x);\r\n    } else {\r\n      str = finiteToString(x);\r\n      i = str.indexOf('.');\r\n\r\n      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\r\n      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\r\n      // minBinaryExponent = floor(decimalExponent * log[2](10))\r\n      // log[2](10) = 3.321928094887362347870319429489390175864\r\n\r\n      if (isExp) {\r\n        base = 2;\r\n        if (baseOut == 16) {\r\n          sd = sd * 4 - 3;\r\n        } else if (baseOut == 8) {\r\n          sd = sd * 3 - 2;\r\n        }\r\n      } else {\r\n        base = baseOut;\r\n      }\r\n\r\n      // Convert the number as an integer then divide the result by its base raised to a power such\r\n      // that the fraction part will be restored.\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        str = str.replace('.', '');\r\n        y = new Ctor(1);\r\n        y.e = str.length - i;\r\n        y.d = convertBase(finiteToString(y), 10, base);\r\n        y.e = y.d.length;\r\n      }\r\n\r\n      xd = convertBase(str, 10, base);\r\n      e = len = xd.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xd[--len] == 0;) xd.pop();\r\n\r\n      if (!xd[0]) {\r\n        str = isExp ? '0p+0' : '0';\r\n      } else {\r\n        if (i < 0) {\r\n          e--;\r\n        } else {\r\n          x = new Ctor(x);\r\n          x.d = xd;\r\n          x.e = e;\r\n          x = divide(x, y, sd, rm, 0, base);\r\n          xd = x.d;\r\n          e = x.e;\r\n          roundUp = inexact;\r\n        }\r\n\r\n        // The rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        i = xd[sd];\r\n        k = base / 2;\r\n        roundUp = roundUp || xd[sd + 1] !== void 0;\r\n\r\n        roundUp = rm < 4\r\n          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))\r\n          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||\r\n            rm === (x.s < 0 ? 8 : 7));\r\n\r\n        xd.length = sd;\r\n\r\n        if (roundUp) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (; ++xd[--sd] > base - 1;) {\r\n            xd[sd] = 0;\r\n            if (!sd) {\r\n              ++e;\r\n              xd.unshift(1);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n\r\n        // Add binary exponent suffix?\r\n        if (isExp) {\r\n          if (len > 1) {\r\n            if (baseOut == 16 || baseOut == 8) {\r\n              i = baseOut == 16 ? 4 : 3;\r\n              for (--len; len % i; len++) str += '0';\r\n              xd = convertBase(str, base, baseOut);\r\n              for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n              // xd[0] will always be be 1\r\n              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n            } else {\r\n              str = str.charAt(0) + '.' + str.slice(1);\r\n            }\r\n          }\r\n\r\n          str =  str + (e < 0 ? 'p' : 'p+') + e;\r\n        } else if (e < 0) {\r\n          for (; ++e;) str = '0' + str;\r\n          str = '0.' + str;\r\n        } else {\r\n          if (++e > len) for (e -= len; e-- ;) str += '0';\r\n          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);\r\n        }\r\n      }\r\n\r\n      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;\r\n    }\r\n\r\n    return x.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Does not strip trailing zeros.\r\n  function truncate(arr, len) {\r\n    if (arr.length > len) {\r\n      arr.length = len;\r\n      return true;\r\n    }\r\n  }\r\n\r\n\r\n  // Decimal methods\r\n\r\n\r\n  /*\r\n   *  abs\r\n   *  acos\r\n   *  acosh\r\n   *  add\r\n   *  asin\r\n   *  asinh\r\n   *  atan\r\n   *  atanh\r\n   *  atan2\r\n   *  cbrt\r\n   *  ceil\r\n   *  clone\r\n   *  config\r\n   *  cos\r\n   *  cosh\r\n   *  div\r\n   *  exp\r\n   *  floor\r\n   *  hypot\r\n   *  ln\r\n   *  log\r\n   *  log2\r\n   *  log10\r\n   *  max\r\n   *  min\r\n   *  mod\r\n   *  mul\r\n   *  pow\r\n   *  random\r\n   *  round\r\n   *  sign\r\n   *  sin\r\n   *  sinh\r\n   *  sqrt\r\n   *  sub\r\n   *  tan\r\n   *  tanh\r\n   *  trunc\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function abs(x) {\r\n    return new this(x).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function acos(x) {\r\n    return new this(x).acos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function acosh(x) {\r\n    return new this(x).acosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function add(x, y) {\r\n    return new this(x).plus(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function asin(x) {\r\n    return new this(x).asin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function asinh(x) {\r\n    return new this(x).asinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function atan(x) {\r\n    return new this(x).atan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function atanh(x) {\r\n    return new this(x).atanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi, pi]\r\n   *\r\n   * y {number|string|Decimal} The y-coordinate.\r\n   * x {number|string|Decimal} The x-coordinate.\r\n   *\r\n   * atan2(±0, -0)               = ±pi\r\n   * atan2(±0, +0)               = ±0\r\n   * atan2(±0, -x)               = ±pi for x > 0\r\n   * atan2(±0, x)                = ±0 for x > 0\r\n   * atan2(-y, ±0)               = -pi/2 for y > 0\r\n   * atan2(y, ±0)                = pi/2 for y > 0\r\n   * atan2(±y, -Infinity)        = ±pi for finite y > 0\r\n   * atan2(±y, +Infinity)        = ±0 for finite y > 0\r\n   * atan2(±Infinity, x)         = ±pi/2 for finite x\r\n   * atan2(±Infinity, -Infinity) = ±3*pi/4\r\n   * atan2(±Infinity, +Infinity) = ±pi/4\r\n   * atan2(NaN, x) = NaN\r\n   * atan2(y, NaN) = NaN\r\n   *\r\n   */\r\n  function atan2(y, x) {\r\n    y = new this(y);\r\n    x = new this(x);\r\n    var r,\r\n      pr = this.precision,\r\n      rm = this.rounding,\r\n      wpr = pr + 4;\r\n\r\n    // Either NaN\r\n    if (!y.s || !x.s) {\r\n      r = new this(NaN);\r\n\r\n    // Both ±Infinity\r\n    } else if (!y.d && !x.d) {\r\n      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\r\n      r.s = y.s;\r\n\r\n    // x is ±Infinity or y is ±0\r\n    } else if (!x.d || y.isZero()) {\r\n      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\r\n      r.s = y.s;\r\n\r\n    // y is ±Infinity or x is ±0\r\n    } else if (!y.d || x.isZero()) {\r\n      r = getPi(this, wpr, 1).times(0.5);\r\n      r.s = y.s;\r\n\r\n    // Both non-zero and finite\r\n    } else if (x.s < 0) {\r\n      this.precision = wpr;\r\n      this.rounding = 1;\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n      x = getPi(this, wpr, 1);\r\n      this.precision = pr;\r\n      this.rounding = rm;\r\n      r = y.s < 0 ? r.minus(x) : r.plus(x);\r\n    } else {\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function cbrt(x) {\r\n    return new this(x).cbrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ceil(x) {\r\n    return finalise(x = new this(x), x.e + 1, 2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Configure global settings for a Decimal constructor.\r\n   *\r\n   * `obj` is an object with one or more of the following properties,\r\n   *\r\n   *   precision  {number}\r\n   *   rounding   {number}\r\n   *   toExpNeg   {number}\r\n   *   toExpPos   {number}\r\n   *   maxE       {number}\r\n   *   minE       {number}\r\n   *   modulo     {number}\r\n   *   crypto     {boolean|number|undefined}\r\n   *\r\n   * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n   *\r\n   */\r\n  function config(obj) {\r\n    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');\r\n    var i, p, v,\r\n      ps = [\r\n        'precision', 1, MAX_DIGITS,\r\n        'rounding', 0, 8,\r\n        'toExpNeg', -EXP_LIMIT, 0,\r\n        'toExpPos', 0, EXP_LIMIT,\r\n        'maxE', 0, EXP_LIMIT,\r\n        'minE', -EXP_LIMIT, 0,\r\n        'modulo', 0, 9\r\n      ];\r\n\r\n    for (i = 0; i < ps.length; i += 3) {\r\n      if ((v = obj[p = ps[i]]) !== void 0) {\r\n        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\r\n        else throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    if (obj.hasOwnProperty(p = 'crypto')) {\r\n      if ((v = obj[p]) === void 0) {\r\n        this[p] = v;\r\n      } else if (v === true || v === false || v === 0 || v === 1) {\r\n        this[p] = !!(v && cryptoObject &&\r\n            (cryptoObject.getRandomValues || cryptoObject.randomBytes));\r\n      } else {\r\n        throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cos(x) {\r\n    return new this(x).cos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cosh(x) {\r\n    return new this(x).cosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n   * constructor.\r\n   *\r\n   */\r\n  function clone(obj) {\r\n    var i, p, ps;\r\n\r\n    /*\r\n     * The Decimal constructor and exported function.\r\n     * Return a new Decimal instance.\r\n     *\r\n     * v {number|string|Decimal} A numeric value.\r\n     *\r\n     */\r\n    function Decimal(v) {\r\n      var e, i, t,\r\n        x = this;\r\n\r\n      // Decimal called without new.\r\n      if (!(x instanceof Decimal)) return new Decimal(v);\r\n\r\n      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\r\n      // which points to Object.\r\n      x.constructor = Decimal;\r\n\r\n      // Duplicate.\r\n      if (v instanceof Decimal) {\r\n        x.s = v.s;\r\n        x.e = v.e;\r\n        x.d = (v = v.d) ? v.slice() : v;\r\n        return;\r\n      }\r\n\r\n      t = typeof v;\r\n\r\n      if (t === 'number') {\r\n        if (v === 0) {\r\n          x.s = 1 / v < 0 ? -1 : 1;\r\n          x.e = 0;\r\n          x.d = [0];\r\n          return;\r\n        }\r\n\r\n        if (v < 0) {\r\n          v = -v;\r\n          x.s = -1;\r\n        } else {\r\n          x.s = 1;\r\n        }\r\n\r\n        // Fast path for small integers.\r\n        if (v === ~~v && v < 1e7) {\r\n          for (e = 0, i = v; i >= 10; i /= 10) e++;\r\n          x.e = e;\r\n          x.d = [v];\r\n          return;\r\n\r\n        // Infinity, NaN.\r\n        } else if (v * 0 !== 0) {\r\n          if (!v) x.s = NaN;\r\n          x.e = NaN;\r\n          x.d = null;\r\n          return;\r\n        }\r\n\r\n        return parseDecimal(x, v.toString());\r\n\r\n      } else if (t !== 'string') {\r\n        throw Error(invalidArgument + v);\r\n      }\r\n\r\n      // Minus sign?\r\n      if (v.charCodeAt(0) === 45) {\r\n        v = v.slice(1);\r\n        x.s = -1;\r\n      } else {\r\n        x.s = 1;\r\n      }\r\n\r\n      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\r\n    }\r\n\r\n    Decimal.prototype = P;\r\n\r\n    Decimal.ROUND_UP = 0;\r\n    Decimal.ROUND_DOWN = 1;\r\n    Decimal.ROUND_CEIL = 2;\r\n    Decimal.ROUND_FLOOR = 3;\r\n    Decimal.ROUND_HALF_UP = 4;\r\n    Decimal.ROUND_HALF_DOWN = 5;\r\n    Decimal.ROUND_HALF_EVEN = 6;\r\n    Decimal.ROUND_HALF_CEIL = 7;\r\n    Decimal.ROUND_HALF_FLOOR = 8;\r\n    Decimal.EUCLID = 9;\r\n\r\n    Decimal.config = config;\r\n    Decimal.clone = clone;\r\n\r\n    Decimal.abs = abs;\r\n    Decimal.acos = acos;\r\n    Decimal.acosh = acosh;        // ES6\r\n    Decimal.add = add;\r\n    Decimal.asin = asin;\r\n    Decimal.asinh = asinh;        // ES6\r\n    Decimal.atan = atan;\r\n    Decimal.atanh = atanh;        // ES6\r\n    Decimal.atan2 = atan2;\r\n    Decimal.cbrt = cbrt;          // ES6\r\n    Decimal.ceil = ceil;\r\n    Decimal.cos = cos;\r\n    Decimal.cosh = cosh;          // ES6\r\n    Decimal.div = div;\r\n    Decimal.exp = exp;\r\n    Decimal.floor = floor;\r\n    Decimal.hypot = hypot;        // ES6\r\n    Decimal.ln = ln;\r\n    Decimal.log = log;\r\n    Decimal.log10 = log10;        // ES6\r\n    Decimal.log2 = log2;          // ES6\r\n    Decimal.max = max;\r\n    Decimal.min = min;\r\n    Decimal.mod = mod;\r\n    Decimal.mul = mul;\r\n    Decimal.pow = pow;\r\n    Decimal.random = random;\r\n    Decimal.round = round;\r\n    Decimal.sign = sign;          // ES6\r\n    Decimal.sin = sin;\r\n    Decimal.sinh = sinh;          // ES6\r\n    Decimal.sqrt = sqrt;\r\n    Decimal.sub = sub;\r\n    Decimal.tan = tan;\r\n    Decimal.tanh = tanh;          // ES6\r\n    Decimal.trunc = trunc;        // ES6\r\n\r\n    if (obj === void 0) obj = {};\r\n    if (obj) {\r\n      ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];\r\n      for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\r\n    }\r\n\r\n    Decimal.config(obj);\r\n\r\n    return Decimal;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function div(x, y) {\r\n    return new this(x).div(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n   *\r\n   */\r\n  function exp(x) {\r\n    return new this(x).exp();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function floor(x) {\r\n    return finalise(x = new this(x), x.e + 1, 3);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n   *\r\n   */\r\n  function hypot() {\r\n    var i, n,\r\n      t = new this(0);\r\n\r\n    external = false;\r\n\r\n    for (i = 0; i < arguments.length;) {\r\n      n = new this(arguments[i++]);\r\n      if (!n.d) {\r\n        if (n.s) {\r\n          external = true;\r\n          return new this(1 / 0);\r\n        }\r\n        t = n;\r\n      } else if (t.d) {\r\n        t = t.plus(n.times(n));\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return t.sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ln(x) {\r\n    return new this(x).ln();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * log[y](x)\r\n   *\r\n   * x {number|string|Decimal} The argument of the logarithm.\r\n   * y {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  function log(x, y) {\r\n    return new this(x).log(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log2(x) {\r\n    return new this(x).log(2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log10(x) {\r\n    return new this(x).log(10);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function max() {\r\n    return maxOrMin(this, arguments, 'lt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function min() {\r\n    return maxOrMin(this, arguments, 'gt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mod(x, y) {\r\n    return new this(x).mod(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mul(x, y) {\r\n    return new this(x).mul(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The base.\r\n   * y {number|string|Decimal} The exponent.\r\n   *\r\n   */\r\n  function pow(x, y) {\r\n    return new this(x).pow(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n   * are produced).\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n   *\r\n   */\r\n  function random(sd) {\r\n    var d, e, k, n,\r\n      i = 0,\r\n      r = new this(1),\r\n      rd = [];\r\n\r\n    if (sd === void 0) sd = this.precision;\r\n    else checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    k = Math.ceil(sd / LOG_BASE);\r\n\r\n    if (this.crypto === false) {\r\n      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;\r\n\r\n    // Browsers supporting crypto.getRandomValues.\r\n    } else if (cryptoObject && cryptoObject.getRandomValues) {\r\n      d = cryptoObject.getRandomValues(new Uint32Array(k));\r\n\r\n      for (; i < k;) {\r\n        n = d[i];\r\n\r\n        // 0 <= n < 4294967296\r\n        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\r\n        if (n >= 4.29e9) {\r\n          d[i] = cryptoObject.getRandomValues(new Uint32Array(1))[0];\r\n        } else {\r\n\r\n          // 0 <= n <= 4289999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd[i++] = n % 1e7;\r\n        }\r\n      }\r\n\r\n    // Node.js supporting crypto.randomBytes.\r\n    } else if (cryptoObject && cryptoObject.randomBytes) {\r\n\r\n      // buffer\r\n      d = cryptoObject.randomBytes(k *= 4);\r\n\r\n      for (; i < k;) {\r\n\r\n        // 0 <= n < 2147483648\r\n        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\r\n\r\n        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\r\n        if (n >= 2.14e9) {\r\n          cryptoObject.randomBytes(4).copy(d, i);\r\n        } else {\r\n\r\n          // 0 <= n <= 2139999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd.push(n % 1e7);\r\n          i += 4;\r\n        }\r\n      }\r\n\r\n      i = k / 4;\r\n    } else if (this.crypto) {\r\n      throw Error(decimalError + 'crypto unavailable');\r\n    } else {\r\n      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;\r\n    }\r\n\r\n    k = rd[--i];\r\n    sd %= LOG_BASE;\r\n\r\n    // Convert trailing digits to zeros according to sd.\r\n    if (k && sd) {\r\n      n = mathpow(10, LOG_BASE - sd);\r\n      rd[i] = (k / n | 0) * n;\r\n    }\r\n\r\n    // Remove trailing words which are zero.\r\n    for (; rd[i] === 0; i--) rd.pop();\r\n\r\n    // Zero?\r\n    if (i < 0) {\r\n      e = 0;\r\n      rd = [0];\r\n    } else {\r\n      e = -1;\r\n\r\n      // Remove leading words which are zero and adjust exponent accordingly.\r\n      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\r\n\r\n      // Count the digits of the first word of rd to determine leading zeros.\r\n      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\r\n\r\n      // Adjust the exponent for leading zeros of the first word of rd.\r\n      if (k < LOG_BASE) e -= LOG_BASE - k;\r\n    }\r\n\r\n    r.e = e;\r\n    r.d = rd;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n   *\r\n   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function round(x) {\r\n    return finalise(x = new this(x), x.e + 1, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if x > 0,\r\n   *  -1    if x < 0,\r\n   *   0    if x is 0,\r\n   *  -0    if x is -0,\r\n   *   NaN  otherwise\r\n   *\r\n   */\r\n  function sign(x) {\r\n    x = new this(x);\r\n    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sin(x) {\r\n    return new this(x).sin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sinh(x) {\r\n    return new this(x).sinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sqrt(x) {\r\n    return new this(x).sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function sub(x, y) {\r\n    return new this(x).sub(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tan(x) {\r\n    return new this(x).tan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tanh(x) {\r\n    return new this(x).tanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` truncated to an integer.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function trunc(x) {\r\n    return finalise(x = new this(x), x.e + 1, 1);\r\n  }\r\n\r\n\r\n  // Create and configure initial Decimal constructor.\r\n  Decimal = clone(Decimal);\r\n\r\n  // Create the internal constants from their string values.\r\n  LN10 = new Decimal(LN10);\r\n  PI = new Decimal(PI);\r\n\r\n\r\n  // Export.\r\n\r\n\r\n  // AMD.\r\n  if (typeof define == 'function' && define.amd) {\r\n    define(function () {\r\n      return Decimal;\r\n    });\r\n\r\n  // Node and other environments that support module.exports.\r\n  } else if (typeof module != 'undefined' && module.exports) {\r\n    module.exports = Decimal;\r\n\r\n    if (!cryptoObject) {\r\n      try {\r\n        cryptoObject = require('cry' + 'pto');\r\n      } catch (e) {\r\n        // Ignore.\r\n      }\r\n    }\r\n\r\n  // Browser.\r\n  } else {\r\n    if (!globalScope) {\r\n      globalScope = typeof self != 'undefined' && self && self.self == self\r\n        ? self : Function('return this')();\r\n    }\r\n\r\n    noConflict = globalScope.Decimal;\r\n    Decimal.noConflict = function () {\r\n      globalScope.Decimal = noConflict;\r\n      return Decimal;\r\n    };\r\n\r\n    globalScope.Decimal = Decimal;\r\n  }\r\n})(this);\r\n","\"use strict\";\n/*\n * Copyright 2010-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\").\n * You may not use this file except in compliance with the License.\n * A copy of the License is located at\n *\n * http://aws.amazon.com/apache2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DynamoDBManager_1 = require(\"./dynamodb/DynamoDBManager\");\nvar S2Manager_1 = require(\"./s2/S2Manager\");\nvar S2Util_1 = require(\"./s2/S2Util\");\nvar nodes2ts_1 = require(\"nodes2ts\");\nvar Covering_1 = require(\"./model/Covering\");\n/**\n * <p>\n * Manager to hangle geo spatial data in Amazon DynamoDB tables. All service calls made using this client are blocking,\n * and will not return until the service call completes.\n * </p>\n * <p>\n * This class is designed to be thread safe; however, once constructed GeoDataManagerConfiguration should not be\n * modified. Modifying GeoDataManagerConfiguration may cause unspecified behaviors.\n * </p>\n * */\nvar GeoDataManager = /** @class */ (function () {\n    /**\n     * <p>\n     * Construct and configure GeoDataManager using GeoDataManagerConfiguration.\n     * </p>\n     * <b>Sample usage:</b>\n     *\n     * <pre>\n     * AmazonDynamoDBClient ddb = new AmazonDynamoDBClient(new ClasspathPropertiesFileCredentialsProvider());\n     * Region usWest2 = Region.getRegion(Regions.US_WEST_2);\n     * ddb.setRegion(usWest2);\n     *\n     * ClientConfiguration clientConfiguration = new ClientConfiguration().withMaxErrorRetry(5);\n     * ddb.setConfiguration(clientConfiguration);\n     *\n     * GeoDataManagerConfiguration config = new GeoDataManagerConfiguration(ddb, &quot;geo-table&quot;);\n     * GeoDataManager geoDataManager = new GeoDataManager(config);\n     * </pre>\n     *\n     * @param config\n     *            Container for the configuration parameters for GeoDataManager.\n     */\n    function GeoDataManager(config) {\n        this.config = config;\n        this.dynamoDBManager = new DynamoDBManager_1.DynamoDBManager(this.config);\n    }\n    /**\n     * <p>\n     * Return GeoDataManagerConfiguration. The returned GeoDataManagerConfiguration should not be modified.\n     * </p>\n     *\n     * @return\n     *         GeoDataManagerConfiguration that is used to configure this GeoDataManager.\n     */\n    GeoDataManager.prototype.getGeoDataManagerConfiguration = function () {\n        return this.config;\n    };\n    /**\n     * <p>\n     * Put a point into the Amazon DynamoDB table. Once put, you cannot update attributes specified in\n     * GeoDataManagerConfiguration: hash key, range key, geohash and geoJson. If you want to update these columns, you\n     * need to insert a new record and delete the old record.\n     * </p>\n     * <b>Sample usage:</b>\n     *\n     * <pre>\n     * GeoPoint geoPoint = new GeoPoint(47.5, -122.3);\n     * AttributeValue rangeKeyValue = new AttributeValue().withS(&quot;a6feb446-c7f2-4b48-9b3a-0f87744a5047&quot;);\n     * AttributeValue titleValue = new AttributeValue().withS(&quot;Original title&quot;);\n     *\n     * PutPointRequest putPointRequest = new PutPointRequest(geoPoint, rangeKeyValue);\n     * putPointRequest.getPutItemRequest().getItem().put(&quot;title&quot;, titleValue);\n     *\n     * PutPointResult putPointResult = geoDataManager.putPoint(putPointRequest);\n     * </pre>\n     *\n     * @param putPointInput\n     *            Container for the necessary parameters to execute put point request.\n     *\n     * @return Result of put point request.\n     */\n    GeoDataManager.prototype.putPoint = function (putPointInput) {\n        return this.dynamoDBManager.putPoint(putPointInput);\n    };\n    /**\n     * <p>\n     * Put a list of points into the Amazon DynamoDB table. Once put, you cannot update attributes specified in\n     * GeoDataManagerConfiguration: hash key, range key, geohash and geoJson. If you want to update these columns, you\n     * need to insert a new record and delete the old record.\n     * </p>\n     * <b>Sample usage:</b>\n     *\n     * <pre>\n     * GeoPoint geoPoint = new GeoPoint(47.5, -122.3);\n     * AttributeValue rangeKeyValue = new AttributeValue().withS(&quot;a6feb446-c7f2-4b48-9b3a-0f87744a5047&quot;);\n     * AttributeValue titleValue = new AttributeValue().withS(&quot;Original title&quot;);\n     *\n     * PutPointRequest putPointRequest = new PutPointRequest(geoPoint, rangeKeyValue);\n     * putPointRequest.getPutItemRequest().getItem().put(&quot;title&quot;, titleValue);\n     * List<PutPointRequest> putPointRequests = new ArrayList<PutPointRequest>();\n     * putPointRequests.add(putPointRequest);\n     * BatchWritePointResult batchWritePointResult = geoDataManager.batchWritePoints(putPointRequests);\n     * </pre>\n     *\n     * @param putPointInputs\n     *            Container for the necessary parameters to execute put point request.\n     *\n     * @return Result of batch put point request.\n     */\n    GeoDataManager.prototype.batchWritePoints = function (putPointInputs) {\n        return this.dynamoDBManager.batchWritePoints(putPointInputs);\n    };\n    /**\n     * <p>\n     * Get a point from the Amazon DynamoDB table.\n     * </p>\n     * <b>Sample usage:</b>\n     *\n     * <pre>\n     * GeoPoint geoPoint = new GeoPoint(47.5, -122.3);\n     * AttributeValue rangeKeyValue = new AttributeValue().withS(&quot;a6feb446-c7f2-4b48-9b3a-0f87744a5047&quot;);\n     *\n     * GetPointRequest getPointRequest = new GetPointRequest(geoPoint, rangeKeyValue);\n     * GetPointResult getPointResult = geoIndexManager.getPoint(getPointRequest);\n     *\n     * System.out.println(&quot;item: &quot; + getPointResult.getGetItemResult().getItem());\n     * </pre>\n     *\n     * @param getPointInput\n     *            Container for the necessary parameters to execute get point request.\n     *\n     * @return Result of get point request.\n     * */\n    GeoDataManager.prototype.getPoint = function (getPointInput) {\n        return this.dynamoDBManager.getPoint(getPointInput);\n    };\n    /**\n     * <p>\n     * Query a rectangular area constructed by two points and return all points within the area. Two points need to\n     * construct a rectangle from minimum and maximum latitudes and longitudes. If minPoint.getLongitude() >\n     * maxPoint.getLongitude(), the rectangle spans the 180 degree longitude line.\n     * </p>\n     * <b>Sample usage:</b>\n     *\n     * <pre>\n     * GeoPoint minPoint = new GeoPoint(45.5, -124.3);\n     * GeoPoint maxPoint = new GeoPoint(49.5, -120.3);\n     *\n     * QueryRectangleRequest queryRectangleRequest = new QueryRectangleRequest(minPoint, maxPoint);\n     * QueryRectangleResult queryRectangleResult = geoIndexManager.queryRectangle(queryRectangleRequest);\n     *\n     * for (Map&lt;String, AttributeValue&gt; item : queryRectangleResult.getItem()) {\n       * \tSystem.out.println(&quot;item: &quot; + item);\n       * }\n     * </pre>\n     *\n     * @param queryRectangleInput\n     *            Container for the necessary parameters to execute rectangle query request.\n     *\n     * @return Result of rectangle query request.\n     */\n    GeoDataManager.prototype.queryRectangle = function (queryRectangleInput) {\n        var _this = this;\n        var latLngRect = S2Util_1.S2Util.latLngRectFromQueryRectangleInput(queryRectangleInput);\n        var covering = new Covering_1.Covering(new this.config.S2RegionCoverer().getCoveringCells(latLngRect));\n        return this.dispatchQueries(covering, queryRectangleInput)\n            .then(function (results) { return _this.filterByRectangle(results, queryRectangleInput); });\n    };\n    /**\n     * <p>\n     * Query a circular area constructed by a center point and its radius.\n     * </p>\n     * <b>Sample usage:</b>\n     *\n     * <pre>\n     * GeoPoint centerPoint = new GeoPoint(47.5, -122.3);\n     *\n     * QueryRadiusRequest queryRadiusRequest = new QueryRadiusRequest(centerPoint, 100);\n     * QueryRadiusResult queryRadiusResult = geoIndexManager.queryRadius(queryRadiusRequest);\n     *\n     * for (Map&lt;String, AttributeValue&gt; item : queryRadiusResult.getItem()) {\n       * \tSystem.out.println(&quot;item: &quot; + item);\n       * }\n     * </pre>\n     *\n     * @param queryRadiusInput\n     *            Container for the necessary parameters to execute radius query request.\n     *\n     * @return Result of radius query request.\n     * */\n    GeoDataManager.prototype.queryRadius = function (queryRadiusInput) {\n        var _this = this;\n        var latLngRect = S2Util_1.S2Util.getBoundingLatLngRectFromQueryRadiusInput(queryRadiusInput);\n        var covering = new Covering_1.Covering(new this.config.S2RegionCoverer().getCoveringCells(latLngRect));\n        return this.dispatchQueries(covering, queryRadiusInput)\n            .then(function (results) { return _this.filterByRadius(results, queryRadiusInput); });\n    };\n    /**\n     * <p>\n     * Update a point data in Amazon DynamoDB table. You cannot update attributes specified in\n     * GeoDataManagerConfiguration: hash key, range key, geohash and geoJson. If you want to update these columns, you\n     * need to insert a new record and delete the old record.\n     * </p>\n     * <b>Sample usage:</b>\n     *\n     * <pre>\n     * GeoPoint geoPoint = new GeoPoint(47.5, -122.3);\n     *\n     * String rangeKey = &quot;a6feb446-c7f2-4b48-9b3a-0f87744a5047&quot;;\n     * AttributeValue rangeKeyValue = new AttributeValue().withS(rangeKey);\n     *\n     * UpdatePointRequest updatePointRequest = new UpdatePointRequest(geoPoint, rangeKeyValue);\n     *\n     * AttributeValue titleValue = new AttributeValue().withS(&quot;Updated title.&quot;);\n     * AttributeValueUpdate titleValueUpdate = new AttributeValueUpdate().withAction(AttributeAction.PUT)\n     *    .withValue(titleValue);\n     * updatePointRequest.getUpdateItemRequest().getAttributeUpdates().put(&quot;title&quot;, titleValueUpdate);\n     *\n     * UpdatePointResult updatePointResult = geoIndexManager.updatePoint(updatePointRequest);\n     * </pre>\n     *\n     * @param updatePointInput\n     *            Container for the necessary parameters to execute update point request.\n     *\n     * @return Result of update point request.\n     */\n    GeoDataManager.prototype.updatePoint = function (updatePointInput) {\n        return this.dynamoDBManager.updatePoint(updatePointInput);\n    };\n    /**\n     * <p>\n     * Delete a point from the Amazon DynamoDB table.\n     * </p>\n     * <b>Sample usage:</b>\n     *\n     * <pre>\n     * GeoPoint geoPoint = new GeoPoint(47.5, -122.3);\n     *\n     * String rangeKey = &quot;a6feb446-c7f2-4b48-9b3a-0f87744a5047&quot;;\n     * AttributeValue rangeKeyValue = new AttributeValue().withS(rangeKey);\n     *\n     * DeletePointRequest deletePointRequest = new DeletePointRequest(geoPoint, rangeKeyValue);\n     * DeletePointResult deletePointResult = geoIndexManager.deletePoint(deletePointRequest);\n     * </pre>\n     *\n     * @param deletePointInput\n     *            Container for the necessary parameters to execute delete point request.\n     *\n     * @return Result of delete point request.\n     */\n    GeoDataManager.prototype.deletePoint = function (deletePointInput) {\n        return this.dynamoDBManager.deletePoint(deletePointInput);\n    };\n    /**\n     * Query Amazon DynamoDB in parallel and filter the result.\n     *\n     * @param covering\n     *            A list of geohash ranges that will be used to query Amazon DynamoDB.\n     *\n     * @param geoQueryInput\n     *            The rectangle area that will be used as a reference point for precise filtering.\n     *\n     * @return Aggregated and filtered items returned from Amazon DynamoDB.\n     */\n    GeoDataManager.prototype.dispatchQueries = function (covering, geoQueryInput) {\n        var _this = this;\n        var promises = covering.getGeoHashRanges(this.config.hashKeyLength).map(function (range) {\n            var hashKey = S2Manager_1.S2Manager.generateHashKey(range.rangeMin, _this.config.hashKeyLength);\n            return _this.dynamoDBManager.queryGeohash(geoQueryInput.QueryInput, hashKey, range);\n        });\n        return Promise.all(promises).then(function (results) {\n            var mergedResults = [];\n            results.forEach(function (queryOutputs) { return queryOutputs.forEach(function (queryOutput) { return mergedResults.push.apply(mergedResults, queryOutput.Items); }); });\n            return mergedResults;\n        });\n    };\n    /**\n     * Filter out any points outside of the queried area from the input list.\n     *\n     * @param list\n     * @param geoQueryInput\n     * @returns DynamoDB.ItemList\n     */\n    GeoDataManager.prototype.filterByRadius = function (list, geoQueryInput) {\n        var _this = this;\n        var centerLatLng = null;\n        var radiusInMeter = 0;\n        var centerPoint = geoQueryInput.CenterPoint;\n        centerLatLng = nodes2ts_1.S2LatLng.fromDegrees(centerPoint.latitude, centerPoint.longitude);\n        radiusInMeter = geoQueryInput.RadiusInMeter;\n        return list.filter(function (item) {\n            var geoJson = item[_this.config.geoJsonAttributeName].S;\n            var coordinates = JSON.parse(geoJson).coordinates;\n            var longitude = coordinates[_this.config.longitudeFirst ? 0 : 1];\n            var latitude = coordinates[_this.config.longitudeFirst ? 1 : 0];\n            var latLng = nodes2ts_1.S2LatLng.fromDegrees(latitude, longitude);\n            return centerLatLng.getEarthDistance(latLng).toNumber() <= radiusInMeter;\n        });\n    };\n    /**\n     * Filter out any points outside of the queried area from the input list.\n     *\n     * @param list\n     * @param geoQueryInput\n     * @returns DynamoDB.ItemList\n     */\n    GeoDataManager.prototype.filterByRectangle = function (list, geoQueryInput) {\n        var _this = this;\n        var latLngRect = S2Util_1.S2Util.latLngRectFromQueryRectangleInput(geoQueryInput);\n        return list.filter(function (item) {\n            var geoJson = item[_this.config.geoJsonAttributeName].S;\n            var coordinates = JSON.parse(geoJson).coordinates;\n            var longitude = coordinates[_this.config.longitudeFirst ? 0 : 1];\n            var latitude = coordinates[_this.config.longitudeFirst ? 1 : 0];\n            var latLng = nodes2ts_1.S2LatLng.fromDegrees(latitude, longitude);\n            return latLngRect.containsLL(latLng);\n        });\n    };\n    return GeoDataManager;\n}());\nexports.GeoDataManager = GeoDataManager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar nodes2ts_1 = require(\"nodes2ts\");\nvar GeoDataManagerConfiguration = /** @class */ (function () {\n    function GeoDataManagerConfiguration(dynamoDBClient, tableName) {\n        this.consistentRead = false;\n        this.hashKeyAttributeName = \"hashKey\";\n        this.rangeKeyAttributeName = \"rangeKey\";\n        this.geohashAttributeName = \"geohash\";\n        this.geoJsonAttributeName = \"geoJson\";\n        this.geohashIndexName = \"geohash-index\";\n        this.hashKeyLength = 2;\n        /**\n         * The order of the GeoJSON coordinate pair in data.\n         * Use false [lat, lon] for compatibility with the Java library https://github.com/awslabs/dynamodb-geo\n         * Use true [lon, lat] for GeoJSON standard compliance. (default)\n         *\n         * Note that this value should match the state of your existing data - if you change it you must update your database manually\n         *\n         * @type {boolean}\n         */\n        this.longitudeFirst = true;\n        this.dynamoDBClient = dynamoDBClient;\n        this.tableName = tableName;\n        this.S2RegionCoverer = nodes2ts_1.S2RegionCoverer;\n    }\n    // Public constants\n    GeoDataManagerConfiguration.MERGE_THRESHOLD = 2;\n    return GeoDataManagerConfiguration;\n}());\nexports.GeoDataManagerConfiguration = GeoDataManagerConfiguration;\n","\"use strict\";\n/*\n * Copyright 2010-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\").\n * You may not use this file except in compliance with the License.\n * A copy of the License is located at\n *\n *  http://aws.amazon.com/apache2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar S2Manager_1 = require(\"../s2/S2Manager\");\nvar DynamoDBManager = /** @class */ (function () {\n    function DynamoDBManager(config) {\n        this.config = config;\n    }\n    /**\n     * Query Amazon DynamoDB\n     *\n     * @param queryInput\n     * @param hashKey\n     *            Hash key for the query request.\n     *\n     * @param range\n     *            The range of geohashs to query.\n     *\n     * @return The query result.\n     */\n    DynamoDBManager.prototype.queryGeohash = function (queryInput, hashKey, range) {\n        var _this = this;\n        var queryOutputs = [];\n        var nextQuery = function (lastEvaluatedKey) {\n            if (lastEvaluatedKey === void 0) { lastEvaluatedKey = null; }\n            var keyConditions = {};\n            keyConditions[_this.config.hashKeyAttributeName] = {\n                ComparisonOperator: \"EQ\",\n                AttributeValueList: [{ N: hashKey.toString(10) }]\n            };\n            var minRange = { N: range.rangeMin.toString(10) };\n            var maxRange = { N: range.rangeMax.toString(10) };\n            keyConditions[_this.config.geohashAttributeName] = {\n                ComparisonOperator: \"BETWEEN\",\n                AttributeValueList: [minRange, maxRange]\n            };\n            var defaults = {\n                TableName: _this.config.tableName,\n                KeyConditions: keyConditions,\n                IndexName: _this.config.geohashIndexName,\n                ConsistentRead: _this.config.consistentRead,\n                ReturnConsumedCapacity: \"TOTAL\",\n                ExclusiveStartKey: lastEvaluatedKey\n            };\n            return _this.config.dynamoDBClient.query(__assign({}, defaults, queryInput)).promise()\n                .then(function (queryOutput) {\n                queryOutputs.push(queryOutput);\n                if (queryOutput.LastEvaluatedKey) {\n                    return nextQuery(queryOutput.LastEvaluatedKey);\n                }\n            });\n        };\n        return nextQuery().then(function () { return queryOutputs; });\n    };\n    DynamoDBManager.prototype.getPoint = function (getPointInput) {\n        var geohash = S2Manager_1.S2Manager.generateGeohash(getPointInput.GeoPoint);\n        var hashKey = S2Manager_1.S2Manager.generateHashKey(geohash, this.config.hashKeyLength);\n        var getItemInput = getPointInput.GetItemInput;\n        getItemInput.TableName = this.config.tableName;\n        getItemInput.Key = (_a = {},\n            _a[this.config.hashKeyAttributeName] = { N: hashKey.toString(10) },\n            _a[this.config.rangeKeyAttributeName] = getPointInput.RangeKeyValue,\n            _a);\n        return this.config.dynamoDBClient.getItem(getItemInput);\n        var _a;\n    };\n    DynamoDBManager.prototype.putPoint = function (putPointInput) {\n        var geohash = S2Manager_1.S2Manager.generateGeohash(putPointInput.GeoPoint);\n        var hashKey = S2Manager_1.S2Manager.generateHashKey(geohash, this.config.hashKeyLength);\n        var putItemInput = __assign({}, putPointInput.PutItemInput, { TableName: this.config.tableName, Item: putPointInput.PutItemInput.Item || {} });\n        putItemInput.Item[this.config.hashKeyAttributeName] = { N: hashKey.toString(10) };\n        putItemInput.Item[this.config.rangeKeyAttributeName] = putPointInput.RangeKeyValue;\n        putItemInput.Item[this.config.geohashAttributeName] = { N: geohash.toString(10) };\n        putItemInput.Item[this.config.geoJsonAttributeName] = {\n            S: JSON.stringify({\n                type: 'POINT',\n                coordinates: (this.config.longitudeFirst ?\n                    [putPointInput.GeoPoint.longitude, putPointInput.GeoPoint.latitude] :\n                    [putPointInput.GeoPoint.latitude, putPointInput.GeoPoint.longitude])\n            })\n        };\n        return this.config.dynamoDBClient.putItem(putItemInput);\n    };\n    DynamoDBManager.prototype.batchWritePoints = function (putPointInputs) {\n        var _this = this;\n        var writeInputs = [];\n        putPointInputs.forEach(function (putPointInput) {\n            var geohash = S2Manager_1.S2Manager.generateGeohash(putPointInput.GeoPoint);\n            var hashKey = S2Manager_1.S2Manager.generateHashKey(geohash, _this.config.hashKeyLength);\n            var putItemInput = putPointInput.PutItemInput;\n            var putRequest = {\n                Item: putItemInput.Item || {}\n            };\n            putRequest.Item[_this.config.hashKeyAttributeName] = { N: hashKey.toString(10) };\n            putRequest.Item[_this.config.rangeKeyAttributeName] = putPointInput.RangeKeyValue;\n            putRequest.Item[_this.config.geohashAttributeName] = { N: geohash.toString(10) };\n            putRequest.Item[_this.config.geoJsonAttributeName] = {\n                S: JSON.stringify({\n                    type: 'POINT',\n                    coordinates: (_this.config.longitudeFirst ?\n                        [putPointInput.GeoPoint.longitude, putPointInput.GeoPoint.latitude] :\n                        [putPointInput.GeoPoint.latitude, putPointInput.GeoPoint.longitude])\n                })\n            };\n            writeInputs.push({ PutRequest: putRequest });\n        });\n        return this.config.dynamoDBClient.batchWriteItem({\n            RequestItems: (_a = {},\n                _a[this.config.tableName] = writeInputs,\n                _a)\n        });\n        var _a;\n    };\n    DynamoDBManager.prototype.updatePoint = function (updatePointInput) {\n        var geohash = S2Manager_1.S2Manager.generateGeohash(updatePointInput.GeoPoint);\n        var hashKey = S2Manager_1.S2Manager.generateHashKey(geohash, this.config.hashKeyLength);\n        updatePointInput.UpdateItemInput.TableName = this.config.tableName;\n        if (!updatePointInput.UpdateItemInput.Key) {\n            updatePointInput.UpdateItemInput.Key = {};\n        }\n        updatePointInput.UpdateItemInput.Key[this.config.hashKeyAttributeName] = { N: hashKey.toString(10) };\n        updatePointInput.UpdateItemInput.Key[this.config.rangeKeyAttributeName] = updatePointInput.RangeKeyValue;\n        // Geohash and geoJson cannot be updated.\n        if (updatePointInput.UpdateItemInput.AttributeUpdates) {\n            delete updatePointInput.UpdateItemInput.AttributeUpdates[this.config.geohashAttributeName];\n            delete updatePointInput.UpdateItemInput.AttributeUpdates[this.config.geoJsonAttributeName];\n        }\n        return this.config.dynamoDBClient.updateItem(updatePointInput.UpdateItemInput);\n    };\n    DynamoDBManager.prototype.deletePoint = function (deletePointInput) {\n        var geohash = S2Manager_1.S2Manager.generateGeohash(deletePointInput.GeoPoint);\n        var hashKey = S2Manager_1.S2Manager.generateHashKey(geohash, this.config.hashKeyLength);\n        return this.config.dynamoDBClient.deleteItem(__assign({}, deletePointInput.DeleteItemInput, { TableName: this.config.tableName, Key: (_a = {},\n                _a[this.config.hashKeyAttributeName] = { N: hashKey.toString(10) },\n                _a[this.config.rangeKeyAttributeName] = deletePointInput.RangeKeyValue,\n                _a) }));\n        var _a;\n    };\n    return DynamoDBManager;\n}());\nexports.DynamoDBManager = DynamoDBManager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GeoDataManager_1 = require(\"./GeoDataManager\");\nexports.GeoDataManager = GeoDataManager_1.GeoDataManager;\nvar GeoDataManagerConfiguration_1 = require(\"./GeoDataManagerConfiguration\");\nexports.GeoDataManagerConfiguration = GeoDataManagerConfiguration_1.GeoDataManagerConfiguration;\nvar GeoTableUtil_1 = require(\"./util/GeoTableUtil\");\nexports.GeoTableUtil = GeoTableUtil_1.GeoTableUtil;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GeohashRange_1 = require(\"./GeohashRange\");\nvar Covering = /** @class */ (function () {\n    function Covering(cellIds) {\n        this.cellIds = cellIds;\n    }\n    Covering.prototype.getGeoHashRanges = function (hashKeyLength) {\n        var ranges = [];\n        this.cellIds.forEach(function (outerRange) {\n            var hashRange = new GeohashRange_1.GeohashRange(outerRange.rangeMin().id, outerRange.rangeMax().id);\n            ranges.push.apply(ranges, hashRange.trySplit(hashKeyLength));\n        });\n        return ranges;\n    };\n    Covering.prototype.getNumberOfCells = function () {\n        return this.cellIds.length;\n    };\n    return Covering;\n}());\nexports.Covering = Covering;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GeoDataManagerConfiguration_1 = require(\"../GeoDataManagerConfiguration\");\nvar S2Manager_1 = require(\"../s2/S2Manager\");\nvar Long = require(\"long\");\nvar GeohashRange = /** @class */ (function () {\n    function GeohashRange(min, max) {\n        this.rangeMin = min instanceof Long ? min : Long.fromNumber(min);\n        this.rangeMax = max instanceof Long ? max : Long.fromNumber(max);\n    }\n    GeohashRange.prototype.tryMerge = function (range) {\n        if (range.rangeMin.subtract(this.rangeMax).lessThanOrEqual(GeoDataManagerConfiguration_1.GeoDataManagerConfiguration.MERGE_THRESHOLD)\n            && range.rangeMin.greaterThan(this.rangeMax)) {\n            this.rangeMax = range.rangeMax;\n            return true;\n        }\n        if (this.rangeMin.subtract(range.rangeMax).lessThanOrEqual(GeoDataManagerConfiguration_1.GeoDataManagerConfiguration.MERGE_THRESHOLD)\n            && this.rangeMin.greaterThan(range.rangeMax)) {\n            this.rangeMin = range.rangeMin;\n            return true;\n        }\n        return false;\n    };\n    /*\n     * Try to split the range to multiple ranges based on the hash key.\n     *\n     * e.g., for the following range:\n     *\n     * min: 123456789\n     * max: 125678912\n     *\n     * when the hash key length is 3, we want to split the range to:\n     *\n     * 1\n     * min: 123456789\n     * max: 123999999\n     *\n     * 2\n     * min: 124000000\n     * max: 124999999\n     *\n     * 3\n     * min: 125000000\n     * max: 125678912\n     *\n     * For this range:\n     *\n     * min: -125678912\n     * max: -123456789\n     *\n     * we want:\n     *\n     * 1\n     * min: -125678912\n     * max: -125000000\n     *\n     * 2\n     * min: -124999999\n     * max: -124000000\n     *\n     * 3\n     * min: -123999999\n     * max: -123456789\n     */\n    GeohashRange.prototype.trySplit = function (hashKeyLength) {\n        var result = [];\n        var minHashKey = S2Manager_1.S2Manager.generateHashKey(this.rangeMin, hashKeyLength);\n        var maxHashKey = S2Manager_1.S2Manager.generateHashKey(this.rangeMax, hashKeyLength);\n        var denominator = Math.pow(10, this.rangeMin.toString().length - minHashKey.toString().length);\n        if (minHashKey.equals(maxHashKey)) {\n            result.push(this);\n        }\n        else {\n            for (var l = minHashKey; l.lessThanOrEqual(maxHashKey); l = l.add(1)) {\n                if (l.greaterThan(0)) {\n                    result.push(new GeohashRange(l.equals(minHashKey) ? this.rangeMin : l.multiply(denominator), l.equals(maxHashKey) ? this.rangeMax : l.add(1).multiply(denominator).subtract(1)));\n                }\n                else {\n                    result.push(new GeohashRange(l.equals(minHashKey) ? this.rangeMin : l.subtract(1).multiply(denominator).add(1), l.equals(maxHashKey) ? this.rangeMax : l.multiply(denominator)));\n                }\n            }\n        }\n        return result;\n    };\n    return GeohashRange;\n}());\nexports.GeohashRange = GeohashRange;\n","\"use strict\";\n/*\n * Copyright 2010-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\").\n * You may not use this file except in compliance with the License.\n * A copy of the License is located at\n *\n * http://aws.amazon.com/apache2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar nodes2ts_1 = require(\"nodes2ts\");\nvar S2Manager = /** @class */ (function () {\n    function S2Manager() {\n    }\n    S2Manager.generateGeohash = function (geoPoint) {\n        var latLng = nodes2ts_1.S2LatLng.fromDegrees(geoPoint.latitude, geoPoint.longitude);\n        var cell = nodes2ts_1.S2Cell.fromLatLng(latLng);\n        var cellId = cell.id;\n        return cellId.id;\n    };\n    S2Manager.generateHashKey = function (geohash, hashKeyLength) {\n        if (geohash.lessThan(0)) {\n            // Counteract \"-\" at beginning of geohash.\n            hashKeyLength++;\n        }\n        var geohashString = geohash.toString(10);\n        var denominator = Math.pow(10, geohashString.length - hashKeyLength);\n        return geohash.divide(denominator);\n    };\n    return S2Manager;\n}());\nexports.S2Manager = S2Manager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar nodes2ts_1 = require(\"nodes2ts\");\nvar S2Util = /** @class */ (function () {\n    function S2Util() {\n    }\n    S2Util.latLngRectFromQueryRectangleInput = function (geoQueryRequest) {\n        var queryRectangleRequest = geoQueryRequest;\n        var minPoint = queryRectangleRequest.MinPoint;\n        var maxPoint = queryRectangleRequest.MaxPoint;\n        var latLngRect = null;\n        if (minPoint != null && maxPoint != null) {\n            var minLatLng = nodes2ts_1.S2LatLng.fromDegrees(minPoint.latitude, minPoint.longitude);\n            var maxLatLng = nodes2ts_1.S2LatLng.fromDegrees(maxPoint.latitude, maxPoint.longitude);\n            latLngRect = nodes2ts_1.S2LatLngRect.fromLatLng(minLatLng, maxLatLng);\n        }\n        return latLngRect;\n    };\n    S2Util.getBoundingLatLngRectFromQueryRadiusInput = function (geoQueryRequest) {\n        var centerPoint = geoQueryRequest.CenterPoint;\n        var radiusInMeter = geoQueryRequest.RadiusInMeter;\n        var centerLatLng = nodes2ts_1.S2LatLng.fromDegrees(centerPoint.latitude, centerPoint.longitude);\n        var latReferenceUnit = centerPoint.latitude > 0.0 ? -1.0 : 1.0;\n        var latReferenceLatLng = nodes2ts_1.S2LatLng.fromDegrees(centerPoint.latitude + latReferenceUnit, centerPoint.longitude);\n        var lngReferenceUnit = centerPoint.longitude > 0.0 ? -1.0 : 1.0;\n        var lngReferenceLatLng = nodes2ts_1.S2LatLng.fromDegrees(centerPoint.latitude, centerPoint.longitude\n            + lngReferenceUnit);\n        var latForRadius = radiusInMeter / centerLatLng.getEarthDistance(latReferenceLatLng).toNumber();\n        var lngForRadius = radiusInMeter / centerLatLng.getEarthDistance(lngReferenceLatLng).toNumber();\n        var minLatLng = nodes2ts_1.S2LatLng.fromDegrees(centerPoint.latitude - latForRadius, centerPoint.longitude - lngForRadius);\n        var maxLatLng = nodes2ts_1.S2LatLng.fromDegrees(centerPoint.latitude + latForRadius, centerPoint.longitude + lngForRadius);\n        return nodes2ts_1.S2LatLngRect.fromLatLng(minLatLng, maxLatLng);\n    };\n    return S2Util;\n}());\nexports.S2Util = S2Util;\n","\"use strict\";\n/*\n * Copyright 2010-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\").\n * You may not use this file except in compliance with the License.\n * A copy of the License is located at\n *\n *  http://aws.amazon.com/apache2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Utility class.\n * */\nvar GeoTableUtil = /** @class */ (function () {\n    function GeoTableUtil() {\n    }\n    /**\n     * <p>\n     * Construct a create table request object based on GeoDataManagerConfiguration. The users can update any aspect of\n     * the request and call it.\n     * </p>\n     * Example:\n     *\n     * <pre>\n     * AmazonDynamoDBClient ddb = new AmazonDynamoDBClient(new ClasspathPropertiesFileCredentialsProvider());\n     * Region usWest2 = Region.getRegion(Regions.US_WEST_2);\n     * ddb.setRegion(usWest2);\n     *\n     * CreateTableRequest createTableRequest = GeoTableUtil.getCreateTableRequest(config);\n     * CreateTableResult createTableResult = ddb.createTable(createTableRequest);\n     * </pre>\n     *\n     * @return Generated create table request.\n     */\n    GeoTableUtil.getCreateTableRequest = function (config) {\n        return {\n            TableName: config.tableName,\n            ProvisionedThroughput: {\n                ReadCapacityUnits: 10,\n                WriteCapacityUnits: 5\n            },\n            KeySchema: [\n                {\n                    KeyType: \"HASH\",\n                    AttributeName: config.hashKeyAttributeName\n                },\n                {\n                    KeyType: \"RANGE\",\n                    AttributeName: config.rangeKeyAttributeName\n                }\n            ],\n            AttributeDefinitions: [\n                { AttributeName: config.hashKeyAttributeName, AttributeType: 'N' },\n                { AttributeName: config.rangeKeyAttributeName, AttributeType: 'S' },\n                { AttributeName: config.geohashAttributeName, AttributeType: 'N' }\n            ],\n            LocalSecondaryIndexes: [\n                {\n                    IndexName: config.geohashIndexName,\n                    KeySchema: [\n                        {\n                            KeyType: 'HASH',\n                            AttributeName: config.hashKeyAttributeName\n                        },\n                        {\n                            KeyType: 'RANGE',\n                            AttributeName: config.geohashAttributeName\n                        }\n                    ],\n                    Projection: {\n                        ProjectionType: 'ALL'\n                    }\n                }\n            ]\n        };\n    };\n    return GeoTableUtil;\n}());\nexports.GeoTableUtil = GeoTableUtil;\n","/*\r\n Copyright 2013 Daniel Wirtz <dcode@dcode.io>\r\n Copyright 2009 The Closure Library Authors. All Rights Reserved.\r\n\r\n Licensed under the Apache License, Version 2.0 (the \"License\");\r\n you may not use this file except in compliance with the License.\r\n You may obtain a copy of the License at\r\n\r\n http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n Unless required by applicable law or agreed to in writing, software\r\n distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n See the License for the specific language governing permissions and\r\n limitations under the License.\r\n */\r\n\r\n/**\r\n * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>\r\n * Released under the Apache License, Version 2.0\r\n * see: https://github.com/dcodeIO/long.js for details\r\n */\r\n(function(global, factory) {\r\n\r\n    /* AMD */ if (typeof define === 'function' && define[\"amd\"])\r\n        define([], factory);\r\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === \"object\" && module && module[\"exports\"])\r\n        module[\"exports\"] = factory();\r\n    /* Global */ else\r\n        (global[\"dcodeIO\"] = global[\"dcodeIO\"] || {})[\"Long\"] = factory();\r\n\r\n})(this, function() {\r\n    \"use strict\";\r\n\r\n    /**\r\n     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n     *  See the from* functions below for more convenient ways of constructing Longs.\r\n     * @exports Long\r\n     * @class A Long class for representing a 64 bit two's-complement integer value.\r\n     * @param {number} low The low (signed) 32 bits of the long\r\n     * @param {number} high The high (signed) 32 bits of the long\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @constructor\r\n     */\r\n    function Long(low, high, unsigned) {\r\n\r\n        /**\r\n         * The low 32 bits as a signed value.\r\n         * @type {number}\r\n         */\r\n        this.low = low | 0;\r\n\r\n        /**\r\n         * The high 32 bits as a signed value.\r\n         * @type {number}\r\n         */\r\n        this.high = high | 0;\r\n\r\n        /**\r\n         * Whether unsigned or not.\r\n         * @type {boolean}\r\n         */\r\n        this.unsigned = !!unsigned;\r\n    }\r\n\r\n    // The internal representation of a long is the two given signed, 32-bit values.\r\n    // We use 32-bit pieces because these are the size of integers on which\r\n    // Javascript performs bit-operations.  For operations like addition and\r\n    // multiplication, we split each number into 16 bit pieces, which can easily be\r\n    // multiplied within Javascript's floating-point representation without overflow\r\n    // or change in sign.\r\n    //\r\n    // In the algorithms below, we frequently reduce the negative case to the\r\n    // positive case by negating the input(s) and then post-processing the result.\r\n    // Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n    // a positive number, it overflows back into a negative).  Not handling this\r\n    // case would often result in infinite recursion.\r\n    //\r\n    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n    // methods on which they depend.\r\n\r\n    /**\r\n     * An indicator used to reliably determine if an object is a Long or not.\r\n     * @type {boolean}\r\n     * @const\r\n     * @private\r\n     */\r\n    Long.prototype.__isLong__;\r\n\r\n    Object.defineProperty(Long.prototype, \"__isLong__\", {\r\n        value: true,\r\n        enumerable: false,\r\n        configurable: false\r\n    });\r\n\r\n    /**\r\n     * @function\r\n     * @param {*} obj Object\r\n     * @returns {boolean}\r\n     * @inner\r\n     */\r\n    function isLong(obj) {\r\n        return (obj && obj[\"__isLong__\"]) === true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the specified object is a Long.\r\n     * @function\r\n     * @param {*} obj Object\r\n     * @returns {boolean}\r\n     */\r\n    Long.isLong = isLong;\r\n\r\n    /**\r\n     * A cache of the Long representations of small integer values.\r\n     * @type {!Object}\r\n     * @inner\r\n     */\r\n    var INT_CACHE = {};\r\n\r\n    /**\r\n     * A cache of the Long representations of small unsigned integer values.\r\n     * @type {!Object}\r\n     * @inner\r\n     */\r\n    var UINT_CACHE = {};\r\n\r\n    /**\r\n     * @param {number} value\r\n     * @param {boolean=} unsigned\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromInt(value, unsigned) {\r\n        var obj, cachedObj, cache;\r\n        if (unsigned) {\r\n            value >>>= 0;\r\n            if (cache = (0 <= value && value < 256)) {\r\n                cachedObj = UINT_CACHE[value];\r\n                if (cachedObj)\r\n                    return cachedObj;\r\n            }\r\n            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n            if (cache)\r\n                UINT_CACHE[value] = obj;\r\n            return obj;\r\n        } else {\r\n            value |= 0;\r\n            if (cache = (-128 <= value && value < 128)) {\r\n                cachedObj = INT_CACHE[value];\r\n                if (cachedObj)\r\n                    return cachedObj;\r\n            }\r\n            obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n            if (cache)\r\n                INT_CACHE[value] = obj;\r\n            return obj;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a Long representing the given 32 bit integer value.\r\n     * @function\r\n     * @param {number} value The 32 bit integer in question\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @returns {!Long} The corresponding Long value\r\n     */\r\n    Long.fromInt = fromInt;\r\n\r\n    /**\r\n     * @param {number} value\r\n     * @param {boolean=} unsigned\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromNumber(value, unsigned) {\r\n        if (isNaN(value) || !isFinite(value))\r\n            return unsigned ? UZERO : ZERO;\r\n        if (unsigned) {\r\n            if (value < 0)\r\n                return UZERO;\r\n            if (value >= TWO_PWR_64_DBL)\r\n                return MAX_UNSIGNED_VALUE;\r\n        } else {\r\n            if (value <= -TWO_PWR_63_DBL)\r\n                return MIN_VALUE;\r\n            if (value + 1 >= TWO_PWR_63_DBL)\r\n                return MAX_VALUE;\r\n        }\r\n        if (value < 0)\r\n            return fromNumber(-value, unsigned).neg();\r\n        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n    }\r\n\r\n    /**\r\n     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n     * @function\r\n     * @param {number} value The number in question\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @returns {!Long} The corresponding Long value\r\n     */\r\n    Long.fromNumber = fromNumber;\r\n\r\n    /**\r\n     * @param {number} lowBits\r\n     * @param {number} highBits\r\n     * @param {boolean=} unsigned\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromBits(lowBits, highBits, unsigned) {\r\n        return new Long(lowBits, highBits, unsigned);\r\n    }\r\n\r\n    /**\r\n     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n     *  assumed to use 32 bits.\r\n     * @function\r\n     * @param {number} lowBits The low 32 bits\r\n     * @param {number} highBits The high 32 bits\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @returns {!Long} The corresponding Long value\r\n     */\r\n    Long.fromBits = fromBits;\r\n\r\n    /**\r\n     * @function\r\n     * @param {number} base\r\n     * @param {number} exponent\r\n     * @returns {number}\r\n     * @inner\r\n     */\r\n    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n    /**\r\n     * @param {string} str\r\n     * @param {(boolean|number)=} unsigned\r\n     * @param {number=} radix\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromString(str, unsigned, radix) {\r\n        if (str.length === 0)\r\n            throw Error('empty string');\r\n        if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n            return ZERO;\r\n        if (typeof unsigned === 'number') {\r\n            // For goog.math.long compatibility\r\n            radix = unsigned,\r\n            unsigned = false;\r\n        } else {\r\n            unsigned = !! unsigned;\r\n        }\r\n        radix = radix || 10;\r\n        if (radix < 2 || 36 < radix)\r\n            throw RangeError('radix');\r\n\r\n        var p;\r\n        if ((p = str.indexOf('-')) > 0)\r\n            throw Error('interior hyphen');\r\n        else if (p === 0) {\r\n            return fromString(str.substring(1), unsigned, radix).neg();\r\n        }\r\n\r\n        // Do several (8) digits each time through the loop, so as to\r\n        // minimize the calls to the very expensive emulated div.\r\n        var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n        var result = ZERO;\r\n        for (var i = 0; i < str.length; i += 8) {\r\n            var size = Math.min(8, str.length - i),\r\n                value = parseInt(str.substring(i, i + size), radix);\r\n            if (size < 8) {\r\n                var power = fromNumber(pow_dbl(radix, size));\r\n                result = result.mul(power).add(fromNumber(value));\r\n            } else {\r\n                result = result.mul(radixToPower);\r\n                result = result.add(fromNumber(value));\r\n            }\r\n        }\r\n        result.unsigned = unsigned;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a Long representation of the given string, written using the specified radix.\r\n     * @function\r\n     * @param {string} str The textual representation of the Long\r\n     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n     * @returns {!Long} The corresponding Long value\r\n     */\r\n    Long.fromString = fromString;\r\n\r\n    /**\r\n     * @function\r\n     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromValue(val) {\r\n        if (val /* is compatible */ instanceof Long)\r\n            return val;\r\n        if (typeof val === 'number')\r\n            return fromNumber(val);\r\n        if (typeof val === 'string')\r\n            return fromString(val);\r\n        // Throws for non-objects, converts non-instanceof Long:\r\n        return fromBits(val.low, val.high, val.unsigned);\r\n    }\r\n\r\n    /**\r\n     * Converts the specified value to a Long.\r\n     * @function\r\n     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n     * @returns {!Long}\r\n     */\r\n    Long.fromValue = fromValue;\r\n\r\n    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n    // no runtime penalty for these.\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_16_DBL = 1 << 16;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_24_DBL = 1 << 24;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var ZERO = fromInt(0);\r\n\r\n    /**\r\n     * Signed zero.\r\n     * @type {!Long}\r\n     */\r\n    Long.ZERO = ZERO;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var UZERO = fromInt(0, true);\r\n\r\n    /**\r\n     * Unsigned zero.\r\n     * @type {!Long}\r\n     */\r\n    Long.UZERO = UZERO;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var ONE = fromInt(1);\r\n\r\n    /**\r\n     * Signed one.\r\n     * @type {!Long}\r\n     */\r\n    Long.ONE = ONE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var UONE = fromInt(1, true);\r\n\r\n    /**\r\n     * Unsigned one.\r\n     * @type {!Long}\r\n     */\r\n    Long.UONE = UONE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var NEG_ONE = fromInt(-1);\r\n\r\n    /**\r\n     * Signed negative one.\r\n     * @type {!Long}\r\n     */\r\n    Long.NEG_ONE = NEG_ONE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n    /**\r\n     * Maximum signed value.\r\n     * @type {!Long}\r\n     */\r\n    Long.MAX_VALUE = MAX_VALUE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n    /**\r\n     * Maximum unsigned value.\r\n     * @type {!Long}\r\n     */\r\n    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n    /**\r\n     * Minimum signed value.\r\n     * @type {!Long}\r\n     */\r\n    Long.MIN_VALUE = MIN_VALUE;\r\n\r\n    /**\r\n     * @alias Long.prototype\r\n     * @inner\r\n     */\r\n    var LongPrototype = Long.prototype;\r\n\r\n    /**\r\n     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n     * @returns {number}\r\n     */\r\n    LongPrototype.toInt = function toInt() {\r\n        return this.unsigned ? this.low >>> 0 : this.low;\r\n    };\r\n\r\n    /**\r\n     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n     * @returns {number}\r\n     */\r\n    LongPrototype.toNumber = function toNumber() {\r\n        if (this.unsigned)\r\n            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n    };\r\n\r\n    /**\r\n     * Converts the Long to a string written in the specified radix.\r\n     * @param {number=} radix Radix (2-36), defaults to 10\r\n     * @returns {string}\r\n     * @override\r\n     * @throws {RangeError} If `radix` is out of range\r\n     */\r\n    LongPrototype.toString = function toString(radix) {\r\n        radix = radix || 10;\r\n        if (radix < 2 || 36 < radix)\r\n            throw RangeError('radix');\r\n        if (this.isZero())\r\n            return '0';\r\n        if (this.isNegative()) { // Unsigned Longs are never negative\r\n            if (this.eq(MIN_VALUE)) {\r\n                // We need to change the Long value before it can be negated, so we remove\r\n                // the bottom-most digit in this base and then recurse to do the rest.\r\n                var radixLong = fromNumber(radix),\r\n                    div = this.div(radixLong),\r\n                    rem1 = div.mul(radixLong).sub(this);\r\n                return div.toString(radix) + rem1.toInt().toString(radix);\r\n            } else\r\n                return '-' + this.neg().toString(radix);\r\n        }\r\n\r\n        // Do several (6) digits each time through the loop, so as to\r\n        // minimize the calls to the very expensive emulated div.\r\n        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n            rem = this;\r\n        var result = '';\r\n        while (true) {\r\n            var remDiv = rem.div(radixToPower),\r\n                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n                digits = intval.toString(radix);\r\n            rem = remDiv;\r\n            if (rem.isZero())\r\n                return digits + result;\r\n            else {\r\n                while (digits.length < 6)\r\n                    digits = '0' + digits;\r\n                result = '' + digits + result;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the high 32 bits as a signed integer.\r\n     * @returns {number} Signed high bits\r\n     */\r\n    LongPrototype.getHighBits = function getHighBits() {\r\n        return this.high;\r\n    };\r\n\r\n    /**\r\n     * Gets the high 32 bits as an unsigned integer.\r\n     * @returns {number} Unsigned high bits\r\n     */\r\n    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n        return this.high >>> 0;\r\n    };\r\n\r\n    /**\r\n     * Gets the low 32 bits as a signed integer.\r\n     * @returns {number} Signed low bits\r\n     */\r\n    LongPrototype.getLowBits = function getLowBits() {\r\n        return this.low;\r\n    };\r\n\r\n    /**\r\n     * Gets the low 32 bits as an unsigned integer.\r\n     * @returns {number} Unsigned low bits\r\n     */\r\n    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n        return this.low >>> 0;\r\n    };\r\n\r\n    /**\r\n     * Gets the number of bits needed to represent the absolute value of this Long.\r\n     * @returns {number}\r\n     */\r\n    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n        if (this.isNegative()) // Unsigned Longs are never negative\r\n            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n        var val = this.high != 0 ? this.high : this.low;\r\n        for (var bit = 31; bit > 0; bit--)\r\n            if ((val & (1 << bit)) != 0)\r\n                break;\r\n        return this.high != 0 ? bit + 33 : bit + 1;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value equals zero.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isZero = function isZero() {\r\n        return this.high === 0 && this.low === 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is negative.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isNegative = function isNegative() {\r\n        return !this.unsigned && this.high < 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is positive.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isPositive = function isPositive() {\r\n        return this.unsigned || this.high >= 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is odd.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isOdd = function isOdd() {\r\n        return (this.low & 1) === 1;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is even.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isEven = function isEven() {\r\n        return (this.low & 1) === 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value equals the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.equals = function equals(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n            return false;\r\n        return this.high === other.high && this.low === other.low;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.eq = LongPrototype.equals;\r\n\r\n    /**\r\n     * Tests if this Long's value differs from the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.notEquals = function notEquals(other) {\r\n        return !this.eq(/* validates */ other);\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.neq = LongPrototype.notEquals;\r\n\r\n    /**\r\n     * Tests if this Long's value is less than the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.lessThan = function lessThan(other) {\r\n        return this.comp(/* validates */ other) < 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.lt = LongPrototype.lessThan;\r\n\r\n    /**\r\n     * Tests if this Long's value is less than or equal the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n        return this.comp(/* validates */ other) <= 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.greaterThan = function greaterThan(other) {\r\n        return this.comp(/* validates */ other) > 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than or equal the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n        return this.comp(/* validates */ other) >= 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n    /**\r\n     * Compares this Long's value with the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n     *  if the given one is greater\r\n     */\r\n    LongPrototype.compare = function compare(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        if (this.eq(other))\r\n            return 0;\r\n        var thisNeg = this.isNegative(),\r\n            otherNeg = other.isNegative();\r\n        if (thisNeg && !otherNeg)\r\n            return -1;\r\n        if (!thisNeg && otherNeg)\r\n            return 1;\r\n        // At this point the sign bits are the same\r\n        if (!this.unsigned)\r\n            return this.sub(other).isNegative() ? -1 : 1;\r\n        // Both are positive if at least one is unsigned\r\n        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n    };\r\n\r\n    /**\r\n     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n     *  if the given one is greater\r\n     */\r\n    LongPrototype.comp = LongPrototype.compare;\r\n\r\n    /**\r\n     * Negates this Long's value.\r\n     * @returns {!Long} Negated Long\r\n     */\r\n    LongPrototype.negate = function negate() {\r\n        if (!this.unsigned && this.eq(MIN_VALUE))\r\n            return MIN_VALUE;\r\n        return this.not().add(ONE);\r\n    };\r\n\r\n    /**\r\n     * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n     * @function\r\n     * @returns {!Long} Negated Long\r\n     */\r\n    LongPrototype.neg = LongPrototype.negate;\r\n\r\n    /**\r\n     * Returns the sum of this and the specified Long.\r\n     * @param {!Long|number|string} addend Addend\r\n     * @returns {!Long} Sum\r\n     */\r\n    LongPrototype.add = function add(addend) {\r\n        if (!isLong(addend))\r\n            addend = fromValue(addend);\r\n\r\n        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n\r\n        var b48 = addend.high >>> 16;\r\n        var b32 = addend.high & 0xFFFF;\r\n        var b16 = addend.low >>> 16;\r\n        var b00 = addend.low & 0xFFFF;\r\n\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 + b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 + b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 + b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 + b48;\r\n        c48 &= 0xFFFF;\r\n        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the difference of this and the specified Long.\r\n     * @param {!Long|number|string} subtrahend Subtrahend\r\n     * @returns {!Long} Difference\r\n     */\r\n    LongPrototype.subtract = function subtract(subtrahend) {\r\n        if (!isLong(subtrahend))\r\n            subtrahend = fromValue(subtrahend);\r\n        return this.add(subtrahend.neg());\r\n    };\r\n\r\n    /**\r\n     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n     * @function\r\n     * @param {!Long|number|string} subtrahend Subtrahend\r\n     * @returns {!Long} Difference\r\n     */\r\n    LongPrototype.sub = LongPrototype.subtract;\r\n\r\n    /**\r\n     * Returns the product of this and the specified Long.\r\n     * @param {!Long|number|string} multiplier Multiplier\r\n     * @returns {!Long} Product\r\n     */\r\n    LongPrototype.multiply = function multiply(multiplier) {\r\n        if (this.isZero())\r\n            return ZERO;\r\n        if (!isLong(multiplier))\r\n            multiplier = fromValue(multiplier);\r\n        if (multiplier.isZero())\r\n            return ZERO;\r\n        if (this.eq(MIN_VALUE))\r\n            return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n        if (multiplier.eq(MIN_VALUE))\r\n            return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n        if (this.isNegative()) {\r\n            if (multiplier.isNegative())\r\n                return this.neg().mul(multiplier.neg());\r\n            else\r\n                return this.neg().mul(multiplier).neg();\r\n        } else if (multiplier.isNegative())\r\n            return this.mul(multiplier.neg()).neg();\r\n\r\n        // If both longs are small, use float multiplication\r\n        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n        // We can skip products that would overflow.\r\n\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n\r\n        var b48 = multiplier.high >>> 16;\r\n        var b32 = multiplier.high & 0xFFFF;\r\n        var b16 = multiplier.low >>> 16;\r\n        var b00 = multiplier.low & 0xFFFF;\r\n\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 * b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 * b00;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c16 += a00 * b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 * b00;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a16 * b16;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a00 * b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n        c48 &= 0xFFFF;\r\n        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n     * @function\r\n     * @param {!Long|number|string} multiplier Multiplier\r\n     * @returns {!Long} Product\r\n     */\r\n    LongPrototype.mul = LongPrototype.multiply;\r\n\r\n    /**\r\n     * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n     *  unsigned if this Long is unsigned.\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Quotient\r\n     */\r\n    LongPrototype.divide = function divide(divisor) {\r\n        if (!isLong(divisor))\r\n            divisor = fromValue(divisor);\r\n        if (divisor.isZero())\r\n            throw Error('division by zero');\r\n        if (this.isZero())\r\n            return this.unsigned ? UZERO : ZERO;\r\n        var approx, rem, res;\r\n        if (!this.unsigned) {\r\n            // This section is only relevant for signed longs and is derived from the\r\n            // closure library as a whole.\r\n            if (this.eq(MIN_VALUE)) {\r\n                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n                else if (divisor.eq(MIN_VALUE))\r\n                    return ONE;\r\n                else {\r\n                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                    var halfThis = this.shr(1);\r\n                    approx = halfThis.div(divisor).shl(1);\r\n                    if (approx.eq(ZERO)) {\r\n                        return divisor.isNegative() ? ONE : NEG_ONE;\r\n                    } else {\r\n                        rem = this.sub(divisor.mul(approx));\r\n                        res = approx.add(rem.div(divisor));\r\n                        return res;\r\n                    }\r\n                }\r\n            } else if (divisor.eq(MIN_VALUE))\r\n                return this.unsigned ? UZERO : ZERO;\r\n            if (this.isNegative()) {\r\n                if (divisor.isNegative())\r\n                    return this.neg().div(divisor.neg());\r\n                return this.neg().div(divisor).neg();\r\n            } else if (divisor.isNegative())\r\n                return this.div(divisor.neg()).neg();\r\n            res = ZERO;\r\n        } else {\r\n            // The algorithm below has not been made for unsigned longs. It's therefore\r\n            // required to take special care of the MSB prior to running it.\r\n            if (!divisor.unsigned)\r\n                divisor = divisor.toUnsigned();\r\n            if (divisor.gt(this))\r\n                return UZERO;\r\n            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n                return UONE;\r\n            res = UZERO;\r\n        }\r\n\r\n        // Repeat the following until the remainder is less than other:  find a\r\n        // floating-point that approximates remainder / other *from below*, add this\r\n        // into the result, and subtract it from the remainder.  It is critical that\r\n        // the approximate value is less than or equal to the real value so that the\r\n        // remainder never becomes negative.\r\n        rem = this;\r\n        while (rem.gte(divisor)) {\r\n            // Approximate the result of division. This may be a little greater or\r\n            // smaller than the actual value.\r\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n            // We will tweak the approximate result by changing it in the 48-th digit or\r\n            // the smallest non-fractional digit, whichever is larger.\r\n            var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n            // Decrease the approximation until it is smaller than the remainder.  Note\r\n            // that if it is too large, the product overflows and is negative.\r\n                approxRes = fromNumber(approx),\r\n                approxRem = approxRes.mul(divisor);\r\n            while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n                approx -= delta;\r\n                approxRes = fromNumber(approx, this.unsigned);\r\n                approxRem = approxRes.mul(divisor);\r\n            }\r\n\r\n            // We know the answer can't be zero... and actually, zero would cause\r\n            // infinite recursion since we would make no progress.\r\n            if (approxRes.isZero())\r\n                approxRes = ONE;\r\n\r\n            res = res.add(approxRes);\r\n            rem = rem.sub(approxRem);\r\n        }\r\n        return res;\r\n    };\r\n\r\n    /**\r\n     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n     * @function\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Quotient\r\n     */\r\n    LongPrototype.div = LongPrototype.divide;\r\n\r\n    /**\r\n     * Returns this Long modulo the specified.\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Remainder\r\n     */\r\n    LongPrototype.modulo = function modulo(divisor) {\r\n        if (!isLong(divisor))\r\n            divisor = fromValue(divisor);\r\n        return this.sub(this.div(divisor).mul(divisor));\r\n    };\r\n\r\n    /**\r\n     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n     * @function\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Remainder\r\n     */\r\n    LongPrototype.mod = LongPrototype.modulo;\r\n\r\n    /**\r\n     * Returns the bitwise NOT of this Long.\r\n     * @returns {!Long}\r\n     */\r\n    LongPrototype.not = function not() {\r\n        return fromBits(~this.low, ~this.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the bitwise AND of this Long and the specified.\r\n     * @param {!Long|number|string} other Other Long\r\n     * @returns {!Long}\r\n     */\r\n    LongPrototype.and = function and(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the bitwise OR of this Long and the specified.\r\n     * @param {!Long|number|string} other Other Long\r\n     * @returns {!Long}\r\n     */\r\n    LongPrototype.or = function or(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the bitwise XOR of this Long and the given one.\r\n     * @param {!Long|number|string} other Other Long\r\n     * @returns {!Long}\r\n     */\r\n    LongPrototype.xor = function xor(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits shifted to the left by the given amount.\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        if ((numBits &= 63) === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n        else\r\n            return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n     * @function\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n    /**\r\n     * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shiftRight = function shiftRight(numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        if ((numBits &= 63) === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n        else\r\n            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n     * @function\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n    /**\r\n     * Returns this Long with bits logically shifted to the right by the given amount.\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        numBits &= 63;\r\n        if (numBits === 0)\r\n            return this;\r\n        else {\r\n            var high = this.high;\r\n            if (numBits < 32) {\r\n                var low = this.low;\r\n                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n            } else if (numBits === 32)\r\n                return fromBits(high, 0, this.unsigned);\r\n            else\r\n                return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n     * @function\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n    /**\r\n     * Converts this Long to signed.\r\n     * @returns {!Long} Signed long\r\n     */\r\n    LongPrototype.toSigned = function toSigned() {\r\n        if (!this.unsigned)\r\n            return this;\r\n        return fromBits(this.low, this.high, false);\r\n    };\r\n\r\n    /**\r\n     * Converts this Long to unsigned.\r\n     * @returns {!Long} Unsigned long\r\n     */\r\n    LongPrototype.toUnsigned = function toUnsigned() {\r\n        if (this.unsigned)\r\n            return this;\r\n        return fromBits(this.low, this.high, true);\r\n    };\r\n\r\n    /**\r\n     * Converts this Long to its byte representation.\r\n     * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n     * @returns {!Array.<number>} Byte representation\r\n     */\r\n    LongPrototype.toBytes = function(le) {\r\n        return le ? this.toBytesLE() : this.toBytesBE();\r\n    }\r\n\r\n    /**\r\n     * Converts this Long to its little endian byte representation.\r\n     * @returns {!Array.<number>} Little endian byte representation\r\n     */\r\n    LongPrototype.toBytesLE = function() {\r\n        var hi = this.high,\r\n            lo = this.low;\r\n        return [\r\n             lo         & 0xff,\r\n            (lo >>>  8) & 0xff,\r\n            (lo >>> 16) & 0xff,\r\n            (lo >>> 24) & 0xff,\r\n             hi         & 0xff,\r\n            (hi >>>  8) & 0xff,\r\n            (hi >>> 16) & 0xff,\r\n            (hi >>> 24) & 0xff\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Converts this Long to its big endian byte representation.\r\n     * @returns {!Array.<number>} Big endian byte representation\r\n     */\r\n    LongPrototype.toBytesBE = function() {\r\n        var hi = this.high,\r\n            lo = this.low;\r\n        return [\r\n            (hi >>> 24) & 0xff,\r\n            (hi >>> 16) & 0xff,\r\n            (hi >>>  8) & 0xff,\r\n             hi         & 0xff,\r\n            (lo >>> 24) & 0xff,\r\n            (lo >>> 16) & 0xff,\r\n            (lo >>>  8) & 0xff,\r\n             lo         & 0xff\r\n        ];\r\n    }\r\n\r\n    return Long;\r\n});\r\n","\"use strict\";\nvar S2_1 = require(\"./S2\");\nvar Interval = (function () {\n    function Interval(lo, hi) {\n        this.lo = S2_1.S2.toDecimal(lo);\n        this.hi = S2_1.S2.toDecimal(hi);\n    }\n    Interval.prototype.toString = function () {\n        return \"[\" + this.lo.toString() + \", \" + this.hi.toString() + \"]\";\n    };\n    /**\n     * Return true if two intervals contains the same set of points.\n     */\n    Interval.prototype.equals = function (that) {\n        if (typeof (that) === typeof (this)) {\n            return this.lo.eq(that.lo) && this.hi.eq(that.hi);\n        }\n        return false;\n    };\n    return Interval;\n}());\nexports.Interval = Interval;\n//# sourceMappingURL=Interval.js.map","\"use strict\";\nvar MutableInteger = (function () {\n    function MutableInteger(val) {\n        this.val = val;\n    }\n    return MutableInteger;\n}());\nexports.MutableInteger = MutableInteger;\n//# sourceMappingURL=MutableInteger.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Interval_1 = require(\"./Interval\");\nvar S2_1 = require(\"./S2\");\nvar decimal_1 = require('./decimal');\n/**\n * An R1Interval represents a closed interval on a unit circle (also known as a\n * 1-dimensional sphere). It is capable of representing the empty interval\n * (containing no points), the full interval (containing all points), and\n * zero-length intervals (containing a single point).\n *\n *  Points are represented by the angle they make with the positive x-axis in\n * the range [-Pi, Pi]. An interval is represented by its lower and upper bounds\n * (both inclusive, since the interval is closed). The lower bound may be\n * greater than the upper bound, in which case the interval is \"inverted\" (i.e.\n * it passes through the point (-1, 0)).\n *\n *  Note that the point (-1, 0) has two valid representations, Pi and -Pi. The\n * normalized representation of this point internally is Pi, so that endpoints\n * of normal intervals are in the range (-Pi, Pi]. However, we take advantage of\n * the point -Pi to construct two special intervals: the Full() interval is\n * [-Pi, Pi], and the Empty() interval is [Pi, -Pi].\n *\n */\nvar R1Interval = (function (_super) {\n    __extends(R1Interval, _super);\n    function R1Interval() {\n        _super.apply(this, arguments);\n    }\n    /** Return true if the interval is empty, i.e. it contains no points. */\n    R1Interval.prototype.isEmpty = function () {\n        return this.lo.gt(this.hi);\n    };\n    R1Interval.prototype.getCenter = function () {\n        return this.lo.plus(this.hi).dividedBy(2);\n    };\n    R1Interval.prototype.getLength = function () {\n        return this.hi.minus(this.lo);\n    };\n    R1Interval.prototype.contains = function (_p) {\n        var p = S2_1.S2.toDecimal(_p);\n        return p.gte(this.lo) && p.lte(this.hi);\n    };\n    /** Return true if the interior of the interval contains the point 'p'. */\n    R1Interval.prototype.interiorContains = function (_p) {\n        var p = S2_1.S2.toDecimal(_p);\n        return p.gt(this.lo) && p.lt(this.hi);\n    };\n    /**\n     * Return true if the interval contains the given interval 'y'. Works for\n     * empty, full, and singleton intervals.\n     */\n    R1Interval.prototype.containsI = function (y) {\n        if (y.isEmpty()) {\n            return true;\n        }\n        return y.lo.gte(this.lo) && y.hi.lte(this.hi);\n    };\n    R1Interval.prototype.interiorContainsI = function (y) {\n        if (y.isEmpty()) {\n            return true;\n        }\n        return y.lo.gt(this.lo) && y.hi.lt(this.hi);\n    };\n    /**\n     * Return true if this interval intersects the given interval, i.e. if they\n     * have any points in common.\n     */\n    R1Interval.prototype.intersects = function (y) {\n        if (this.lo.lte(y.lo)) {\n            return y.lo.lte(this.hi) && y.lo.lte(y.hi);\n        }\n        else {\n            return this.lo.lte(y.hi) && this.lo.lte(this.hi);\n        }\n    };\n    /**\n     * Return true if the interior of this interval intersects any point of the\n     * given interval (including its boundary).\n     */\n    R1Interval.prototype.interiorIntersects = function (y) {\n        return y.lo.lt(this.hi) && this.lo.lt(y.hi) && this.lo.lt(this.hi) && y.lo.lte(y.hi);\n    };\n    /** Expand the interval so that it contains the given point \"p\". */\n    R1Interval.prototype.addPoint = function (_p) {\n        var p = S2_1.S2.toDecimal(_p);\n        if (this.isEmpty()) {\n            return R1Interval.fromPoint(p);\n        }\n        else if (p.lt(this.lo)) {\n            return new R1Interval(p, this.hi);\n        }\n        else if (p.gt(this.hi)) {\n            return new R1Interval(this.lo, p);\n        }\n        else {\n            return new R1Interval(this.lo, this.hi);\n        }\n    };\n    /**\n     * Return an interval that contains all points with a distance \"radius\" of a\n     * point in this interval. Note that the expansion of an empty interval is\n     * always empty.\n     */\n    R1Interval.prototype.expanded = function (_radius) {\n        var radius = S2_1.S2.toDecimal(_radius);\n        // assert (radius >= 0);\n        if (this.isEmpty()) {\n            return this;\n        }\n        return new R1Interval(this.lo.minus(radius), this.hi.plus(radius));\n    };\n    /**\n     * Return the smallest interval that contains this interval and the given\n     * interval \"y\".\n     */\n    R1Interval.prototype.union = function (y) {\n        if (this.isEmpty()) {\n            return y;\n        }\n        if (y.isEmpty()) {\n            return this;\n        }\n        return new R1Interval(decimal_1.Decimal.min(this.lo, y.lo), decimal_1.Decimal.max(this.hi, y.hi));\n    };\n    /**\n     * Return the intersection of this interval with the given interval. Empty\n     * intervals do not need to be special-cased.\n     */\n    R1Interval.prototype.intersection = function (y) {\n        return new R1Interval(decimal_1.Decimal.max(this.lo, y.lo), decimal_1.Decimal.min(this.hi, y.hi));\n    };\n    /**\n     * Return true if the length of the symmetric difference between the two\n     * intervals is at most the given tolerance.\n     */\n    R1Interval.prototype.approxEquals = function (y, maxError) {\n        if (maxError === void 0) { maxError = 1e-15; }\n        if (this.isEmpty()) {\n            return y.getLength().lte(maxError);\n        }\n        if (y.isEmpty()) {\n            return this.getLength().lte(maxError);\n        }\n        return y.lo.minus(this.lo).abs()\n            .plus(y.hi.minus(this.hi).abs())\n            .lte(maxError);\n    };\n    R1Interval.empty = function () {\n        return new R1Interval(1, 0);\n    };\n    R1Interval.fromPoint = function (p) {\n        return new R1Interval(p, p);\n    };\n    /**\n     * Convenience method to construct the minimal interval containing the two\n     * given points. This is equivalent to starting with an empty interval and\n     * calling AddPoint() twice, but it is more efficient.\n     */\n    R1Interval.fromPointPair = function (_p1, _p2) {\n        var p1 = S2_1.S2.toDecimal(_p1);\n        var p2 = S2_1.S2.toDecimal(_p2);\n        if (p1.lte(p2)) {\n            return new R1Interval(p1, p2);\n        }\n        else {\n            return new R1Interval(p2, p1);\n        }\n    };\n    return R1Interval;\n}(Interval_1.Interval));\nexports.R1Interval = R1Interval;\n//# sourceMappingURL=R1Interval.js.map","\"use strict\";\nvar S2Point_1 = require(\"./S2Point\");\nvar decimal_1 = require('./decimal');\nvar S2_1 = require(\"./S2\");\n/**\n * R2Vector represents a vector in the two-dimensional space. It defines the\n * basic geometrical operations for 2D vectors, e.g. cross product, addition,\n * norm, comparison etc.\n *\n */\nvar R2Vector = (function () {\n    function R2Vector(_x, _y) {\n        this._x = new decimal_1.Decimal(_x);\n        this._y = new decimal_1.Decimal(_y);\n        // this._x = new Decimal(_x) as decimal.Decimal;\n        // this._y = new Decimal(_y) as decimal.Decimal;\n    }\n    Object.defineProperty(R2Vector.prototype, \"x\", {\n        get: function () {\n            return this._x;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(R2Vector.prototype, \"y\", {\n        get: function () {\n            return this._y;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    R2Vector.prototype.get = function (index) {\n        if (index > 1) {\n            throw new Error(\"Index out fo bounds error \" + index);\n        }\n        return index == 0 ? this._x : this._y;\n    };\n    R2Vector.fromPointFace = function (p, face) {\n        return p.toR2Vector(face);\n    };\n    R2Vector.add = function (p1, p2) {\n        return new R2Vector(p1._x.plus(p2._x), p1._y.plus(p2._y));\n    };\n    R2Vector.mul = function (p, _m) {\n        var m = new decimal_1.Decimal(_m);\n        return new R2Vector(m.times(p._x), m.times(p._y));\n    };\n    R2Vector.prototype.norm2 = function () {\n        return this.x.pow(2).plus(this.y.pow(2));\n    };\n    R2Vector.dotProd = function (p1, p2) {\n        return p1.x.times(p2.x).plus(p1.y.times(p2.y));\n    };\n    R2Vector.prototype.dotProd = function (that) {\n        return R2Vector.dotProd(this, that);\n    };\n    R2Vector.prototype.crossProd = function (that) {\n        return this.x.times(that.y).minus(this.y.times(that.x));\n    };\n    R2Vector.prototype.lessThan = function (vb) {\n        if (this.x.lt(vb.x)) {\n            return true;\n        }\n        if (vb.x.lt(this.x)) {\n            return false;\n        }\n        if (this.y.lt(vb.y)) {\n            return true;\n        }\n        return false;\n    };\n    //\n    // @Override\n    // public boolean equals(Object that) {\n    //   if (!(that instanceof R2Vector)) {\n    //     return false;\n    //   }\n    //   R2Vector thatPoint = (R2Vector) that;\n    //   return this.x == thatPoint.x && this.y == thatPoint.y;\n    // }\n    // /**\n    //  * Calcualates hashcode based on stored coordinates. Since we want +0.0 and\n    //  * -0.0 to be treated the same, we ignore the sign of the coordinates.\n    //  */\n    // @Override\n    // public int hashCode() {\n    //   long value = 17;\n    //   value += 37 * value + Double.doubleToLongBits(Math.abs(x));\n    //   value += 37 * value + Double.doubleToLongBits(Math.abs(y));\n    //   return (int) (value ^ (value >>> 32));\n    // }\n    //\n    R2Vector.fromSTVector = function (stVector) {\n        return new R2Vector(R2Vector.singleStTOUV(stVector.x), R2Vector.singleStTOUV(stVector.y));\n    };\n    // from S2Projections.stToUV (QUADRATIC)\n    R2Vector.singleStTOUV = function (_s) {\n        var s = S2_1.S2.toDecimal(_s);\n        if (s.gte(0)) {\n            return S2_1.S2.toDecimal(1)\n                .dividedBy(3)\n                .times(s.plus(1).pow(2).minus(1));\n        }\n        else {\n            return S2_1.S2.toDecimal(1)\n                .dividedBy(3)\n                .times(S2_1.S2.toDecimal(1)\n                .minus(S2_1.S2.toDecimal(1).minus(s).pow(2)));\n        }\n    };\n    R2Vector.singleUVToST = function (_x) {\n        var x = S2_1.S2.toDecimal(_x);\n        if (x.gte(0)) {\n            return decimal_1.Decimal.sqrt(x.times(3).plus(1)).minus(1);\n        }\n        else {\n            return S2_1.S2.toDecimal(1)\n                .minus(decimal_1.Decimal.sqrt(S2_1.S2.toDecimal(1).minus(x.times(3))));\n        }\n    };\n    /**\n     * To be used only if this vector is representing uv.\n     * @param face\n     * @returns {S2Point}\n     */\n    R2Vector.prototype.toPoint = function (face) {\n        switch (face) {\n            case 0:\n                return new S2Point_1.S2Point(1, this.x, this.y);\n            case 1:\n                return new S2Point_1.S2Point(this.x.neg(), 1, this.y);\n            case 2:\n                return new S2Point_1.S2Point(this.x.neg(), this.y.neg(), 1);\n            case 3:\n                return new S2Point_1.S2Point(-1, this.y.neg(), this.x.neg());\n            case 4:\n                return new S2Point_1.S2Point(this.y, -1, this.x.neg());\n            default:\n                return new S2Point_1.S2Point(this.y, this.x, -1);\n        }\n    };\n    R2Vector.prototype.toSt = function (which) {\n        return which == 0 ? R2Vector.singleUVToST(this.x) : R2Vector.singleUVToST(this.y);\n    };\n    R2Vector.prototype.toString = function () {\n        return \"(\" + this.x.toString() + \", \" + this.y.toString() + \")\";\n    };\n    return R2Vector;\n}());\nexports.R2Vector = R2Vector;\n//# sourceMappingURL=R2Vector.js.map","\"use strict\";\nvar decimal_1 = require('./decimal');\nvar S2_1 = require(\"./S2\");\nvar S1Angle = (function () {\n    function S1Angle(radians) {\n        this.radians = new decimal_1.Decimal(radians);\n    }\n    S1Angle.prototype.degrees = function () {\n        return S2_1.S2.toDecimal(this.radians).times((180 / Math.PI));\n    };\n    //\n    // public long e5() {\n    //   return Math.round(degrees() * 1e5);\n    // }\n    //\n    // public long e6() {\n    //   return Math.round(degrees() * 1e6);\n    // }\n    //\n    // public long e7() {\n    //   return Math.round(degrees() * 1e7);\n    // }\n    /**\n     * Return the angle between two points, which is also equal to the distance\n     * between these points on the unit sphere. The points do not need to be\n     * normalized.\n     */\n    S1Angle.fromPoints = function (x, y) {\n        return new S1Angle(x.angle(y));\n    };\n    S1Angle.prototype.lessThan = function (that) {\n        return this.radians.lt(that.radians);\n    };\n    S1Angle.prototype.greaterThan = function (that) {\n        return this.radians.gt(that.radians);\n    };\n    S1Angle.prototype.lessOrEquals = function (that) {\n        return this.radians.lte(that.radians);\n    };\n    S1Angle.prototype.greaterOrEquals = function (that) {\n        return this.radians.gte(that.radians);\n    };\n    S1Angle.max = function (left, right) {\n        return right.greaterThan(left) ? right : left;\n    };\n    S1Angle.min = function (left, right) {\n        return right.greaterThan(left) ? left : right;\n    };\n    S1Angle.degrees = function (degrees) {\n        var d = new decimal_1.Decimal(degrees);\n        return new S1Angle(d.times(Math.PI / 180));\n    };\n    //\n    // public static S1Angle e5(long e5) {\n    //   return degrees(e5 * 1e-5);\n    // }\n    //\n    // public static S1Angle e6(long e6) {\n    //   // Multiplying by 1e-6 isn't quite as accurate as dividing by 1e6,\n    //   // but it's about 10 times faster and more than accurate enough.\n    //   return degrees(e6 * 1e-6);\n    // }\n    //\n    // public static S1Angle e7(long e7) {\n    //   return degrees(e7 * 1e-7);\n    // }\n    /**\n     * Writes the angle in degrees with a \"d\" suffix, e.g. \"17.3745d\". By default\n     * 6 digits are printed; this can be changed using setprecision(). Up to 17\n     * digits are required to distinguish one angle from another.\n     */\n    S1Angle.prototype.toString = function () {\n        return this.degrees() + \"d\";\n    };\n    S1Angle.prototype.compareTo = function (that) {\n        return this.radians < that.radians ? -1 : this.radians > that.radians ? 1 : 0;\n    };\n    return S1Angle;\n}());\nexports.S1Angle = S1Angle;\n//# sourceMappingURL=S1Angle.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Interval_1 = require(\"./Interval\");\nvar S2_1 = require(\"./S2\");\nvar S1Interval = (function (_super) {\n    __extends(S1Interval, _super);\n    function S1Interval(lo, hi, checked) {\n        if (checked === void 0) { checked = false; }\n        _super.call(this, lo, hi);\n        if (!checked) {\n            if (this.lo.eq(-S2_1.S2.M_PI) && !this.hi.eq(S2_1.S2.M_PI)) {\n                this.lo = S2_1.S2.toDecimal(S2_1.S2.M_PI);\n            }\n            if (this.hi.eq(-S2_1.S2.M_PI) && !this.lo.eq(S2_1.S2.M_PI)) {\n                this.hi = S2_1.S2.toDecimal(S2_1.S2.M_PI);\n            }\n        }\n    }\n    /**\n     * An interval is valid if neither bound exceeds Pi in absolute value, and the\n     * value -Pi appears only in the Empty() and Full() intervals.\n     */\n    S1Interval.prototype.isValid = function () {\n        return this.lo.abs().lte(S2_1.S2.M_PI) && this.hi.abs().lte(S2_1.S2.M_PI)\n            && !(this.lo.eq(-S2_1.S2.M_PI) && !this.hi.eq(S2_1.S2.M_PI))\n            && !(this.hi.eq(-S2_1.S2.M_PI) && !this.lo.eq(S2_1.S2.M_PI));\n        // return (Math.abs(this.lo) <= S2.M_PI && Math.abs(this.hi) <= S2.M_PI\n        // && !(this.lo == -S2.M_PI && this.hi != S2.M_PI) && !(this.hi == -S2.M_PI && this.lo != S2.M_PI));\n    };\n    /** Return true if the interval contains all points on the unit circle. */\n    S1Interval.prototype.isFull = function () {\n        // console.log(this.hi.minus(this.lo).eq(2 * S2.M_PI));\n        return this.hi.minus(this.lo).eq(2 * S2_1.S2.M_PI);\n    };\n    /** Return true if the interval is empty, i.e. it contains no points. */\n    S1Interval.prototype.isEmpty = function () {\n        return this.lo.minus(this.hi).eq(2 * S2_1.S2.M_PI);\n    };\n    /* Return true if this.lo > this.hi. (This is true for empty intervals.) */\n    S1Interval.prototype.isInverted = function () {\n        return this.lo.gt(this.hi);\n    };\n    /**\n     * Return the midpoint of the interval. For full and empty intervals, the\n     * result is arbitrary.\n     */\n    S1Interval.prototype.getCenter = function () {\n        var center = this.lo.plus(this.hi).dividedBy(2);\n        // let center = 0.5 * (this.lo + this.hi);\n        if (!this.isInverted()) {\n            return center;\n        }\n        // Return the center in the range (-Pi, Pi].\n        return (center.lte(0)) ? (center.plus(S2_1.S2.M_PI)) : (center.minus(S2_1.S2.M_PI));\n    };\n    /**\n     * Return the length of the interval. The length of an empty interval is\n     * negative.\n     */\n    S1Interval.prototype.getLength = function () {\n        var length = this.hi.minus(this.lo);\n        if (length.gte(0)) {\n            return length;\n        }\n        length = length.plus(2 * S2_1.S2.M_PI);\n        // Empty intervals have a negative length.\n        return (length.gt(0)) ? length : S2_1.S2.toDecimal(-1);\n    };\n    /**\n     * Return the complement of the interior of the interval. An interval and its\n     * complement have the same boundary but do not share any interior values. The\n     * complement operator is not a bijection, since the complement of a singleton\n     * interval (containing a single value) is the same as the complement of an\n     * empty interval.\n     */\n    S1Interval.prototype.complement = function () {\n        if (this.lo.eq(this.hi)) {\n            return S1Interval.full(); // Singleton.\n        }\n        return new S1Interval(this.hi, this.lo, true); // Handles\n        // empty and\n        // full.\n    };\n    /** Return true if the interval (which is closed) contains the point 'p'. */\n    S1Interval.prototype.contains = function (_p) {\n        var p = S2_1.S2.toDecimal(_p);\n        // Works for empty, full, and singleton intervals.\n        // assert (Math.abs(p) <= S2.M_PI);\n        if (p.eq(-S2_1.S2.M_PI)) {\n            p = S2_1.S2.toDecimal(S2_1.S2.M_PI);\n        }\n        return this.fastContains(p);\n    };\n    /**\n     * Return true if the interval (which is closed) contains the point 'p'. Skips\n     * the normalization of 'p' from -Pi to Pi.\n     *\n     */\n    S1Interval.prototype.fastContains = function (_p) {\n        var p = S2_1.S2.toDecimal(_p);\n        if (this.isInverted()) {\n            return (p.gte(this.lo) || p.lte(this.hi)) && !this.isEmpty();\n        }\n        else {\n            return p.gte(this.lo) && p.lte(this.hi);\n        }\n    };\n    /** Return true if the interior of the interval contains the point 'p'. */\n    S1Interval.prototype.interiorContains = function (_p) {\n        // Works for empty, full, and singleton intervals.\n        // assert (Math.abs(p) <= S2.M_PI);\n        var p = S2_1.S2.toDecimal(_p);\n        if (p.eq(-S2_1.S2.M_PI)) {\n            p = S2_1.S2.toDecimal(S2_1.S2.M_PI);\n        }\n        if (this.isInverted()) {\n            return p.gt(this.lo) || p.lt(this.hi);\n        }\n        else {\n            return (p.gt(this.lo) && p.lt(this.hi)) || this.isFull();\n        }\n    };\n    /**\n     * Return true if the interval contains the given interval 'y'. Works for\n     * empty, full, and singleton intervals.\n     */\n    S1Interval.prototype.containsI = function (y) {\n        // It might be helpful to compare the structure of these tests to\n        // the simpler Contains(number) method above.\n        if (this.isInverted()) {\n            if (y.isInverted()) {\n                return y.lo.gte(this.lo) && y.hi.lte(this.hi);\n            }\n            return (y.lo.gte(this.lo) || y.hi.lte(this.hi)) && !this.isEmpty();\n        }\n        else {\n            if (y.isInverted()) {\n                return this.isFull() || y.isEmpty();\n            }\n            return y.lo.gte(this.lo) && y.hi.lte(this.hi);\n        }\n    };\n    /**\n     * Returns true if the interior of this interval contains the entire interval\n     * 'y'. Note that x.InteriorContains(x) is true only when x is the empty or\n     * full interval, and x.InteriorContains(S1Interval(p,p)) is equivalent to\n     * x.InteriorContains(p).\n     */\n    S1Interval.prototype.interiorContainsI = function (y) {\n        if (this.isInverted()) {\n            if (!y.isInverted()) {\n                return this.lo.gt(this.lo) || y.hi.lt(this.hi);\n            }\n            return (y.lo.gt(this.lo) && y.hi.lt(this.hi)) || y.isEmpty();\n        }\n        else {\n            if (y.isInverted()) {\n                return this.isFull() || y.isEmpty();\n            }\n            return (y.lo.gt(this.lo) && y.hi.lt(this.hi)) || this.isFull();\n        }\n    };\n    /**\n     * Return true if the two intervals contain any points in common. Note that\n     * the point +/-Pi has two representations, so the intervals [-Pi,-3] and\n     * [2,Pi] intersect, for example.\n     */\n    S1Interval.prototype.intersects = function (y) {\n        if (this.isEmpty() || y.isEmpty()) {\n            return false;\n        }\n        if (this.isInverted()) {\n            // Every non-empty inverted interval contains Pi.\n            return y.isInverted() || y.lo.lte(this.hi) || y.hi.gte(this.lo);\n        }\n        else {\n            if (y.isInverted()) {\n                return y.lo.lte(this.hi) || y.hi.gte(this.lo);\n            }\n            return y.lo.lte(this.hi) && y.hi.gte(this.lo);\n        }\n    };\n    /**\n     * Return true if the interior of this interval contains any point of the\n     * interval 'y' (including its boundary). Works for empty, full, and singleton\n     * intervals.\n     */\n    S1Interval.prototype.interiorIntersects = function (y) {\n        if (this.isEmpty() || y.isEmpty() || this.lo.eq(this.hi)) {\n            return false;\n        }\n        if (this.isInverted()) {\n            return y.isInverted() || y.lo.lt(this.hi) || y.hi.gt(this.lo);\n        }\n        else {\n            if (y.isInverted()) {\n                return y.lo.lt(this.hi) || y.hi.gt(this.lo);\n            }\n            return (y.lo.lt(this.hi) && y.hi.gt(this.lo)) || this.isFull();\n        }\n    };\n    /**\n     * Expand the interval by the minimum amount necessary so that it contains the\n     * given point \"p\" (an angle in the range [-Pi, Pi]).\n     */\n    S1Interval.prototype.addPoint = function (_p) {\n        var p = S2_1.S2.toDecimal(_p);\n        // assert (Math.abs(p) <= S2.M_PI);\n        if (p.eq(-S2_1.S2.M_PI)) {\n            p = S2_1.S2.toDecimal(S2_1.S2.M_PI);\n        }\n        if (this.fastContains(p)) {\n            return new S1Interval(this.lo, this.hi);\n        }\n        if (this.isEmpty()) {\n            return S1Interval.fromPoint(p);\n        }\n        else {\n            // Compute distance from p to each endpoint.\n            var dlo = S1Interval.positiveDistance(p, this.lo);\n            var dhi = S1Interval.positiveDistance(this.hi, p);\n            if (dlo.lt(dhi)) {\n                return new S1Interval(p, this.hi);\n            }\n            else {\n                return new S1Interval(this.lo, p);\n            }\n        }\n    };\n    /**\n     * Return an interval that contains all points within a distance \"radius\" of\n     * a point in this interval. Note that the expansion of an empty interval is\n     * always empty. The radius must be non-negative.\n     */\n    S1Interval.prototype.expanded = function (_radius) {\n        var radius = S2_1.S2.toDecimal(_radius);\n        // assert (radius >= 0);\n        if (this.isEmpty()) {\n            return this;\n        }\n        // Check whether this interval will be full after expansion, allowing\n        // for a 1-bit rounding error when computing each endpoint.\n        if (this.getLength().plus(radius.times(2)).gte(2 * S2_1.S2.M_PI - 1e-15)) {\n            return S1Interval.full();\n        }\n        // NOTE(dbeaumont): Should this remainder be 2 * M_PI or just M_PI ??\n        var lo = S2_1.S2.IEEEremainder(this.lo.minus(radius), 2 * S2_1.S2.M_PI);\n        var hi = S2_1.S2.IEEEremainder(this.hi.plus(radius), 2 * S2_1.S2.M_PI);\n        if (lo.eq(-S2_1.S2.M_PI)) {\n            lo = S2_1.S2.toDecimal(S2_1.S2.M_PI);\n        }\n        return new S1Interval(lo, hi);\n    };\n    /**\n     * Return the smallest interval that contains this interval and the given\n     * interval \"y\".\n     */\n    S1Interval.prototype.union = function (y) {\n        // The y.is_full() case is handled correctly in all cases by the code\n        // below, but can follow three separate code paths depending on whether\n        // this interval is inverted, is non-inverted but contains Pi, or neither.\n        if (y.isEmpty()) {\n            return this;\n        }\n        if (this.fastContains(y.lo)) {\n            if (this.fastContains(y.hi)) {\n                // Either this interval contains y, or the union of the two\n                // intervals is the Full() interval.\n                if (this.containsI(y)) {\n                    return this; // is_full() code path\n                }\n                return S1Interval.full();\n            }\n            return new S1Interval(this.lo, this.hi, true);\n        }\n        if (this.fastContains(y.hi)) {\n            return new S1Interval(y.lo, this.hi, true);\n        }\n        // This interval contains neither endpoint of y. This means that either y\n        // contains all of this interval, or the two intervals are disjoint.\n        if (this.isEmpty() || y.fastContains(this.lo)) {\n            return y;\n        }\n        // Check which pair of endpoints are closer together.\n        var dlo = S1Interval.positiveDistance(y.hi, this.lo);\n        var dhi = S1Interval.positiveDistance(this.hi, y.lo);\n        if (dlo < dhi) {\n            return new S1Interval(y.lo, this.hi, true);\n        }\n        else {\n            return new S1Interval(this.lo, y.hi, true);\n        }\n    };\n    /**\n     * Return the smallest interval that contains the intersection of this\n     * interval with \"y\". Note that the region of intersection may consist of two\n     * disjoint intervals.\n     */\n    S1Interval.prototype.intersection = function (y) {\n        // The y.is_full() case is handled correctly in all cases by the code\n        // below, but can follow three separate code paths depending on whether\n        // this interval is inverted, is non-inverted but contains Pi, or neither.\n        if (y.isEmpty()) {\n            return S1Interval.empty();\n        }\n        if (this.fastContains(y.lo)) {\n            if (this.fastContains(y.hi)) {\n                // Either this interval contains y, or the region of intersection\n                // consists of two disjoint subintervals. In either case, we want\n                // to return the shorter of the two original intervals.\n                if (y.getLength().lt(this.getLength())) {\n                    return y; // is_full() code path\n                }\n                return this;\n            }\n            return new S1Interval(y.lo, this.hi, true);\n        }\n        if (this.fastContains(y.hi)) {\n            return new S1Interval(this.lo, y.hi, true);\n        }\n        // This interval contains neither endpoint of y. This means that either y\n        // contains all of this interval, or the two intervals are disjoint.\n        if (y.fastContains(this.lo)) {\n            return this; // is_empty() okay here\n        }\n        // assert (!intersects(y));\n        return S1Interval.empty();\n    };\n    /**\n     * Return true if the length of the symmetric difference between the two\n     * intervals is at most the given tolerance.\n     */\n    S1Interval.prototype.approxEquals = function (y, maxError) {\n        if (maxError === void 0) { maxError = 1e-9; }\n        if (this.isEmpty()) {\n            return y.getLength().lte(maxError);\n        }\n        if (y.isEmpty()) {\n            return this.getLength().lte(maxError);\n        }\n        return S2_1.S2.IEEEremainder(y.lo.minus(this.lo), 2 * S2_1.S2.M_PI).abs()\n            .plus(S2_1.S2.IEEEremainder(y.hi.minus(this.hi), 2 * S2_1.S2.M_PI).abs())\n            .lte(maxError);\n    };\n    S1Interval.empty = function () {\n        return new S1Interval(S2_1.S2.M_PI, -S2_1.S2.M_PI, true);\n    };\n    S1Interval.full = function () {\n        return new S1Interval(-S2_1.S2.M_PI, S2_1.S2.M_PI, true);\n    };\n    S1Interval.fromPoint = function (_p) {\n        var p = S2_1.S2.toDecimal(_p);\n        if (p.eq(-S2_1.S2.M_PI)) {\n            p = S2_1.S2.toDecimal(S2_1.S2.M_PI);\n        }\n        return new S1Interval(p, p, true);\n    };\n    /**\n     * Convenience method to construct the minimal interval containing the two\n     * given points. This is equivalent to starting with an empty interval and\n     * calling AddPoint() twice, but it is more efficient.\n     */\n    S1Interval.fromPointPair = function (_p1, _p2) {\n        // assert (Math.abs(p1) <= S2.M_PI && Math.abs(p2) <= S2.M_PI);\n        var p1 = S2_1.S2.toDecimal(_p1);\n        var p2 = S2_1.S2.toDecimal(_p2);\n        if (p1.eq(-S2_1.S2.M_PI)) {\n            p1 = S2_1.S2.toDecimal(S2_1.S2.M_PI);\n        }\n        if (p2.eq(-S2_1.S2.M_PI)) {\n            p2 = S2_1.S2.toDecimal(S2_1.S2.M_PI);\n        }\n        if (S1Interval.positiveDistance(p1, p2).lte(S2_1.S2.M_PI)) {\n            return new S1Interval(p1, p2, true);\n        }\n        else {\n            return new S1Interval(p2, p1, true);\n        }\n    };\n    /**\n     * Compute the distance from \"a\" to \"b\" in the range [0, 2*Pi). This is\n     * equivalent to (drem(b - a - S2.M_PI, 2 * S2.M_PI) + S2.M_PI), except that\n     * it is more numerically stable (it does not lose precision for very small\n     * positive distances).\n     */\n    S1Interval.positiveDistance = function (_a, _b) {\n        var a = S2_1.S2.toDecimal(_a);\n        var b = S2_1.S2.toDecimal(_b);\n        var d = b.minus(a);\n        if (d.gte(0)) {\n            return d;\n        }\n        // We want to ensure that if b == Pi and a == (-Pi + eps),\n        // the return result is approximately 2*Pi and not zero.\n        return b.plus(S2_1.S2.M_PI).minus(a.minus(S2_1.S2.M_PI));\n    };\n    return S1Interval;\n}(Interval_1.Interval));\nexports.S1Interval = S1Interval;\n//# sourceMappingURL=S1Interval.js.map","\"use strict\";\nvar S2Point_1 = require(\"./S2Point\");\nvar decimal_1 = require('./decimal');\nvar S2Metric_1 = require(\"./S2Metric\");\nexports.S2Metric = S2Metric_1.S2Metric;\nvar Long = require('long');\nvar S2 = (function () {\n    function S2() {\n    }\n    S2.IEEEremainder = function (_f1, _f2) {\n        var f1 = S2.toDecimal(_f1);\n        var f2 = S2.toDecimal(_f2);\n        var r = f1.mod(f2);\n        if (r.isNaN() || r.eq(f2) || r.lessThanOrEqualTo(f2.abs().dividedBy(2))) {\n            return r;\n        }\n        else {\n            return (f1.gte(0) ? S2.toDecimal(1) : S2.toDecimal(-1)).times(r.minus(f2));\n        }\n    };\n    /**\n     * Return true if the given point is approximately unit length (this is mainly\n     * useful for assertions).\n     */\n    S2.isUnitLength = function (p) {\n        return p.norm2().minus(1).abs().lte(1e-15);\n    };\n    /**\n     * If v is non-zero, return an integer {@code exp} such that\n     * {@code (0.5 <= |v|*2^(-exp) < 1)}. If v is zero, return 0.\n     *\n     * <p>Note that this arguably a bad definition of exponent because it makes\n     * {@code exp(9) == 4}. In decimal this would be like saying that the\n     * exponent of 1234 is 4, when in scientific 'exponent' notation 1234 is\n     * {@code 1.234 x 10^3}.\n     *\n     * TODO(dbeaumont): Replace this with \"DoubleUtils.getExponent(v) - 1\" ?\n     */\n    S2.exp = function (v /*double*/) {\n        if (v == 0) {\n            return 0;\n        }\n        // IT should always be ((int)log(2,v))+1;\n        var start = Math.floor(Math.log(v) / Math.log(2));\n        for (var i = start; i < start + 10; i++) {\n            var curVal = Math.abs(v) * Math.pow(2, -i);\n            if (curVal >= 0.5 && curVal < 1) {\n                return i;\n            }\n        }\n        throw new Error('method not written yet');\n        // return (int)((S2.EXPONENT_MASK & bits) >> S2.EXPONENT_SHIFT) - 1022;\n    };\n    /**\n     * Return a vector \"c\" that is orthogonal to the given unit-length vectors \"a\"\n     * and \"b\". This function is similar to a.CrossProd(b) except that it does a\n     * better job of ensuring orthogonality when \"a\" is nearly parallel to \"b\",\n     * and it returns a non-zero result even when a == b or a == -b.\n     *\n     *  It satisfies the following properties (RCP == RobustCrossProd):\n     *\n     *  (1) RCP(a,b) != 0 for all a, b (2) RCP(b,a) == -RCP(a,b) unless a == b or\n     * a == -b (3) RCP(-a,b) == -RCP(a,b) unless a == b or a == -b (4) RCP(a,-b)\n     * == -RCP(a,b) unless a == b or a == -b\n     */\n    S2.robustCrossProd = function (a, b) {\n        // The direction of a.CrossProd(b) becomes unstable as (a + b) or (a - b)\n        // approaches zero. This leads to situations where a.CrossProd(b) is not\n        // very orthogonal to \"a\" and/or \"b\". We could fix this using Gram-Schmidt,\n        // but we also want b.RobustCrossProd(a) == -b.RobustCrossProd(a).\n        //\n        // The easiest fix is to just compute the cross product of (b+a) and (b-a).\n        // Given that \"a\" and \"b\" are unit-length, this has good orthogonality to\n        // \"a\" and \"b\" even if they differ only in the lowest bit of one component.\n        // assert (isUnitLength(a) && isUnitLength(b));\n        var x = S2Point_1.S2Point.crossProd(S2Point_1.S2Point.add(b, a), S2Point_1.S2Point.sub(b, a));\n        if (!x.equals(new S2Point_1.S2Point(0, 0, 0))) {\n            return x;\n        }\n        // The only result that makes sense mathematically is to return zero, but\n        // we find it more convenient to return an arbitrary orthogonal vector.\n        return a.ortho();\n    };\n    /**\n     * Return the area of triangle ABC. The method used is about twice as\n     * expensive as Girard's formula, but it is numerically stable for both large\n     * and very small triangles. The points do not need to be normalized. The area\n     * is always positive.\n     *\n     *  The triangle area is undefined if it contains two antipodal points, and\n     * becomes numerically unstable as the length of any edge approaches 180\n     * degrees.\n     */\n    S2.area = function (a, b, c) {\n        // This method is based on l'Huilier's theorem,\n        //\n        // tan(E/4) = sqrt(tan(s/2) tan((s-a)/2) tan((s-b)/2) tan((s-c)/2))\n        //\n        // where E is the spherical excess of the triangle (i.e. its area),\n        // a, b, c, are the side lengths, and\n        // s is the semiperimeter (a + b + c) / 2 .\n        //\n        // The only significant source of error using l'Huilier's method is the\n        // cancellation error of the terms (s-a), (s-b), (s-c). This leads to a\n        // *relative* error of about 1e-16 * s / min(s-a, s-b, s-c). This compares\n        // to a relative error of about 1e-15 / E using Girard's formula, where E is\n        // the true area of the triangle. Girard's formula can be even worse than\n        // this for very small triangles, e.g. a triangle with a true area of 1e-30\n        // might evaluate to 1e-5.\n        //\n        // So, we prefer l'Huilier's formula unless dmin < s * (0.1 * E), where\n        // dmin = min(s-a, s-b, s-c). This basically includes all triangles\n        // except for extremely long and skinny ones.\n        //\n        // Since we don't know E, we would like a conservative upper bound on\n        // the triangle area in terms of s and dmin. It's possible to show that\n        // E <= k1 * s * sqrt(s * dmin), where k1 = 2*sqrt(3)/Pi (about 1).\n        // Using this, it's easy to show that we should always use l'Huilier's\n        // method if dmin >= k2 * s^5, where k2 is about 1e-2. Furthermore,\n        // if dmin < k2 * s^5, the triangle area is at most k3 * s^4, where\n        // k3 is about 0.1. Since the best case error using Girard's formula\n        // is about 1e-15, this means that we shouldn't even consider it unless\n        // s >= 3e-4 or so.\n        // We use volatile doubles to force the compiler to truncate all of these\n        // quantities to 64 bits. Otherwise it may compute a value of dmin > 0\n        // simply because it chose to spill one of the intermediate values to\n        // memory but not one of the others.\n        var sa = b.angle(c);\n        var sb = c.angle(a);\n        var sc = a.angle(b);\n        var s = sa.plus(sb).plus(sc).times(0.5);\n        // 0.5 * (sa + sb + sc);\n        if (s.gte(3e-4)) {\n            // Consider whether Girard's formula might be more accurate.\n            var s2 = s.pow(2);\n            var dmin = s.minus(decimal_1.Decimal.max(sa, sb, sc));\n            if (dmin.lt(s2.pow(2).times(s).times(1e-2))) {\n                // This triangle is skinny enough to consider Girard's formula.\n                var area = S2.girardArea(a, b, c);\n                if (dmin.lt(s.times(area.times(0.1)))) {\n                    return area;\n                }\n            }\n        }\n        // Use l'Huilier's formula.\n        return S2.toDecimal(4)\n            .times(decimal_1.Decimal.atan(decimal_1.Decimal.sqrt(decimal_1.Decimal.max(0.0, decimal_1.Decimal.tan(s.times(0.5))\n            .times(decimal_1.Decimal.tan(s.minus(sa).times(0.5)))\n            .times(decimal_1.Decimal.tan(s.minus(sb).times(0.5)))\n            .times(decimal_1.Decimal.tan(s.minus(sc).times(0.5)))))));\n    };\n    /**\n     * Return the area of the triangle computed using Girard's formula. This is\n     * slightly faster than the Area() method above is not accurate for very small\n     * triangles.\n     */\n    S2.girardArea = function (a, b, c) {\n        // This is equivalent to the usual Girard's formula but is slightly\n        // more accurate, faster to compute, and handles a == b == c without\n        // a special case.\n        var ab = S2Point_1.S2Point.crossProd(a, b);\n        var bc = S2Point_1.S2Point.crossProd(b, c);\n        var ac = S2Point_1.S2Point.crossProd(a, c);\n        return decimal_1.Decimal.max(0, ab.angle(ac)\n            .minus(ab.angle(bc))\n            .plus(bc.angle(ac)));\n    };\n    S2.toDecimal = function (value) {\n        if (typeof (value) === 'number' || typeof (value) === 'string') {\n            return new decimal_1.Decimal(value);\n        }\n        return value;\n    };\n    /**\n     * Return true if the points A, B, C are strictly counterclockwise. Return\n     * false if the points are clockwise or colinear (i.e. if they are all\n     * contained on some great circle).\n     *\n     *  Due to numerical errors, situations may arise that are mathematically\n     * impossible, e.g. ABC may be considered strictly CCW while BCA is not.\n     * However, the implementation guarantees the following:\n     *\n     *  If SimpleCCW(a,b,c), then !SimpleCCW(c,b,a) for all a,b,c.\n     *\n     * In other words, ABC and CBA are guaranteed not to be both CCW\n     */\n    S2.simpleCCW = function (a, b, c) {\n        // We compute the signed volume of the parallelepiped ABC. The usual\n        // formula for this is (AxB).C, but we compute it here using (CxA).B\n        // in order to ensure that ABC and CBA are not both CCW. This follows\n        // from the following identities (which are true numerically, not just\n        // mathematically):\n        //\n        // (1) x.CrossProd(y) == -(y.CrossProd(x))\n        // (2) (-x).DotProd(y) == -(x.DotProd(y))\n        return S2Point_1.S2Point.crossProd(c, a).dotProd(b).gt(0);\n    };\n    /**\n     *\n     * Return true if edge AB crosses CD at a point that is interior to both\n     * edges. Properties:\n     *\n     *  (1) SimpleCrossing(b,a,c,d) == SimpleCrossing(a,b,c,d) (2)\n     * SimpleCrossing(c,d,a,b) == SimpleCrossing(a,b,c,d)\n     */\n    S2.simpleCrossing = function (a, b, c, d) {\n        // We compute SimpleCCW() for triangles ACB, CBD, BDA, and DAC. All\n        // of these triangles need to have the same orientation (CW or CCW)\n        // for an intersection to exist. Note that this is slightly more\n        // restrictive than the corresponding definition for planar edges,\n        // since we need to exclude pairs of line segments that would\n        // otherwise \"intersect\" by crossing two antipodal points.\n        var ab = S2Point_1.S2Point.crossProd(a, b);\n        var cd = S2Point_1.S2Point.crossProd(c, d);\n        var acb = ab.dotProd(c).neg();\n        var cbd = cd.dotProd(b).neg();\n        var bda = ab.dotProd(d);\n        var dac = cd.dotProd(a);\n        return (acb.times(cbd).gt(0)) && (cbd.times(bda).gt(0)) && (bda.times(dac).gt(0));\n    };\n    S2.M_PI = Math.PI;\n    S2.M_1_PI = 1.0 / Math.PI;\n    S2.M_PI_2 = Math.PI / 2.0;\n    S2.M_PI_4 = Math.PI / 4.0;\n    S2.M_SQRT2 = Math.sqrt(2);\n    S2.M_E = Math.E;\n    // the axis directions are reversed).\n    S2.SWAP_MASK = 0x01;\n    S2.INVERT_MASK = 0x02;\n    // Number of bits in the mantissa of a double.\n    S2.EXPONENT_SHIFT = 52;\n    // Mask to extract the exponent from a double.\n    S2.EXPONENT_MASK = Long.fromString('0x7ff0000000000000', true, 16);\n    /** Mapping from cell orientation + Hilbert traversal to IJ-index. */\n    S2.POS_TO_ORIENTATION = [S2.SWAP_MASK, 0, 0, S2.INVERT_MASK + S2.SWAP_MASK];\n    S2.POS_TO_IJ = [\n        // 0 1 2 3\n        [0, 1, 3, 2],\n        [0, 2, 3, 1],\n        [3, 2, 0, 1],\n        [3, 1, 0, 2],\n    ];\n    S2.MAX_LEVEL = 30;\n    S2.Metric = S2Metric_1.S2Metric;\n    return S2;\n}());\nexports.S2 = S2;\n//# sourceMappingURL=S2.js.map","/*\n * Copyright 2005 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar S2_1 = require(\"./S2\");\nvar S2Point_1 = require(\"./S2Point\");\nvar S1Angle_1 = require(\"./S1Angle\");\nvar S2LatLngRect_1 = require(\"./S2LatLngRect\");\nvar S2LatLng_1 = require(\"./S2LatLng\");\nvar R1Interval_1 = require(\"./R1Interval\");\nvar S1Interval_1 = require(\"./S1Interval\");\nvar Long = require('long');\nvar decimal_1 = require('./decimal');\n/**\n * This class represents a spherical cap, i.e. a portion of a sphere cut off by\n * a plane. The cap is defined by its axis and height. This representation has\n * good numerical accuracy for very small caps (unlike the (axis,\n * min-distance-from-origin) representation), and is also efficient for\n * containment tests (unlike the (axis, angle) representation).\n *\n * Here are some useful relationships between the cap height (h), the cap\n * opening angle (theta), the maximum chord length from the cap's center (d),\n * and the radius of cap's base (a). All formulas assume a unit radius.\n *\n * h = 1 - cos(theta) = 2 sin^2(theta/2) d^2 = 2 h = a^2 + h^2\n *\n */\nvar S2Cap = (function () {\n    /**\n     * Create a cap given its axis and the cap height, i.e. the maximum projected\n     * distance along the cap axis from the cap center. 'axis' should be a\n     * unit-length vector.\n     */\n    function S2Cap(axis, _height) {\n        this.axis = axis;\n        this.height = S2_1.S2.toDecimal(_height);\n        // assert (isValid());\n    }\n    /**\n     * Create a cap given its axis and the cap opening angle, i.e. maximum angle\n     * between the axis and a point on the cap. 'axis' should be a unit-length\n     * vector, and 'angle' should be between 0 and 180 degrees.\n     */\n    S2Cap.fromAxisAngle = function (axis, angle) {\n        // The height of the cap can be computed as 1-cos(angle), but this isn't\n        // very accurate for angles close to zero (where cos(angle) is almost 1).\n        // Computing it as 2*(sin(angle/2)**2) gives much better precision.\n        // assert (S2.isUnitLength(axis));\n        var d = angle.radians.times(0.5).sin();\n        // ecimal.sin(0.5 * angle.radians.times(0.5));\n        return new S2Cap(axis, d.pow(2).times(2));\n    };\n    /**\n     * Create a cap given its axis and its area in steradians. 'axis' should be a\n     * unit-length vector, and 'area' should be between 0 and 4 * M_PI.\n     */\n    S2Cap.fromAxisArea = function (axis, _area) {\n        var area = S2_1.S2.toDecimal(_area);\n        // assert (S2.isUnitLength(axis));\n        return new S2Cap(axis, area.dividedBy(S2_1.S2.toDecimal(2).times(S2_1.S2.M_PI)));\n    };\n    /** Return an empty cap, i.e. a cap that contains no points. */\n    S2Cap.empty = function () {\n        return new S2Cap(new S2Point_1.S2Point(1, 0, 0), -1);\n    };\n    /** Return a full cap, i.e. a cap that contains all points. */\n    S2Cap.full = function () {\n        return new S2Cap(new S2Point_1.S2Point(1, 0, 0), 2);\n    };\n    S2Cap.prototype.getCapBound = function () {\n        return this;\n    };\n    S2Cap.prototype.area = function () {\n        return decimal_1.Decimal.max(0, this.height)\n            .times(S2_1.S2.M_PI)\n            .times(2);\n        // return 2 * S2.M_PI * Math.max(0.0, this.height);\n    };\n    /**\n     * Return the cap opening angle in radians, or a negative number for empty\n     * caps.\n     */\n    S2Cap.prototype.angle = function () {\n        // This could also be computed as acos(1 - height_), but the following\n        // formula is much more accurate when the cap height is small. It\n        // follows from the relationship h = 1 - cos(theta) = 2 sin^2(theta/2).\n        if (this.isEmpty()) {\n            return new S1Angle_1.S1Angle(-1);\n        }\n        return new S1Angle_1.S1Angle(decimal_1.Decimal.asin(this.height.times(0.5).sqrt())\n            .times(2));\n    };\n    /**\n     * We allow negative heights (to represent empty caps) but not heights greater\n     * than 2.\n     */\n    S2Cap.prototype.isValid = function () {\n        return S2_1.S2.isUnitLength(this.axis) && this.height.lte(2);\n    };\n    /** Return true if the cap is empty, i.e. it contains no points. */\n    S2Cap.prototype.isEmpty = function () {\n        return this.height.lt(0);\n    };\n    /** Return true if the cap is full, i.e. it contains all points. */\n    S2Cap.prototype.isFull = function () {\n        return this.height.gte(2);\n    };\n    /**\n     * Return the complement of the interior of the cap. A cap and its complement\n     * have the same boundary but do not share any interior points. The complement\n     * operator is not a bijection, since the complement of a singleton cap\n     * (containing a single point) is the same as the complement of an empty cap.\n     */\n    S2Cap.prototype.complement = function () {\n        // The complement of a full cap is an empty cap, not a singleton.\n        // Also make sure that the complement of an empty cap has height 2.\n        var cHeight = this.isFull() ? -1 : decimal_1.Decimal.max(this.height, 0).neg().plus(2);\n        return new S2Cap(S2Point_1.S2Point.neg(this.axis), cHeight);\n    };\n    /**\n     * Return true if and only if this cap contains the given other cap (in a set\n     * containment sense, e.g. every cap contains the empty cap).\n     */\n    S2Cap.prototype.containsCap = function (other) {\n        if (this.isFull() || other.isEmpty()) {\n            return true;\n        }\n        return this.angle().radians.gte(this.axis.angle(other.axis).plus(other.angle().radians));\n    };\n    /**\n     * Return true if and only if the interior of this cap intersects the given\n     * other cap. (This relationship is not symmetric, since only the interior of\n     * this cap is used.)\n     */\n    S2Cap.prototype.interiorIntersects = function (other) {\n        // Interior(X) intersects Y if and only if Complement(Interior(X))\n        // does not contain Y.\n        return !this.complement().containsCap(other);\n    };\n    /**\n     * Return true if and only if the given point is contained in the interior of\n     * the region (i.e. the region excluding its boundary). 'p' should be a\n     * unit-length vector.\n     */\n    S2Cap.prototype.interiorContains = function (p) {\n        // assert (S2.isUnitLength(p));\n        return this.isFull() || S2Point_1.S2Point.sub(this.axis, p).norm2().lt(this.height.times(2));\n    };\n    /**\n     * Increase the cap height if necessary to include the given point. If the cap\n     * is empty the axis is set to the given point, but otherwise it is left\n     * unchanged. 'p' should be a unit-length vector.\n     */\n    S2Cap.prototype.addPoint = function (p) {\n        // Compute the squared chord length, then convert it into a height.\n        // assert (S2.isUnitLength(p));\n        if (this.isEmpty()) {\n            return new S2Cap(p, 0);\n        }\n        else {\n            // To make sure that the resulting cap actually includes this point,\n            // we need to round up the distance calculation. That is, after\n            // calling cap.AddPoint(p), cap.Contains(p) should be true.\n            var dist2 = S2Point_1.S2Point.sub(this.axis, p).norm2();\n            var newHeight = decimal_1.Decimal.max(this.height, S2Cap.ROUND_UP.times(0.5).times(dist2));\n            return new S2Cap(this.axis, newHeight);\n        }\n    };\n    // Increase the cap height if necessary to include \"other\". If the current\n    // cap is empty it is set to the given other cap.\n    S2Cap.prototype.addCap = function (other) {\n        if (this.isEmpty()) {\n            return new S2Cap(other.axis, other.height);\n        }\n        else {\n            // See comments for FromAxisAngle() and AddPoint(). This could be\n            // optimized by doing the calculation in terms of cap heights rather\n            // than cap opening angles.\n            var angle = this.axis.angle(other.axis).plus(other.angle().radians);\n            if (angle.gte(S2_1.S2.M_PI)) {\n                return new S2Cap(this.axis, 2); //Full cap\n            }\n            else {\n                var d = angle.times(0.5).sin();\n                var newHeight = decimal_1.Decimal.max(this.height, S2Cap.ROUND_UP.times(2).times(d.pow(2)));\n                return new S2Cap(this.axis, newHeight);\n            }\n        }\n    };\n    // //////////////////////////////////////////////////////////////////////\n    // S2Region interface (see {@code S2Region} for details):\n    S2Cap.prototype.getRectBound = function () {\n        if (this.isEmpty()) {\n            return S2LatLngRect_1.S2LatLngRect.empty();\n        }\n        // Convert the axis to a (lat,lng) pair, and compute the cap angle.\n        var axisLatLng = S2LatLng_1.S2LatLng.fromPoint(this.axis);\n        var capAngle = this.angle().radians;\n        var allLongitudes = false;\n        var lat = Array(2);\n        var lng = Array(2);\n        lng[0] = S2_1.S2.toDecimal(-S2_1.S2.M_PI);\n        lng[1] = S2_1.S2.toDecimal(S2_1.S2.M_PI);\n        // Check whether cap includes the south pole.\n        lat[0] = axisLatLng.latRadians.minus(capAngle);\n        if (lat[0].lte(-S2_1.S2.M_PI_2)) {\n            lat[0] = S2_1.S2.toDecimal(-S2_1.S2.M_PI_2);\n            allLongitudes = true;\n        }\n        // Check whether cap includes the north pole.\n        lat[1] = axisLatLng.latRadians.plus(capAngle);\n        if (lat[1].gte(S2_1.S2.M_PI_2)) {\n            lat[1] = S2_1.S2.toDecimal(S2_1.S2.M_PI_2);\n            allLongitudes = true;\n        }\n        if (!allLongitudes) {\n            // Compute the range of longitudes covered by the cap. We use the law\n            // of sines for spherical triangles. Consider the triangle ABC where\n            // A is the north pole, B is the center of the cap, and C is the point\n            // of tangency between the cap boundary and a line of longitude. Then\n            // C is a right angle, and letting a,b,c denote the sides opposite A,B,C,\n            // we have sin(a)/sin(A) = sin(c)/sin(C), or sin(A) = sin(a)/sin(c).\n            // Here \"a\" is the cap angle, and \"c\" is the colatitude (90 degrees\n            // minus the latitude). This formula also works for negative latitudes.\n            //\n            // The formula for sin(a) follows from the relationship h = 1 - cos(a).\n            // double sinA = Math.sqrt(this.height * (2 - this.height));\n            // double sinC = Math.cos(axisLatLng.lat().radians());\n            var sinA = this.height.times(this.height.neg().plus(2)).sqrt();\n            var sinC = axisLatLng.latRadians.cos();\n            if (sinA.lte(sinC)) {\n                var angleA = decimal_1.Decimal.asin(sinA.dividedBy(sinC));\n                lng[0] = S2_1.S2.IEEEremainder(axisLatLng.lngRadians.minus(angleA), 2 * S2_1.S2.M_PI);\n                lng[1] = S2_1.S2.IEEEremainder(axisLatLng.lngRadians.plus(angleA), 2 * S2_1.S2.M_PI);\n            }\n        }\n        return new S2LatLngRect_1.S2LatLngRect(new R1Interval_1.R1Interval(lat[0], lat[1]), new S1Interval_1.S1Interval(lng[0], lng[1]));\n    };\n    S2Cap.prototype.containsC = function (cell) {\n        // If the cap does not contain all cell vertices, return false.\n        // We check the vertices before taking the Complement() because we can't\n        // accurately represent the complement of a very small cap (a height\n        // of 2-epsilon is rounded off to 2).\n        var vertices = new Array(4);\n        for (var k = 0; k < 4; ++k) {\n            vertices[k] = cell.getVertex(k);\n            if (!this.contains(vertices[k])) {\n                return false;\n            }\n        }\n        // Otherwise, return true if the complement of the cap does not intersect\n        // the cell. (This test is slightly conservative, because technically we\n        // want Complement().InteriorIntersects() here.)\n        return !this.complement().intersects(cell, vertices);\n    };\n    // public mayIntersectC(cell:S2Cell):boolean {\n    //   const toRet = this._mayIntersectC(cell);\n    //   console.log(\"intersects? \",toRet, cell.id.pos().toString(16), cell.level);\n    //   return toRet;\n    // }\n    S2Cap.prototype.mayIntersectC = function (cell) {\n        // If the cap contains any cell vertex, return true.\n        var vertices = new Array(4);\n        for (var k = 0; k < 4; ++k) {\n            vertices[k] = cell.getVertex(k);\n            if (this.contains(vertices[k])) {\n                return true;\n            }\n        }\n        return this.intersects(cell, vertices);\n    };\n    /**\n     * Return true if the cap intersects 'cell', given that the cap vertices have\n     * alrady been checked.\n     */\n    S2Cap.prototype.intersects = function (cell, vertices) {\n        // Return true if this cap intersects any point of 'cell' excluding its\n        // vertices (which are assumed to already have been checked).\n        // If the cap is a hemisphere or larger, the cell and the complement of the\n        // cap are both convex. Therefore since no vertex of the cell is contained,\n        // no other interior point of the cell is contained either.\n        if (this.height.gte(1)) {\n            return false;\n        }\n        // We need to check for empty caps due to the axis check just below.\n        if (this.isEmpty()) {\n            return false;\n        }\n        // Optimization: return true if the cell contains the cap axis. (This\n        // allows half of the edge checks below to be skipped.)\n        if (cell.contains(this.axis)) {\n            return true;\n        }\n        // At this point we know that the cell does not contain the cap axis,\n        // and the cap does not contain any cell vertex. The only way that they\n        // can intersect is if the cap intersects the interior of some edge.\n        var sin2Angle = this.height.times(this.height.neg().plus(2)); // sin^2(capAngle)\n        // if (cell.id.pos().toString(16) === '77c040000000000') {\n        //   console.log(\"DIOCAN\");\n        // }\n        for (var k = 0; k < 4; ++k) {\n            var edge = cell.getEdgeRaw(k);\n            var dot = this.axis.dotProd(edge);\n            if (dot.gt(0)) {\n                // The axis is in the interior half-space defined by the edge. We don't\n                // need to consider these edges, since if the cap intersects this edge\n                // then it also intersects the edge on the opposite side of the cell\n                // (because we know the axis is not contained with the cell).\n                continue;\n            }\n            // The Norm2() factor is necessary because \"edge\" is not normalized.\n            if (dot.pow(2).gt(sin2Angle.times(edge.norm2()))) {\n                // if (cell.id.pos().toString(16) === '77c040000000000') {\n                //   console.log(\"DIOCaAN\", k, dot.toString(), sin2Angle.toString(), sin2Angle.times(edge.norm2()).toString());\n                // }\n                return false; // Entire cap is on the exterior side of this edge.\n            }\n            // Otherwise, the great circle containing this edge intersects\n            // the interior of the cap. We just need to check whether the point\n            // of closest approach occurs between the two edge endpoints.\n            var dir = S2Point_1.S2Point.crossProd(edge, this.axis);\n            if (dir.dotProd(vertices[k]).lt(0)\n                && dir.dotProd(vertices[(k + 1) & 3]).gt(0)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    S2Cap.prototype.contains = function (p) {\n        // The point 'p' should be a unit-length vector.\n        // assert (S2.isUnitLength(p));\n        return S2Point_1.S2Point.sub(this.axis, p).norm2().lte(this.height.times(2));\n    };\n    //\n    // /** Return true if two caps are identical. */\n    // public equals(that:Object ):boolean  {\n    //\n    //   if (!(that instanceof S2Cap)) {\n    //     return false;\n    //   }\n    //\n    //   S2Cap other = (S2Cap) that;\n    //   return (this.axis.equals(other.axis) && this.height == other.height)\n    //       || (isEmpty() && other.isEmpty()) || (isFull() && other.isFull());\n    //\n    // }\n    //\n    // @Override\n    // public int hashCode() {\n    //   if (isFull()) {\n    //     return 17;\n    //   } else if (isEmpty()) {\n    //     return 37;\n    //   }\n    //   int result = 17;\n    //   result = 37 * result + this.axis.hashCode();\n    //   long heightBits = Double.doubleToLongBits(this.height);\n    //   result = 37 * result + (int) ((heightBits >>> 32) ^ heightBits);\n    //   return result;\n    // }\n    // /////////////////////////////////////////////////////////////////////\n    // The following static methods are convenience functions for assertions\n    // and testing purposes only.\n    /**\n     * Return true if the cap axis and height differ by at most \"max_error\" from\n     * the given cap \"other\".\n     */\n    S2Cap.prototype.approxEquals = function (other, maxError) {\n        if (maxError === void 0) { maxError = 1e-14; }\n        return (this.axis.aequal(other.axis, maxError) && this.height.minus(other.height).lte(maxError))\n            || (this.isEmpty() && other.height.lte(maxError))\n            || (other.isEmpty() && this.height.lte(maxError))\n            || (this.isFull() && other.height.gte(2 - maxError))\n            || (other.isFull() && this.height.gte(2 - maxError));\n    };\n    S2Cap.prototype.toString = function () {\n        return \"[Point = \" + this.axis.toString() + \" Height = \" + this.height.toString() + \"]\";\n    };\n    S2Cap.prototype.toGEOJSON = function () {\n        return this.getRectBound().toGEOJSON();\n    };\n    /**\n     * Multiply a positive number by this constant to ensure that the result of a\n     * floating point operation is at least as large as the true\n     * infinite-precision result.\n     */\n    S2Cap.ROUND_UP = S2_1.S2.toDecimal(1).dividedBy(new Long(1).shiftLeft(52).toString()).plus(1);\n    return S2Cap;\n}());\nexports.S2Cap = S2Cap;\n//# sourceMappingURL=S2Cap.js.map","\"use strict\";\nvar Long = require('long');\nvar decimal_1 = require('./decimal');\nvar S2CellId_1 = require(\"./S2CellId\");\nvar S2Point_1 = require(\"./S2Point\");\nvar S2LatLng_1 = require(\"./S2LatLng\");\nvar S2Projections_1 = require(\"./S2Projections\");\nvar R2Vector_1 = require(\"./R2Vector\");\nvar MutableInteger_1 = require(\"./MutableInteger\");\nvar S2_1 = require(\"./S2\");\nvar S2LatLngRect_1 = require(\"./S2LatLngRect\");\nvar R1Interval_1 = require(\"./R1Interval\");\nvar S1Interval_1 = require(\"./S1Interval\");\nvar S2Cap_1 = require(\"./S2Cap\");\nvar S2Cell = (function () {\n    function S2Cell(cellID) {\n        this.cellID = cellID;\n        this._uv = [];\n        this._uv.push([]);\n        this._uv.push([]);\n        this.init(cellID);\n    }\n    Object.defineProperty(S2Cell.prototype, \"id\", {\n        get: function () {\n            return this.cellID;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(S2Cell.prototype, \"face\", {\n        get: function () {\n            return this._face;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(S2Cell.prototype, \"level\", {\n        get: function () {\n            return this._level;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(S2Cell.prototype, \"orientation\", {\n        get: function () {\n            return this._orientation;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // This is a static method in order to provide named parameters.\n    S2Cell.fromFacePosLevel = function (face, pos, level) {\n        return new S2Cell(S2CellId_1.S2CellId.fromFacePosLevel(face, new Long(pos), level));\n    };\n    // Convenience methods.\n    S2Cell.fromPoint = function (p) {\n        return new S2Cell(S2CellId_1.S2CellId.fromPoint(p));\n    };\n    S2Cell.fromLatLng = function (ll) {\n        return new S2Cell(S2CellId_1.S2CellId.fromPoint(ll.toPoint()));\n    };\n    S2Cell.prototype.isLeaf = function () {\n        return this.level == S2CellId_1.S2CellId.MAX_LEVEL;\n    };\n    S2Cell.prototype.getVertex = function (k) {\n        return S2Point_1.S2Point.normalize(this.getVertexRaw(k));\n    };\n    /**\n     * Return the k-th vertex of the cell (k = 0,1,2,3). Vertices are returned in\n     * CCW order. The points returned by GetVertexRaw are not necessarily unit\n     * length.\n     */\n    S2Cell.prototype.getVertexRaw = function (k) {\n        // Vertices are returned in the order SW, SE, NE, NW.\n        return new R2Vector_1.R2Vector(this._uv[0][(k >> 1) ^ (k & 1)], this._uv[1][k >> 1])\n            .toPoint(this.face);\n        // return S2Projections.faceUvToXyz(this.face, );\n    };\n    S2Cell.prototype.getEdge = function (k) {\n        return S2Point_1.S2Point.normalize(this.getEdgeRaw(k));\n    };\n    S2Cell.prototype.getEdgeRaw = function (k) {\n        switch (k) {\n            case 0:\n                return S2Projections_1.S2Projections.getVNorm(this.face, this._uv[1][0]); // South\n            case 1:\n                return S2Projections_1.S2Projections.getUNorm(this.face, this._uv[0][1]); // East\n            case 2:\n                return S2Point_1.S2Point.neg(S2Projections_1.S2Projections.getVNorm(this.face, this._uv[1][1])); // North\n            default:\n                return S2Point_1.S2Point.neg(S2Projections_1.S2Projections.getUNorm(this.face, this._uv[0][0])); // West\n        }\n    };\n    /**\n     * Return the inward-facing normal of the great circle passing through the\n     * edge from vertex k to vertex k+1 (mod 4). The normals returned by\n     * GetEdgeRaw are not necessarily unit length.\n     *\n     *  If this is not a leaf cell, set children[0..3] to the four children of\n     * this cell (in traversal order) and return true. Otherwise returns false.\n     * This method is equivalent to the following:\n     *\n     *  for (pos=0, id=child_begin(); id != child_end(); id = id.next(), ++pos)\n     * children[i] = S2Cell(id);\n     *\n     * except that it is more than two times faster.\n     */\n    S2Cell.prototype.subdivide = function () {\n        // This function is equivalent to just iterating over the child cell ids\n        // and calling the S2Cell constructor, but it is about 2.5 times faster.\n        if (this.isLeaf()) {\n            return null;\n        }\n        // Compute the cell midpoint in uv-space.\n        // const uvMid = this.getCenterUV();\n        var children = new Array(4);\n        // Create four children with the appropriate bounds.\n        var id = this.cellID.childBegin();\n        for (var pos = 0; pos < 4; ++pos, id = id.next()) {\n            children[pos] = new S2Cell(id);\n        }\n        return children;\n    };\n    /**\n     * Return the direction vector corresponding to the center in (s,t)-space of\n     * the given cell. This is the point at which the cell is divided into four\n     * subcells; it is not necessarily the centroid of the cell in (u,v)-space or\n     * (x,y,z)-space. The point returned by GetCenterRaw is not necessarily unit\n     * length.\n     */\n    S2Cell.prototype.getCenter = function () {\n        return S2Point_1.S2Point.normalize(this.getCenterRaw());\n    };\n    S2Cell.prototype.getCenterRaw = function () {\n        return this.cellID.toPointRaw();\n    };\n    /**\n     * Return the center of the cell in (u,v) coordinates (see {@code\n     * S2Projections}). Note that the center of the cell is defined as the point\n     * at which it is recursively subdivided into four children; in general, it is\n     * not at the midpoint of the (u,v) rectangle covered by the cell\n     */\n    S2Cell.prototype.getCenterUV = function () {\n        var i = new MutableInteger_1.MutableInteger(0);\n        var j = new MutableInteger_1.MutableInteger(0);\n        this.cellID.toFaceIJOrientation(i, j, null);\n        var cellSize = 1 << (S2CellId_1.S2CellId.MAX_LEVEL - this.level);\n        // TODO(dbeaumont): Figure out a better naming of the variables here (and elsewhere).\n        var si = (i.val & -cellSize) * 2 + cellSize - S2Cell.MAX_CELL_SIZE;\n        var x = R2Vector_1.R2Vector.singleStTOUV(S2_1.S2.toDecimal(1).dividedBy(S2Cell.MAX_CELL_SIZE).times(si));\n        // let x = S2Projections.stToUV((1.0 / S2Cell.MAX_CELL_SIZE) * si);\n        var sj = (j.val & -cellSize) * 2 + cellSize - S2Cell.MAX_CELL_SIZE;\n        var y = R2Vector_1.R2Vector.singleStTOUV(S2_1.S2.toDecimal(1).dividedBy(S2Cell.MAX_CELL_SIZE).times(sj));\n        // double y = S2Projections.stToUV((1.0 / S2Cell.MAX_CELL_SIZE) * sj);\n        return new R2Vector_1.R2Vector(x, y);\n    };\n    /**\n     * Return the average area of cells at this level. This is accurate to within\n     * a factor of 1.7 (for S2_QUADRATIC_PROJECTION) and is extremely cheap to\n     * compute.\n     */\n    S2Cell.averageArea = function (level) {\n        return S2Projections_1.S2Projections.AVG_AREA.getValue(level);\n    };\n    /**\n     * Return the average area of cells at this level. This is accurate to within\n     * a factor of 1.7 (for S2_QUADRATIC_PROJECTION) and is extremely cheap to\n     * compute.\n     */\n    S2Cell.prototype.averageArea = function () {\n        return S2Projections_1.S2Projections.AVG_AREA.getValue(this.level);\n    };\n    /**\n     * Return the approximate area of this cell. This method is accurate to within\n     * 3% percent for all cell sizes and accurate to within 0.1% for cells at\n     * level 5 or higher (i.e. 300km square or smaller). It is moderately cheap to\n     * compute.\n     */\n    S2Cell.prototype.approxArea = function () {\n        // All cells at the first two levels have the same area.\n        if (this.level < 2) {\n            return this.averageArea();\n        }\n        // First, compute the approximate area of the cell when projected\n        // perpendicular to its normal. The cross product of its diagonals gives\n        // the normal, and the length of the normal is twice the projected area.\n        var flatArea = S2Point_1.S2Point.crossProd(S2Point_1.S2Point.sub(this.getVertex(2), this.getVertex(0)), S2Point_1.S2Point.sub(this.getVertex(3), this.getVertex(1))).norm().times(0.5);\n        // double flatArea = 0.5 * S2Point.crossProd(\n        //         S2Point.sub(getVertex(2), getVertex(0)), S2Point.sub(getVertex(3), getVertex(1))).norm();\n        // Now, compensate for the curvature of the cell surface by pretending\n        // that the cell is shaped like a spherical cap. The ratio of the\n        // area of a spherical cap to the area of its projected disc turns out\n        // to be 2 / (1 + sqrt(1 - r*r)) where \"r\" is the radius of the disc.\n        // For example, when r=0 the ratio is 1, and when r=1 the ratio is 2.\n        // Here we set Pi*r*r == flat_area to find the equivalent disc.\n        return flatArea\n            .times(2)\n            .dividedBy(decimal_1.Decimal.min(flatArea.times(S2_1.S2.M_1_PI), 1)\n            .neg()\n            .plus(1)\n            .sqrt()\n            .plus(1)).toNumber();\n    };\n    //\n    // /**\n    //  * Return the area of this cell as accurately as possible. This method is more\n    //  * expensive but it is accurate to 6 digits of precision even for leaf cells\n    //  * (whose area is approximately 1e-18).\n    //  */\n    S2Cell.prototype.exactArea = function () {\n        var v0 = this.getVertex(0);\n        var v1 = this.getVertex(1);\n        var v2 = this.getVertex(2);\n        var v3 = this.getVertex(3);\n        return S2_1.S2.area(v0, v1, v2).plus(S2_1.S2.area(v0, v2, v3));\n    };\n    // //////////////////////////////////////////////////////////////////////\n    // S2Region interface (see {@code S2Region} for details):\n    S2Cell.prototype.getCapBound = function () {\n        // Use the cell center in (u,v)-space as the cap axis. This vector is\n        // very close to GetCenter() and faster to compute. Neither one of these\n        // vectors yields the bounding cap with minimal surface area, but they\n        // are both pretty close.\n        //\n        // It's possible to show that the two vertices that are furthest from\n        // the (u,v)-origin never determine the maximum cap size (this is a\n        // possible future optimization).\n        var u = this._uv[0][0].plus(this._uv[0][1]).times(0.5);\n        var v = this._uv[1][0].plus(this._uv[1][1]).times(0.5);\n        var cap = new S2Cap_1.S2Cap(S2Point_1.S2Point.normalize(S2Projections_1.S2Projections.faceUvToXyz(this.face, u, v)), 0);\n        for (var k = 0; k < 4; ++k) {\n            cap = cap.addPoint(this.getVertex(k));\n        }\n        return cap;\n    };\n    // 35.26 degrees\n    S2Cell.prototype.getRectBound = function () {\n        if (this.level > 0) {\n            // Except for cells at level 0, the latitude and longitude extremes are\n            // attained at the vertices. Furthermore, the latitude range is\n            // determined by one pair of diagonally opposite vertices and the\n            // longitude range is determined by the other pair.\n            //\n            // We first determine which corner (i,j) of the cell has the largest\n            // absolute latitude. To maximize latitude, we want to find the point in\n            // the cell that has the largest absolute z-coordinate and the smallest\n            // absolute x- and y-coordinates. To do this we look at each coordinate\n            // (u and v), and determine whether we want to minimize or maximize that\n            // coordinate based on the axis direction and the cell's (u,v) quadrant.\n            var u = this._uv[0][0].plus(this._uv[0][1]);\n            var v = this._uv[1][0].plus(this._uv[1][1]);\n            var i = S2Projections_1.S2Projections.getUAxis(this.face).z.eq(0) ? (u.lt(0) ? 1 : 0) : (u.gt(0) ? 1 : 0);\n            var j = S2Projections_1.S2Projections.getVAxis(this.face).z.eq(0) ? (v.lt(0) ? 1 : 0) : (v.gt(0) ? 1 : 0);\n            var lat = R1Interval_1.R1Interval.fromPointPair(this.getLatitude(i, j), this.getLatitude(1 - i, 1 - j));\n            lat = lat.expanded(S2Cell.MAX_ERROR).intersection(S2LatLngRect_1.S2LatLngRect.fullLat());\n            if (lat.lo.eq(-S2_1.S2.M_PI_2) || lat.hi.eq(S2_1.S2.M_PI_2)) {\n                return new S2LatLngRect_1.S2LatLngRect(lat, S1Interval_1.S1Interval.full());\n            }\n            var lng = S1Interval_1.S1Interval.fromPointPair(this.getLongitude(i, 1 - j), this.getLongitude(1 - i, j));\n            return new S2LatLngRect_1.S2LatLngRect(lat, lng.expanded(S2Cell.MAX_ERROR));\n        }\n        // The face centers are the +X, +Y, +Z, -X, -Y, -Z axes in that order.\n        // assert (S2Projections.getNorm(face).get(face % 3) == ((face < 3) ? 1 : -1));\n        switch (this.face) {\n            case 0:\n                return new S2LatLngRect_1.S2LatLngRect(new R1Interval_1.R1Interval(-S2_1.S2.M_PI_4, S2_1.S2.M_PI_4), new S1Interval_1.S1Interval(-S2_1.S2.M_PI_4, S2_1.S2.M_PI_4));\n            case 1:\n                return new S2LatLngRect_1.S2LatLngRect(new R1Interval_1.R1Interval(-S2_1.S2.M_PI_4, S2_1.S2.M_PI_4), new S1Interval_1.S1Interval(S2_1.S2.M_PI_4, 3 * S2_1.S2.M_PI_4));\n            case 2:\n                return new S2LatLngRect_1.S2LatLngRect(new R1Interval_1.R1Interval(S2Cell.POLE_MIN_LAT, S2_1.S2.M_PI_2), new S1Interval_1.S1Interval(-S2_1.S2.M_PI, S2_1.S2.M_PI));\n            case 3:\n                return new S2LatLngRect_1.S2LatLngRect(new R1Interval_1.R1Interval(-S2_1.S2.M_PI_4, S2_1.S2.M_PI_4), new S1Interval_1.S1Interval(3 * S2_1.S2.M_PI_4, -3 * S2_1.S2.M_PI_4));\n            case 4:\n                return new S2LatLngRect_1.S2LatLngRect(new R1Interval_1.R1Interval(-S2_1.S2.M_PI_4, S2_1.S2.M_PI_4), new S1Interval_1.S1Interval(-3 * S2_1.S2.M_PI_4, -S2_1.S2.M_PI_4));\n            default:\n                return new S2LatLngRect_1.S2LatLngRect(new R1Interval_1.R1Interval(-S2_1.S2.M_PI_2, -S2Cell.POLE_MIN_LAT), new S1Interval_1.S1Interval(-S2_1.S2.M_PI, S2_1.S2.M_PI));\n        }\n    };\n    S2Cell.prototype.mayIntersect = function (cell) {\n        return this.cellID.intersects(cell.cellID);\n    };\n    S2Cell.prototype.contains = function (p) {\n        // We can't just call XYZtoFaceUV, because for points that lie on the\n        // boundary between two faces (i.e. u or v is +1/-1) we need to return\n        // true for both adjacent cells.\n        var uvPoint = p.toR2Vector(this.face);\n        // S2Projections.faceXyzToUv(this.face, p);\n        if (uvPoint == null) {\n            return false;\n        }\n        return (uvPoint.x.gte(this._uv[0][0]) && uvPoint.x.lte(this._uv[0][1])\n            && uvPoint.y.gte(this._uv[1][0]) && uvPoint.y.lte(this._uv[1][1]));\n    };\n    // The point 'p' does not need to be normalized.\n    S2Cell.prototype.containsC = function (cell) {\n        return this.cellID.contains(cell.cellID);\n    };\n    S2Cell.prototype.init = function (id) {\n        this.cellID = id;\n        var ij = [];\n        var mOrientation = new MutableInteger_1.MutableInteger(0);\n        for (var d = 0; d < 2; ++d) {\n            ij[d] = new MutableInteger_1.MutableInteger(0);\n        }\n        this._face = id.toFaceIJOrientation(ij[0], ij[1], mOrientation);\n        this._orientation = mOrientation.val; // Compress int to a byte.\n        this._level = id.level();\n        var cellSize = 1 << (S2CellId_1.S2CellId.MAX_LEVEL - this.level);\n        for (var d = 0; d < 2; ++d) {\n            // Compute the cell bounds in scaled (i,j) coordinates.\n            var sijLo = (ij[d].val & -cellSize) * 2 - S2Cell.MAX_CELL_SIZE;\n            var sijHi = sijLo + cellSize * 2;\n            var s = S2_1.S2.toDecimal(1).dividedBy(S2Cell.MAX_CELL_SIZE);\n            this._uv[d][0] = R2Vector_1.R2Vector.singleStTOUV(s.times(sijLo));\n            //S2Projections.stToUV((1.0 / S2Cell.MAX_CELL_SIZE) * sijLo);\n            this._uv[d][1] = R2Vector_1.R2Vector.singleStTOUV(s.times(sijHi));\n        }\n    };\n    // Internal method that does the actual work in the constructors.\n    S2Cell.prototype.getLatitude = function (i, j) {\n        var p = S2Projections_1.S2Projections.faceUvToXyz(this.face, this._uv[0][i], this._uv[1][j]);\n        return decimal_1.Decimal.atan2(p.z, p.x.pow(2).plus(p.y.pow(2))\n            .sqrt());\n        // return Math.atan2(p.z, Math.sqrt(p.x * p.x + p.y * p.y));\n    };\n    S2Cell.prototype.getLongitude = function (i, j) {\n        var p = S2Projections_1.S2Projections.faceUvToXyz(this.face, this._uv[0][i], this._uv[1][j]);\n        return decimal_1.Decimal.atan2(p.y, p.x);\n        // Math.atan2(p.y, p.x);\n    };\n    // Return the latitude or longitude of the cell vertex given by (i,j),\n    // where \"i\" and \"j\" are either 0 or 1.\n    S2Cell.prototype.toString = function () {\n        return \"[\" + this._face + \", \" + this._level + \", \" + this._orientation + \", \" + this.cellID.toToken() + \"]\";\n    };\n    S2Cell.prototype.toGEOJSON = function () {\n        var coords = [this.getVertex(0), this.getVertex(1), this.getVertex(2), this.getVertex(3), this.getVertex(0)]\n            .map(function (v) { return S2LatLng_1.S2LatLng.fromPoint(v); })\n            .map(function (v) { return ([v.lngDegrees.toNumber(), v.latDegrees.toNumber()]); });\n        // const rectJSON = this.getRectBound().toGEOJSON();\n        return {\n            type: 'Feature',\n            geometry: {\n                type: 'Polygon',\n                coordinates: [coords]\n            },\n            properties: {},\n            title: \"Cell: \" + this.id.toToken() + \" lvl: \" + this.level\n        };\n        // rectJSON.title = `Cell: ${this.id.toToken()}`;\n        // return rectJSON;\n    };\n    S2Cell.MAX_CELL_SIZE = 1 << S2CellId_1.S2CellId.MAX_LEVEL;\n    // We grow the bounds slightly to make sure that the bounding rectangle\n    // also contains the normalized versions of the vertices. Note that the\n    // maximum result magnitude is Pi, with a floating-point exponent of 1.\n    // Therefore adding or subtracting 2**-51 will always change the result.\n    S2Cell.MAX_ERROR = S2_1.S2.toDecimal(1.0).dividedBy(S2_1.S2.toDecimal(new Long(1).shiftLeft(51).toString()));\n    // The 4 cells around the equator extend to +/-45 degrees latitude at the\n    // midpoints of their top and bottom edges. The two cells covering the\n    // poles extend down to +/-35.26 degrees at their vertices.\n    // adding kMaxError (as opposed to the C version) because of asin and atan2\n    // roundoff errors\n    S2Cell.POLE_MIN_LAT = decimal_1.Decimal.asin(S2_1.S2.toDecimal(1.0).dividedBy(3).sqrt()).minus(S2Cell.MAX_ERROR);\n    return S2Cell;\n}());\nexports.S2Cell = S2Cell;\n//# sourceMappingURL=S2Cell.js.map","/*\n * Copyright 2005 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\n//const Long = require(\"long\");\nvar Long = require('long');\nvar S2Point_1 = require(\"./S2Point\");\nvar R2Vector_1 = require(\"./R2Vector\");\nvar S2_1 = require(\"./S2\");\nvar MutableInteger_1 = require(\"./MutableInteger\");\nvar S2LatLng_1 = require(\"./S2LatLng\");\nvar decimal_1 = require('./decimal');\nvar parseHex = function parseHex(str) {\n    return Long.fromString(str, false, 16);\n};\n/**\n * An S2CellId is a 64-bit unsigned integer that uniquely identifies a cell in\n * the S2 cell decomposition. It has the following format:\n *\n * <pre>\n * id = [face][face_pos]\n * </pre>\n *\n * face: a 3-bit number (range 0..5) encoding the cube face.\n *\n * face_pos: a 61-bit number encoding the position of the center of this cell\n * along the Hilbert curve over this face (see the Wiki pages for details).\n *\n * Sequentially increasing cell ids follow a continuous space-filling curve over\n * the entire sphere. They have the following properties:\n *  - The id of a cell at level k consists of a 3-bit face number followed by k\n * bit pairs that recursively select one of the four children of each cell. The\n * next bit is always 1, and all other bits are 0. Therefore, the level of a\n * cell is determined by the position of its lowest-numbered bit that is turned\n * on (for a cell at level k, this position is 2 * (MAX_LEVEL - k).)\n *  - The id of a parent cell is at the midpoint of the range of ids spanned by\n * its children (or by its descendants at any level).\n *\n * Leaf cells are often used to represent points on the unit sphere, and this\n * class provides methods for converting directly between these two\n * representations. For cells that represent 2D regions rather than discrete\n * point, it is better to use the S2Cell class.\n *\n *\n */\nvar S2CellId = (function () {\n    function S2CellId(id) {\n        if (typeof (id) === 'string') {\n            this.id = Long.fromString(id);\n        }\n        else {\n            this.id = id;\n        }\n    }\n    Object.defineProperty(S2CellId.prototype, \"face\", {\n        /** Which cube face this cell belongs to, in the range 0..5. */\n        get: function () {\n            return this.id.shiftRightUnsigned(S2CellId.POS_BITS).toInt();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Return the lowest-numbered bit that is on for cells at the given level. */\n    S2CellId.prototype.lowestOnBit = function () {\n        return this.id.and(this.id.negate());\n    };\n    /** The default constructor returns an invalid cell id. */\n    S2CellId.none = function () {\n        return new S2CellId(new Long(0));\n    };\n    /**\n     * Returns an invalid cell id guaranteed to be larger than any valid cell id.\n     * Useful for creating indexes.\n     */\n    S2CellId.sentinel = function () {\n        return new S2CellId(S2CellId.MAX_UNSIGNED); // -1\n    };\n    S2CellId.prototype.getBits1 = function (i, j, k, bits) {\n        var nbits = (k == 7) ? (S2CellId.MAX_LEVEL - 7 * S2CellId.LOOKUP_BITS) : S2CellId.LOOKUP_BITS;\n        bits += (this.id\n            .shiftRightUnsigned((k * 2 * S2CellId.LOOKUP_BITS + 1))\n            .getLowBitsUnsigned()\n            & ((1 << (2 * nbits)) - 1)) << 2;\n        /*\n         * System.out.println(\"id is: \" + id_); System.out.println(\"bits is \" +\n         * bits); System.out.println(\"lookup_ij[bits] is \" + lookup_ij[bits]);\n         */\n        bits = S2CellId.LOOKUP_IJ[bits];\n        i.val = i.val + ((bits >> (S2CellId.LOOKUP_BITS + 2)) << (k * S2CellId.LOOKUP_BITS));\n        // i.setValue(i.intValue() + ((bits >> (LOOKUP_BITS + 2)) << (k * LOOKUP_BITS)));\n        /*\n         * System.out.println(\"left is \" + ((bits >> 2) & ((1 << kLookupBits) -\n         * 1))); System.out.println(\"right is \" + (k * kLookupBits));\n         * System.out.println(\"j is: \" + j.intValue()); System.out.println(\"addition\n         * is: \" + ((((bits >> 2) & ((1 << kLookupBits) - 1))) << (k *\n         * kLookupBits)));\n         */\n        j.val = j.val + ((((bits >> 2) & ((1 << S2CellId.LOOKUP_BITS) - 1))) << (k * S2CellId.LOOKUP_BITS));\n        bits &= (S2_1.S2.SWAP_MASK | S2_1.S2.INVERT_MASK);\n        return bits;\n    };\n    /**\n     * Convert (face, si, ti) coordinates (see s2.h) to a direction vector (not\n     * necessarily unit length).\n     */\n    S2CellId.prototype.faceSiTiToXYZ = function (face, si, ti) {\n        // console.log('faceSiTiToXYZ', si, ti);\n        var kScale = S2_1.S2.toDecimal(1).dividedBy(S2CellId.MAX_SIZE);\n        var uvVector = R2Vector_1.R2Vector.fromSTVector(new R2Vector_1.R2Vector(kScale.times(si), kScale.times(ti)));\n        // console.log(uvVector.toString(), uvVector.x.toString());\n        return uvVector.toPoint(face);\n    };\n    S2CellId.lowestOnBitForLevel = function (level) {\n        return new Long(1).shiftLeft(2 * (S2CellId.MAX_LEVEL - level));\n    };\n    /**\n     * Return the (face, i, j) coordinates for the leaf cell corresponding to this\n     * cell id. Since cells are represented by the Hilbert curve position at the\n     * center of the cell, the returned (i,j) for non-leaf cells will be a leaf\n     * cell adjacent to the cell center. If \"orientation\" is non-NULL, also return\n     * the Hilbert curve orientation for the current cell.\n     */\n    S2CellId.prototype.toFaceIJOrientation = function (pi, pj, orientation) {\n        // System.out.println(\"Entering toFaceIjorientation\");\n        var face = this.face;\n        var bits = (face & S2_1.S2.SWAP_MASK);\n        // System.out.println(\"face = \" + face + \" bits = \" + bits);\n        // Each iteration maps 8 bits of the Hilbert curve position into\n        // 4 bits of \"i\" and \"j\". The lookup table transforms a key of the\n        // form \"ppppppppoo\" to a value of the form \"iiiijjjjoo\", where the\n        // letters [ijpo] represents bits of \"i\", \"j\", the Hilbert curve\n        // position, and the Hilbert curve orientation respectively.\n        //\n        // On the first iteration we need to be careful to clear out the bits\n        // representing the cube face.\n        for (var k = 7; k >= 0; --k) {\n            bits = this.getBits1(pi, pj, k, bits);\n        }\n        if (orientation != null) {\n            // The position of a non-leaf cell at level \"n\" consists of a prefix of\n            // 2*n bits that identifies the cell, followed by a suffix of\n            // 2*(MAX_LEVEL-n)+1 bits of the form 10*. If n==MAX_LEVEL, the suffix is\n            // just \"1\" and has no effect. Otherwise, it consists of \"10\", followed\n            // by (MAX_LEVEL-n-1) repetitions of \"00\", followed by \"0\". The \"10\" has\n            // no effect, while each occurrence of \"00\" has the effect of reversing\n            // the kSwapMask bit.\n            // assert (S2.POS_TO_ORIENTATION[2] == 0);\n            // assert (S2.POS_TO_ORIENTATION[0] == S2.SWAP_MASK);\n            if ((Long.fromString('0x1111111111111110', true, 16).and(this.lowestOnBit()).notEquals(0))) {\n                bits ^= S2_1.S2.SWAP_MASK;\n            }\n            orientation.val = bits;\n        }\n        return face;\n    };\n    /**\n     * Return true if this is a leaf cell (more efficient than checking whether\n     * level() == MAX_LEVEL).\n     */\n    S2CellId.prototype.isLeaf = function () {\n        return this.id.and(1).getLowBits() != 0;\n    };\n    /**\n     * Return the cell at the previous level or at the given level (which must be\n     * less than or equal to the current level).\n     */\n    S2CellId.prototype.parentL = function (level) {\n        // assert (isValid() && level >= 0 && level <= this.level());\n        var newLsb = S2CellId.lowestOnBitForLevel(level);\n        return new S2CellId(this.id.and(newLsb.negate()).or(newLsb));\n        // return new S2CellId((id & -newLsb) | newLsb);\n    };\n    S2CellId.prototype.parent = function () {\n        // assert (isValid() && level() > 0);\n        var newLsb = this.lowestOnBit().shiftLeft(2);\n        // return new S2CellId((id & -newLsb) | newLsb);\n        return new S2CellId(this.id.and(newLsb.negate()).or(newLsb));\n    };\n    /**\n     * Return a cell given its face (range 0..5), 61-bit Hilbert curve position\n     * within that face, and level (range 0..MAX_LEVEL). The given position will\n     * be modified to correspond to the Hilbert curve position at the center of\n     * the returned cell. This is a static function rather than a constructor in\n     * order to give names to the arguments.\n     */\n    S2CellId.fromFacePosLevel = function (face, pos, level) {\n        // equivalent to pos | 1\n        return new S2CellId(new Long(face)\n            .shiftLeft(S2CellId.POS_BITS)\n            .add(pos.or(1))).parentL(level);\n        // return new S2CellId((((long) face) << POS_BITS) + (pos | 1)).parent(level);\n    };\n    // /**\n    //  * Return the leaf cell containing the given point (a direction vector, not\n    //  * necessarily unit length).\n    //  */\n    S2CellId.fromPoint = function (p) {\n        var face = p.toFace();\n        var uv = p.toR2Vector(face);\n        var i = S2CellId.stToIJ(uv.toSt(0));\n        var j = S2CellId.stToIJ(uv.toSt(1));\n        return S2CellId.fromFaceIJ(face, i, j);\n    };\n    //\n    //\n    // /** Return the leaf cell containing the given S2LatLng. */\n    // public static S2CellId fromLatLng(S2LatLng ll) {\n    //   return fromPoint(ll.toPoint());\n    // }\n    S2CellId.prototype.toPoint = function () {\n        return S2Point_1.S2Point.normalize(this.toPointRaw());\n    };\n    /**\n     * Return the direction vector corresponding to the center of the given cell.\n     * The vector returned by ToPointRaw is not necessarily unit length.\n     */\n    S2CellId.prototype.toPointRaw = function () {\n        // First we compute the discrete (i,j) coordinates of a leaf cell contained\n        // within the given cell. Given that cells are represented by the Hilbert\n        // curve position corresponding at their center, it turns out that the cell\n        // returned by ToFaceIJOrientation is always one of two leaf cells closest\n        // to the center of the cell (unless the given cell is a leaf cell itself,\n        // in which case there is only one possibility).\n        //\n        // Given a cell of size s >= 2 (i.e. not a leaf cell), and letting (imin,\n        // jmin) be the coordinates of its lower left-hand corner, the leaf cell\n        // returned by ToFaceIJOrientation() is either (imin + s/2, jmin + s/2)\n        // (imin + s/2 - 1, jmin + s/2 - 1). We can distinguish these two cases by\n        // looking at the low bit of \"i\" or \"j\". In the first case the low bit is\n        // zero, unless s == 2 (i.e. the level just above leaf cells) in which case\n        // the low bit is one.\n        //\n        // The following calculation converts (i,j) to the (si,ti) coordinates of\n        // the cell center. (We need to multiply the coordinates by a factor of 2\n        // so that the center of leaf cells can be represented exactly.)\n        var i = new MutableInteger_1.MutableInteger(0);\n        var j = new MutableInteger_1.MutableInteger(0);\n        var face = this.toFaceIJOrientation(i, j, null);\n        // System.out.println(\"i= \" + i.intValue() + \" j = \" + j.intValue());\n        // let delta = isLeaf() ? 1 : (((i.intValue() ^ (((int) id) >>> 2)) & 1) != 0) ? 2 : 0;\n        var delta = this.isLeaf()\n            ? 1 :\n            ((((new Long(i.val).getLowBits() ^ ((this.id.getLowBits()) >>> 2)) & 1) != 0)\n                ? 2 : 0);\n        // let delta = this.isLeaf() ? 1 : new Long(i.val).and(this.id.getLowBits() >>> 2).and(1).notEquals(1) ? 2 : 0\n        // ((i.val ? (((int)id) >>> 2))  & 1  ))\n        var si = new Long((i.val << 1) + delta - S2CellId.MAX_SIZE).getLowBits();\n        var ti = new Long((j.val << 1) + delta - S2CellId.MAX_SIZE).getLowBits();\n        return this.faceSiTiToXYZ(face, si, ti);\n    };\n    /** Return the S2LatLng corresponding to the center of the given cell. */\n    S2CellId.prototype.toLatLng = function () {\n        return S2LatLng_1.S2LatLng.fromPoint(this.toPointRaw());\n    };\n    /** Return true if id() represents a valid cell. */\n    S2CellId.prototype.isValid = function () {\n        return this.face < S2CellId.NUM_FACES && ((this.lowestOnBit().and(Long.fromString('0x1555555555555555', false, 16)).notEquals(0)));\n        // return this.face() < NUM_FACES && ((lowestOnBit() & (0x1555555555555555L)) != 0);\n    };\n    /**\n     * The position of the cell center along the Hilbert curve over this face, in\n     * the range 0..(2**kPosBits-1).\n     */\n    S2CellId.prototype.pos = function () {\n        return this.id.and(S2CellId.MAX_UNSIGNED.shiftRightUnsigned(S2CellId.FACE_BITS));\n        // return (id & (-1L >>> FACE_BITS));\n    };\n    /** Return the subdivision level of the cell (range 0..MAX_LEVEL). */\n    S2CellId.prototype.level = function () {\n        // Fast path for leaf cells.\n        if (this.isLeaf()) {\n            return S2CellId.MAX_LEVEL;\n        }\n        var x = this.id.getLowBits();\n        var level = -1;\n        if (x != 0) {\n            level += 16;\n        }\n        else {\n            x = this.id.shiftRightUnsigned(32).getLowBits();\n        }\n        // We only need to look at even-numbered bits to determine the\n        // level of a valid cell id.\n        x &= -x; // Get lowest bit.\n        if ((x & 0x00005555) != 0) {\n            level += 8;\n        }\n        if ((x & 0x00550055) != 0) {\n            level += 4;\n        }\n        if ((x & 0x05050505) != 0) {\n            level += 2;\n        }\n        if ((x & 0x11111111) != 0) {\n            level += 1;\n        }\n        // assert (level >= 0 && level <= MAX_LEVEL);\n        return level;\n    };\n    /**\n     * Return true if this is a top-level face cell (more efficient than checking\n     * whether level() == 0).\n     */\n    S2CellId.prototype.isFace = function () {\n        return this.level() === 0;\n        // return (id & (lowestOnBitForLevel(0) - 1)) == 0;\n    };\n    /**\n     * Return the child position (0..3) of this cell's ancestor at the given\n     * level, relative to its parent. The argument should be in the range\n     * 1..MAX_LEVEL. For example, child_position(1) returns the position of this\n     * cell's level-1 ancestor within its top-level face cell.\n     */\n    S2CellId.prototype.childPosition = function (level) {\n        return this.id.shiftRight((2 * (S2CellId.MAX_LEVEL - level) + 1)).and(3).getLowBits();\n        // return (int) (id >>> (2 * (MAX_LEVEL - level) + 1)) & 3;\n    };\n    // Methods that return the range of cell ids that are contained\n    // within this cell (including itself). The range is *inclusive*\n    // (i.e. test using >= and <=) and the return values of both\n    // methods are valid leaf cell ids.\n    //\n    // These methods should not be used for iteration. If you want to\n    // iterate through all the leaf cells, call child_begin(MAX_LEVEL) and\n    // child_end(MAX_LEVEL) instead.\n    //\n    // It would in fact be error-prone to define a range_end() method,\n    // because (range_max().id() + 1) is not always a valid cell id, and the\n    // iterator would need to be tested using \"<\" rather that the usual \"!=\".\n    S2CellId.prototype.rangeMin = function () {\n        return new S2CellId(this.id.sub(this.lowestOnBit().sub(1)));\n        // return new S2CellId(id - (lowestOnBit() - 1));\n    };\n    S2CellId.prototype.rangeMax = function () {\n        return new S2CellId(this.id.add(this.lowestOnBit().sub(1)));\n        // return new S2CellId(id + (lowestOnBit() - 1));\n    };\n    //\n    //\n    /** Return true if the given cell is contained within this one. */\n    S2CellId.prototype.contains = function (other) {\n        // assert (isValid() && other.isValid());\n        return other.greaterOrEquals(this.rangeMin()) && other.lessOrEquals(this.rangeMax());\n    };\n    /** Return true if the given cell intersects this one. */\n    S2CellId.prototype.intersects = function (other) {\n        // assert (isValid() && other.isValid());\n        return other.rangeMin().lessOrEquals(this.rangeMax())\n            && other.rangeMax().greaterOrEquals(this.rangeMin());\n    };\n    S2CellId.prototype.childBegin = function () {\n        // assert (isValid() && level() < MAX_LEVEL);\n        var oldLsb = this.lowestOnBit();\n        return new S2CellId(this.id.sub(oldLsb).add(oldLsb.shiftRight(2)));\n        // return new S2CellId(id - oldLsb + (oldLsb >>> 2));\n    };\n    S2CellId.prototype.childBeginL = function (level) {\n        // assert (isValid() && level >= this.level() && level <= MAX_LEVEL);\n        return new S2CellId(this.id.sub(this.lowestOnBit()).add(S2CellId.lowestOnBitForLevel(level)));\n        // return new S2CellId(id - lowestOnBit() + lowestOnBitForLevel(level));\n    };\n    S2CellId.prototype.childEnd = function () {\n        // assert (isValid() && level() < MAX_LEVEL);\n        var oldLsb = this.lowestOnBit();\n        return new S2CellId(this.id.add(oldLsb).add(oldLsb.shiftRightUnsigned(2)));\n        // return new S2CellId(id + oldLsb + (oldLsb >>> 2));\n    };\n    S2CellId.prototype.childEndL = function (level) {\n        // assert (isValid() && level >= this.level() && level <= MAX_LEVEL);\n        return new S2CellId(this.id.add(this.lowestOnBit()).add(S2CellId.lowestOnBitForLevel(level)));\n        // return new S2CellId(id + lowestOnBit() + lowestOnBitForLevel(level));\n    };\n    //\n    // Iterator-style methods for traversing the immediate children of a cell or\n    // all of the children at a given level (greater than or equal to the current\n    // level). Note that the end value is exclusive, just like standard STL\n    // iterators, and may not even be a valid cell id. You should iterate using\n    // code like this:\n    //\n    // for(S2CellId c = id.childBegin(); !c.equals(id.childEnd()); c = c.next())\n    // ...\n    //\n    // The convention for advancing the iterator is \"c = c.next()\", so be sure\n    // to use 'equals()' in the loop guard, or compare 64-bit cell id's,\n    // rather than \"c != id.childEnd()\".\n    /**\n     * Return the next cell at the same level along the Hilbert curve. Works\n     * correctly when advancing from one face to the next, but does *not* wrap\n     * around from the last face to the first or vice versa.\n     */\n    S2CellId.prototype.next = function () {\n        return new S2CellId(this.id.add(this.lowestOnBit().shiftLeft(1)));\n        // return new S2CellId(id + (lowestOnBit() << 1));\n    };\n    /**\n     * Return the previous cell at the same level along the Hilbert curve. Works\n     * correctly when advancing from one face to the next, but does *not* wrap\n     * around from the last face to the first or vice versa.\n     */\n    S2CellId.prototype.prev = function () {\n        return new S2CellId(this.id.sub(this.lowestOnBit().shiftLeft(1)));\n        // return new S2CellId(id - (lowestOnBit() << 1));\n    };\n    /**\n     * Like next(), but wraps around from the last face to the first and vice\n     * versa. Should *not* be used for iteration in conjunction with\n     * child_begin(), child_end(), Begin(), or End().\n     */\n    S2CellId.prototype.nextWrap = function () {\n        var n = this.next();\n        if (S2CellId.unsignedLongLessThan(n.id, S2CellId.WRAP_OFFSET)) {\n            return n;\n        }\n        return new S2CellId(n.id.sub(S2CellId.WRAP_OFFSET));\n        // return new S2CellId(n.id - WRAP_OFFSET);\n    };\n    /**\n     * Like prev(), but wraps around from the last face to the first and vice\n     * versa. Should *not* be used for iteration in conjunction with\n     * child_begin(), child_end(), Begin(), or End().\n     */\n    S2CellId.prototype.prevWrap = function () {\n        var p = this.prev();\n        if (p.id.lessThan(S2CellId.WRAP_OFFSET)) {\n            return p;\n        }\n        return new S2CellId(p.id.add(S2CellId.WRAP_OFFSET));\n    };\n    S2CellId.begin = function (level) {\n        return S2CellId.fromFacePosLevel(0, new Long(0), 0).childBeginL(level);\n    };\n    S2CellId.end = function (level) {\n        return S2CellId.fromFacePosLevel(5, new Long(0), 0).childEndL(level);\n    };\n    /**\n     * Decodes the cell id from a compact text string suitable for display or\n     * indexing. Cells at lower levels (i.e. larger cells) are encoded into\n     * fewer characters. The maximum token length is 16.\n     *\n     * @param token the token to decode\n     * @return the S2CellId for that token\n     * @throws NumberFormatException if the token is not formatted correctly\n     */\n    S2CellId.fromToken = function (token) {\n        if (token == null) {\n            throw new Error(\"Null string in S2CellId.fromToken\");\n        }\n        if (token.length == 0) {\n            throw new Error(\"Empty string in S2CellId.fromToken\");\n        }\n        if (token.length > 16 || \"X\" == token) {\n            return S2CellId.none();\n        }\n        var value = new Long(0);\n        for (var pos = 0; pos < 16; pos++) {\n            var digit = new Long(0);\n            if (pos < token.length) {\n                digit = Long.fromString(token[pos], true, 16);\n                if (digit.equals(-1)) {\n                    throw new Error(token);\n                }\n                if (S2CellId.overflowInParse(value, digit.toNumber())) {\n                    throw new Error(\"Too large for unsigned long: \" + token);\n                }\n            }\n            value = value.mul(16).add(digit);\n        }\n        return new S2CellId(value);\n    };\n    /**\n     * Encodes the cell id to compact text strings suitable for display or indexing.\n     * Cells at lower levels (i.e. larger cells) are encoded into fewer characters.\n     * The maximum token length is 16.\n     *\n     * Simple implementation: convert the id to hex and strip trailing zeros. We\n     * could use base-32 or base-64, but assuming the cells used for indexing\n     * regions are at least 100 meters across (level 16 or less), the savings\n     * would be at most 3 bytes (9 bytes hex vs. 6 bytes base-64).\n     *\n     * @return the encoded cell id\n     */\n    S2CellId.prototype.toToken = function () {\n        if (this.id.equals(0)) {\n            return \"X\";\n        }\n        var hex = this.id.toUnsigned().toString(16);\n        // Long.toHexString(id).toLowerCase(Locale.ENGLISH);\n        var sb = '';\n        for (var i = hex.length; i < 16; i++) {\n            sb += '0';\n        }\n        sb += hex;\n        // sb.append(hex);\n        for (var len = 16; len > 0; len--) {\n            if (sb[len - 1] != '0') {\n                return sb.substring(0, len);\n            }\n        }\n        throw new Error(\"Shouldn't make it here\");\n    };\n    /**\n     * Returns true if (current * radix) + digit is a number too large to be\n     * represented by an unsigned long.  This is useful for detecting overflow\n     * while parsing a string representation of a number.\n     * Does not verify whether supplied radix is valid, passing an invalid radix\n     * will give undefined results or an ArrayIndexOutOfBoundsException.\n     */\n    S2CellId.overflowInParse = function (current, digit, radix) {\n        if (radix === void 0) { radix = 10; }\n        if (current.greaterThanOrEqual(0)) {\n            if (current.lessThan(S2CellId.maxValueDivs[radix])) {\n                return false;\n            }\n            if (current.greaterThan(S2CellId.maxValueDivs[radix])) {\n                return true;\n            }\n            // current == maxValueDivs[radix]\n            return (digit > S2CellId.maxValueMods[radix]);\n        }\n        // current < 0: high bit is set\n        return true;\n    };\n    /**\n     * Return the four cells that are adjacent across the cell's four edges.\n     * Neighbors are returned in the order defined by S2Cell::GetEdge. All\n     * neighbors are guaranteed to be distinct.\n     */\n    S2CellId.prototype.getEdgeNeighbors = function () {\n        var i = new MutableInteger_1.MutableInteger(0);\n        var j = new MutableInteger_1.MutableInteger(0);\n        var level = this.level();\n        var size = 1 << (S2CellId.MAX_LEVEL - level);\n        var face = this.toFaceIJOrientation(i, j, null);\n        var neighbors = [];\n        // Edges 0, 1, 2, 3 are in the S, E, N, W directions.\n        neighbors.push(S2CellId.fromFaceIJSame(face, i.val, j.val - size, j.val - size >= 0).parentL(level));\n        neighbors.push(S2CellId.fromFaceIJSame(face, i.val + size, j.val, i.val + size < S2CellId.MAX_SIZE).parentL(level));\n        neighbors.push(S2CellId.fromFaceIJSame(face, i.val, j.val + size, j.val + size < S2CellId.MAX_SIZE).parentL(level));\n        neighbors.push(S2CellId.fromFaceIJSame(face, i.val - size, j.val, i.val - size >= 0).parentL(level));\n        // neighbors[0] = fromFaceIJSame(face, i.intValue(), j.intValue() - size,\n        //     j.intValue() - size >= 0).parent(level);\n        // neighbors[1] = fromFaceIJSame(face, i.intValue() + size, j.intValue(),\n        //     i.intValue() + size < MAX_SIZE).parent(level);\n        // neighbors[2] = fromFaceIJSame(face, i.intValue(), j.intValue() + size,\n        //     j.intValue() + size < MAX_SIZE).parent(level);\n        // neighbors[3] = fromFaceIJSame(face, i.intValue() - size, j.intValue(),\n        //     i.intValue() - size >= 0).parent(level);\n        return neighbors;\n    };\n    /**\n     * Return the neighbors of closest vertex to this cell at the given level, by\n     * appending them to \"output\". Normally there are four neighbors, but the\n     * closest vertex may only have three neighbors if it is one of the 8 cube\n     * vertices.\n     *\n     * Requires: level < this.evel(), so that we can determine which vertex is\n     * closest (in particular, level == MAX_LEVEL is not allowed).\n     */\n    S2CellId.prototype.getVertexNeighbors = function (level) {\n        // \"level\" must be strictly less than this cell's level so that we can\n        // determine which vertex this cell is closest to.\n        // assert (level < this.level());\n        var i = new MutableInteger_1.MutableInteger(0);\n        var j = new MutableInteger_1.MutableInteger(0);\n        var face = this.toFaceIJOrientation(i, j, null);\n        // Determine the i- and j-offsets to the closest neighboring cell in each\n        // direction. This involves looking at the next bit of \"i\" and \"j\" to\n        // determine which quadrant of this->parent(level) this cell lies in.\n        var halfsize = 1 << (S2CellId.MAX_LEVEL - (level + 1));\n        var size = halfsize << 1;\n        var isame, jsame;\n        var ioffset, joffset;\n        if ((i.val & halfsize) != 0) {\n            ioffset = size;\n            isame = (i.val + size) < S2CellId.MAX_SIZE;\n        }\n        else {\n            ioffset = -size;\n            isame = (i.val - size) >= 0;\n        }\n        if ((j.val & halfsize) != 0) {\n            joffset = size;\n            jsame = (j.val + size) < S2CellId.MAX_SIZE;\n        }\n        else {\n            joffset = -size;\n            jsame = (j.val - size) >= 0;\n        }\n        var toRet = [];\n        toRet.push(this.parentL(level));\n        toRet.push(S2CellId\n            .fromFaceIJSame(face, i.val + ioffset, j.val, isame)\n            .parentL(level));\n        // output\n        //     .add(fromFaceIJSame(face, i.intValue() + ioffset, j.intValue(), isame)\n        //         .parent(level));\n        toRet.push(S2CellId\n            .fromFaceIJSame(face, i.val, j.val + joffset, jsame)\n            .parentL(level));\n        // output\n        //     .add(fromFaceIJSame(face, i.intValue(), j.intValue() + joffset, jsame)\n        //         .parent(level));\n        // If i- and j- edge neighbors are *both* on a different face, then this\n        // vertex only has three neighbors (it is one of the 8 cube vertices).\n        if (isame || jsame) {\n            toRet.push(S2CellId.fromFaceIJSame(face, i.val + ioffset, j.val + joffset, isame && jsame).parentL(level));\n        }\n        return toRet;\n    };\n    /**\n     * Append all neighbors of this cell at the given level to \"output\". Two cells\n     * X and Y are neighbors if their boundaries intersect but their interiors do\n     * not. In particular, two cells that intersect at a single point are\n     * neighbors.\n     *\n     * Requires: nbr_level >= this->level(). Note that for cells adjacent to a\n     * face vertex, the same neighbor may be appended more than once.\n     */\n    S2CellId.prototype.getAllNeighbors = function (nbrLevel) {\n        var i = new MutableInteger_1.MutableInteger(0);\n        var j = new MutableInteger_1.MutableInteger(0);\n        var face = this.toFaceIJOrientation(i, j, null);\n        // Find the coordinates of the lower left-hand leaf cell. We need to\n        // normalize (i,j) to a known position within the cell because nbr_level\n        // may be larger than this cell's level.\n        var size = 1 << (S2CellId.MAX_LEVEL - this.level());\n        i.val = i.val & -size;\n        j.val = j.val & -size;\n        var nbrSize = 1 << (S2CellId.MAX_LEVEL - nbrLevel);\n        // assert (nbrSize <= size);\n        var output = [];\n        // We compute the N-S, E-W, and diagonal neighbors in one pass.\n        // The loop test is at the end of the loop to avoid 32-bit overflow.\n        for (var k = -nbrSize;; k += nbrSize) {\n            var sameFace = void 0;\n            if (k < 0) {\n                sameFace = (j.val + k >= 0);\n            }\n            else if (k >= size) {\n                sameFace = (j.val + k < S2CellId.MAX_SIZE);\n            }\n            else {\n                sameFace = true;\n                // North and South neighbors.\n                output.push(S2CellId.fromFaceIJSame(face, i.val + k, j.val - nbrSize, j.val - size >= 0).parentL(nbrLevel));\n                output.push(S2CellId.fromFaceIJSame(face, i.val + k, j.val + size, j.val + size < S2CellId.MAX_SIZE).parentL(nbrLevel));\n            }\n            // East, West, and Diagonal neighbors.\n            output.push(S2CellId.fromFaceIJSame(face, i.val - nbrSize, j.val + k, sameFace && i.val - size >= 0).parentL(nbrLevel));\n            output.push(S2CellId.fromFaceIJSame(face, i.val + size, j.val + k, sameFace && i.val + size < S2CellId.MAX_SIZE).parentL(nbrLevel));\n            if (k >= size) {\n                break;\n            }\n        }\n        return output;\n    };\n    // ///////////////////////////////////////////////////////////////////\n    // Low-level methods.\n    /**\n     * Return a leaf cell given its cube face (range 0..5) and i- and\n     * j-coordinates (see s2.h).\n     */\n    S2CellId.fromFaceIJ = function (face, i, j) {\n        // Optimization notes:\n        // - Non-overlapping bit fields can be combined with either \"+\" or \"|\".\n        // Generally \"+\" seems to produce better code, but not always.\n        // gcc doesn't have very good code generation for 64-bit operations.\n        // We optimize this by computing the result as two 32-bit integers\n        // and combining them at the end. Declaring the result as an array\n        // rather than local variables helps the compiler to do a better job\n        // of register allocation as well. Note that the two 32-bits halves\n        // get shifted one bit to the left when they are combined.\n        var faceL = new Long(face);\n        var n = [new Long(0), faceL.shiftLeft(S2CellId.POS_BITS - 33)];\n        // Alternating faces have opposite Hilbert curve orientations; this\n        // is necessary in order for all faces to have a right-handed\n        // coordinate system.\n        var bits = faceL.and(S2CellId.SWAP_MASK);\n        // Each iteration maps 4 bits of \"i\" and \"j\" into 8 bits of the Hilbert\n        // curve position. The lookup table transforms a 10-bit key of the form\n        // \"iiiijjjjoo\" to a 10-bit value of the form \"ppppppppoo\", where the\n        // letters [ijpo] denote bits of \"i\", \"j\", Hilbert curve position, and\n        // Hilbert curve orientation respectively.\n        for (var k = 7; k >= 0; --k) {\n            bits = S2CellId.getBits(n, i, j, k, bits);\n        }\n        // S2CellId s = new S2CellId((((n[1] << 32) + n[0]) << 1) + 1);\n        return new S2CellId(n[1].shiftLeft(32)\n            .add(n[0])\n            .shiftLeft(1)\n            .add(1));\n    };\n    S2CellId.getBits = function (n, i, j, k, bits) {\n        var mask = new Long(1).shiftLeft(S2CellId.LOOKUP_BITS).sub(1);\n        bits = bits.add(new Long(i)\n            .shiftRight(k * S2CellId.LOOKUP_BITS)\n            .and(mask)\n            .shiftLeft(S2CellId.LOOKUP_BITS + 2));\n        // bits += (((i >> (k * LOOKUP_BITS)) & mask) << (LOOKUP_BITS + 2));\n        bits = bits.add(new Long(j)\n            .shiftRight(k * S2CellId.LOOKUP_BITS)\n            .and(mask)\n            .shiftLeft(2));\n        // bits += (((j >> (k * LOOKUP_BITS)) & mask) << 2);\n        bits = S2CellId.LOOKUP_POS[bits.toNumber()];\n        n[k >> 2] = n[k >> 2].or(bits.shiftRight(2).shiftLeft((k & 3) * 2 * S2CellId.LOOKUP_BITS));\n        // n[k >> 2] |= ((((long) bits) >> 2) << ((k & 3) * 2 * LOOKUP_BITS));\n        return bits.and(S2CellId.SWAP_MASK | S2CellId.INVERT_MASK);\n    };\n    /**\n     * Return the i- or j-index of the leaf cell containing the given s- or\n     * t-value.\n     */\n    S2CellId.stToIJ = function (_s) {\n        // Converting from floating-point to integers via static_cast is very slow\n        // on Intel processors because it requires changing the rounding mode.\n        // Rounding to the nearest integer using FastIntRound() is much faster.\n        var s = S2_1.S2.toDecimal(_s);\n        var m = S2_1.S2.toDecimal(S2CellId.MAX_SIZE).dividedBy(2); // scaling multiplier\n        return decimal_1.Decimal.max(0, decimal_1.Decimal.min(m.times(2).minus(1), decimal_1.Decimal.round(m.times(s).plus(m.minus(0.5))))).toNumber();\n        // return Math.max(0,  Math.min(2 * m - 1, Math.round(m * s + (m - 0.5))));\n        // return (int) Math.max(0, Math.min(2 * m - 1, Math.round(m * s + (m - 0.5))));\n    };\n    /**\n     * Given (i, j) coordinates that may be out of bounds, normalize them by\n     * returning the corresponding neighbor cell on an adjacent face.\n     */\n    S2CellId.fromFaceIJWrap = function (face, i, j) {\n        // Convert i and j to the coordinates of a leaf cell just beyond the\n        // boundary of this face. This prevents 32-bit overflow in the case\n        // of finding the neighbors of a face cell, and also means that we\n        // don't need to worry about the distinction between (s,t) and (u,v).\n        i = Math.max(-1, Math.min(S2CellId.MAX_SIZE, i));\n        j = Math.max(-1, Math.min(S2CellId.MAX_SIZE, j));\n        // Find the (s,t) coordinates corresponding to (i,j). At least one\n        // of these coordinates will be just outside the range [0, 1].\n        var kScale = S2_1.S2.toDecimal(1.0).dividedBy(S2CellId.MAX_SIZE);\n        var s = kScale.times(new Long(i).shiftLeft(1).add(1).sub(S2CellId.MAX_SIZE).toInt());\n        var t = kScale.times(new Long(j).shiftLeft(1).add(1).sub(S2CellId.MAX_SIZE).toInt());\n        // Find the leaf cell coordinates on the adjacent face, and convert\n        // them to a cell id at the appropriate level.\n        var p = new R2Vector_1.R2Vector(s, t).toPoint(face);\n        face = p.toFace();\n        // face = S2Projections.xyzToFace(p);\n        var st = p.toR2Vector(face);\n        // R2Vector st = S2Projections.validFaceXyzToUv(face, p);\n        return S2CellId.fromFaceIJ(face, S2CellId.stToIJ(st.x), S2CellId.stToIJ(st.y));\n    };\n    /**\n     * Public helper function that calls FromFaceIJ if sameFace is true, or\n     * FromFaceIJWrap if sameFace is false.\n     */\n    S2CellId.fromFaceIJSame = function (face, i, j, sameFace) {\n        if (sameFace) {\n            return S2CellId.fromFaceIJ(face, i, j);\n        }\n        else {\n            return S2CellId.fromFaceIJWrap(face, i, j);\n        }\n    };\n    /**\n     * Returns true if x1 < x2, when both values are treated as unsigned.\n     */\n    S2CellId.unsignedLongLessThan = function (x1, x2) {\n        return x1.toUnsigned().lessThan(x2.toUnsigned());\n        // return (x1 + Long.MIN_VALUE) < (x2 + Long.MIN_VALUE);\n    };\n    /**\n     * Returns true if x1 > x2, when both values are treated as unsigned.\n     */\n    S2CellId.unsignedLongGreaterThan = function (x1, x2) {\n        return x1.toUnsigned().greaterThan(x2.toUnsigned());\n        // return (x1 + Long.MIN_VALUE) > (x2 + Long.MIN_VALUE);\n    };\n    S2CellId.prototype.lessThan = function (x) {\n        return S2CellId.unsignedLongLessThan(this.id, x.id);\n    };\n    S2CellId.prototype.greaterThan = function (x) {\n        return S2CellId.unsignedLongGreaterThan(this.id, x.id);\n    };\n    S2CellId.prototype.lessOrEquals = function (x) {\n        return S2CellId.unsignedLongLessThan(this.id, x.id) || this.id.equals(x.id);\n    };\n    S2CellId.prototype.greaterOrEquals = function (x) {\n        return S2CellId.unsignedLongGreaterThan(this.id, x.id) || this.id.equals(x.id);\n    };\n    S2CellId.prototype.toString = function () {\n        return \"(face=\" + this.face + \", pos=\" + this.pos().toString(16) + \", level=\"\n            + this.level() + \")\";\n    };\n    S2CellId.prototype.compareTo = function (that) {\n        return S2CellId.unsignedLongLessThan(this.id, that.id) ? -1 :\n            S2CellId.unsignedLongGreaterThan(this.id, that.id) ? 1 : 0;\n    };\n    S2CellId.prototype.equals = function (that) {\n        return this.compareTo(that) === 0;\n    };\n    /**\n     * Returns the position of the id within the given list or a negative value with\n     * the position of the index wher eit should be entered if the id was present\n     */\n    S2CellId.binarySearch = function (ids, _id, low) {\n        if (low === void 0) { low = 0; }\n        var id;\n        if (_id instanceof S2CellId) {\n            id = _id;\n        }\n        else if (_id instanceof Long) {\n            id = new S2CellId(_id);\n        }\n        var high = ids.length - 1;\n        while (low <= high) {\n            var mid = (low + high) >>> 1;\n            var midVal = ids[mid];\n            var cmp = midVal.compareTo(id);\n            if (cmp < 0)\n                low = mid + 1;\n            else if (cmp > 0)\n                high = mid - 1;\n            else\n                return mid; // key found\n        }\n        return -(low + 1); // key not found\n    };\n    S2CellId.indexedBinarySearch = function (ids, id, low) {\n        if (low === void 0) { low = 0; }\n        var toRet = this.binarySearch(ids, id, low);\n        if (toRet >= 0) {\n            return toRet;\n        }\n        else {\n            return -(toRet + 1);\n        }\n    };\n    // Although only 60 bits are needed to represent the index of a leaf\n    // cell, we need an extra bit in order to represent the position of\n    // the center of the leaf cell along the Hilbert curve.\n    S2CellId.FACE_BITS = 3;\n    S2CellId.NUM_FACES = 6;\n    S2CellId.MAX_LEVEL = 30; // Valid levels: 0..MAX_LEVEL\n    S2CellId.POS_BITS = 2 * S2CellId.MAX_LEVEL + 1;\n    S2CellId.MAX_SIZE = 1 << S2CellId.MAX_LEVEL;\n    //\n    // calculated as 0xffffffffffffffff / radix\n    S2CellId.maxValueDivs = [new Long(0), new Long(0),\n        parseHex('9223372036854775807'), parseHex('6148914691236517205'), parseHex('4611686018427387903'),\n        parseHex('3689348814741910323'), parseHex('3074457345618258602'), parseHex('2635249153387078802'),\n        parseHex('2305843009213693951'), parseHex('2049638230412172401'), parseHex('1844674407370955161'),\n        parseHex('1676976733973595601'), parseHex('1537228672809129301'), parseHex('1418980313362273201'),\n        parseHex('1317624576693539401'), parseHex('1229782938247303441'), parseHex('1152921504606846975'),\n        parseHex('1085102592571150095'), parseHex('1024819115206086200'), parseHex('970881267037344821'),\n        parseHex('922337203685477580'), parseHex('878416384462359600'), parseHex('838488366986797800'),\n        parseHex('802032351030850070'), parseHex('768614336404564650'), parseHex('737869762948382064'),\n        parseHex('709490156681136600'), parseHex('683212743470724133'), parseHex('658812288346769700'),\n        parseHex('636094623231363848'), parseHex('614891469123651720'), parseHex('595056260442243600'),\n        parseHex('576460752303423487'), parseHex('558992244657865200'), parseHex('542551296285575047'),\n        parseHex('527049830677415760'), parseHex('512409557603043100')]; // 35-36\n    // calculated as 0xffffffffffffffff % radix\n    S2CellId.maxValueMods = [0, 0,\n        1, 0, 3, 0, 3, 1, 7, 6, 5, 4, 3, 2, 1, 0, 15, 0, 15, 16, 15, 15,\n        15, 5, 15, 15, 15, 24, 15, 23, 15, 15, 31, 15, 17, 15, 15]; // 22-36\n    // Constant related to unsigned long's\n    // '18446744073709551615'\n    // Long.fromString('0xffffffffffffffff', true, 16).toString()\n    // new Decimal(2).pow(64).sub(1);\n    S2CellId.MAX_UNSIGNED = Long.fromString('0xffffffffffffffff', true, 16);\n    // The following lookup tables are used to convert efficiently between an\n    // (i,j) cell index and the corresponding position along the Hilbert curve.\n    // \"lookup_pos\" maps 4 bits of \"i\", 4 bits of \"j\", and 2 bits representing the\n    // orientation of the current cell into 8 bits representing the order in which\n    // that subcell is visited by the Hilbert curve, plus 2 bits indicating the\n    // new orientation of the Hilbert curve within that subcell. (Cell\n    // orientations are represented as combination of kSwapMask and kInvertMask.)\n    //\n    // \"lookup_ij\" is an inverted table used for mapping in the opposite\n    // direction.\n    //\n    // We also experimented with looking up 16 bits at a time (14 bits of position\n    // plus 2 of orientation) but found that smaller lookup tables gave better\n    // performance. (2KB fits easily in the primary cache.)\n    // Values for these constants are *declared* in the *.h file. Even though\n    // the declaration specifies a value for the constant, that declaration\n    // is not a *definition* of storage for the value. Because the values are\n    // supplied in the declaration, we don't need the values here. Failing to\n    // define storage causes link errors for any code that tries to take the\n    // address of one of these values.\n    S2CellId.LOOKUP_BITS = 4;\n    S2CellId.SWAP_MASK = 0x01;\n    S2CellId.INVERT_MASK = 0x02;\n    S2CellId.LOOKUP_POS = [];\n    S2CellId.LOOKUP_IJ = [];\n    /**\n     * This is the offset required to wrap around from the beginning of the\n     * Hilbert curve to the end or vice versa; see next_wrap() and prev_wrap().\n     */\n    S2CellId.WRAP_OFFSET = new Long(S2CellId.NUM_FACES).shiftLeft(S2CellId.POS_BITS);\n    return S2CellId;\n}());\nexports.S2CellId = S2CellId;\nfunction initLookupCell(level, i, j, origOrientation, pos, orientation) {\n    if (level == S2CellId.LOOKUP_BITS) {\n        var ij = (i << S2CellId.LOOKUP_BITS) + j;\n        S2CellId.LOOKUP_POS[(ij << 2) + origOrientation] = pos.shiftLeft(2).add(orientation);\n        S2CellId.LOOKUP_IJ[pos.shiftLeft(2).add(origOrientation).toNumber()] = (ij << 2) + orientation;\n    }\n    else {\n        level++;\n        i <<= 1;\n        j <<= 1;\n        pos = pos.shiftLeft(2);\n        // Initialize each sub-cell recursively.\n        for (var subPos = 0; subPos < 4; subPos++) {\n            var ij = S2_1.S2.POS_TO_IJ[orientation][subPos];\n            var orientationMask = S2_1.S2.POS_TO_ORIENTATION[subPos];\n            initLookupCell(level, i + (ij >>> 1), j + (ij & 1), origOrientation, pos.add(subPos), orientation ^ orientationMask);\n        }\n    }\n}\ninitLookupCell(0, 0, 0, 0, new Long(0), 0);\ninitLookupCell(0, 0, 0, S2_1.S2.SWAP_MASK, new Long(0), S2_1.S2.SWAP_MASK);\ninitLookupCell(0, 0, 0, S2_1.S2.INVERT_MASK, new Long(0), S2_1.S2.INVERT_MASK);\ninitLookupCell(0, 0, 0, S2_1.S2.SWAP_MASK | S2_1.S2.INVERT_MASK, new Long(0), S2_1.S2.SWAP_MASK | S2_1.S2.INVERT_MASK);\n//# sourceMappingURL=S2CellId.js.map","\"use strict\";\n/*\n * Copyright 2005 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Long = require('long');\nvar S2CellId_1 = require(\"./S2CellId\");\nvar S2Cell_1 = require(\"./S2Cell\");\nvar S2Projections_1 = require(\"./S2Projections\");\nvar S2LatLngRect_1 = require(\"./S2LatLngRect\");\nvar S2Point_1 = require(\"./S2Point\");\nvar S2_1 = require(\"./S2\");\nvar S2Cap_1 = require(\"./S2Cap\");\n/**\n * An S2CellUnion is a region consisting of cells of various sizes. Typically a\n * cell union is used to approximate some other shape. There is a tradeoff\n * between the accuracy of the approximation and how many cells are used. Unlike\n * polygons, cells have a fixed hierarchical structure. This makes them more\n * suitable for optimizations based on preprocessing.\n *\n */\nvar S2CellUnion = (function () {\n    function S2CellUnion() {\n        /** The CellIds that form the Union */\n        this.cellIds = [];\n    }\n    S2CellUnion.prototype.S2CellUnion = function () {\n    };\n    /**\n     * Populates a cell union with the given S2CellIds or 64-bit cells ids, and\n     * then calls Normalize(). The InitSwap() version takes ownership of the\n     * vector data without copying and clears the given vector. These methods may\n     * be called multiple times.\n     */\n    S2CellUnion.prototype.initFromIds = function (cellIds) {\n        this.initRawIds(cellIds);\n        this.normalize();\n    };\n    S2CellUnion.prototype.initSwap = function (cellIds) {\n        this.initRawSwap(cellIds);\n        this.normalize();\n    };\n    S2CellUnion.prototype.initRawCellIds = function (cellIds) {\n        this.cellIds = cellIds;\n    };\n    S2CellUnion.prototype.initRawIds = function (cellIds) {\n        var size = cellIds.length;\n        this.cellIds = [];\n        for (var i = 0; i < size; i++) {\n            this.cellIds.push(new S2CellId_1.S2CellId(cellIds[i]));\n        }\n    };\n    /**\n     * Like Init(), but does not call Normalize(). The cell union *must* be\n     * normalized before doing any calculations with it, so it is the caller's\n     * responsibility to make sure that the input is normalized. This method is\n     * useful when converting cell unions to another representation and back.\n     * These methods may be called multiple times.\n     */\n    S2CellUnion.prototype.initRawSwap = function (cellIds) {\n        this.cellIds = [].concat(cellIds);\n    };\n    S2CellUnion.prototype.size = function () {\n        return this.cellIds.length;\n    };\n    /** Convenience methods for accessing the individual cell ids. */\n    S2CellUnion.prototype.cellId = function (i) {\n        return this.cellIds[i];\n    };\n    S2CellUnion.prototype.getCellIds = function () {\n        return this.cellIds;\n    };\n    /**\n     * Replaces \"output\" with an expanded version of the cell union where any\n     * cells whose level is less than \"min_level\" or where (level - min_level) is\n     * not a multiple of \"level_mod\" are replaced by their children, until either\n     * both of these conditions are satisfied or the maximum level is reached.\n     *\n     *  This method allows a covering generated by S2RegionCoverer using\n     * min_level() or level_mod() constraints to be stored as a normalized cell\n     * union (which allows various geometric computations to be done) and then\n     * converted back to the original list of cell ids that satisfies the desired\n     * constraints.\n     */\n    S2CellUnion.prototype.denormalize = function (minLevel, levelMod) {\n        // assert (minLevel >= 0 && minLevel <= S2CellId.MAX_LEVEL);\n        // assert (levelMod >= 1 && levelMod <= 3);\n        var output = [];\n        for (var i = 0; i < this.cellIds.length; i++) {\n            var id = this.cellIds[i];\n            var level = id.level();\n            var newLevel = Math.max(minLevel, level);\n            if (levelMod > 1) {\n                // Round up so that (new_level - min_level) is a multiple of level_mod.\n                // (Note that S2CellId::kMaxLevel is a multiple of 1, 2, and 3.)\n                newLevel += (S2CellId_1.S2CellId.MAX_LEVEL - (newLevel - minLevel)) % levelMod;\n                newLevel = Math.min(S2CellId_1.S2CellId.MAX_LEVEL, newLevel);\n            }\n            if (newLevel == level) {\n                output.push(id);\n            }\n            else {\n                var end = id.childEndL(newLevel);\n                for (var iid = id.childBeginL(newLevel); !iid.equals(end); iid = iid.next()) {\n                    output.push(iid);\n                }\n            }\n        }\n        return output;\n    };\n    /**\n     * If there are more than \"excess\" elements of the cell_ids() vector that are\n     * allocated but unused, reallocate the array to eliminate the excess space.\n     * This reduces memory usage when many cell unions need to be held in memory\n     * at once.\n     */\n    S2CellUnion.prototype.pack = function () {\n        throw new Error('useless');\n        // this.cellIds.trimToSize();\n    };\n    S2CellUnion.prototype.containsC = function (cell) {\n        return this.containsCell(cell);\n    };\n    S2CellUnion.prototype.mayIntersectC = function (cell) {\n        return this.mayIntersectCell(cell);\n    };\n    /**\n     * Return true if the cell union contains the given cell id. Containment is\n     * defined with respect to regions, e.g. a cell contains its 4 children. This\n     * is a fast operation (logarithmic in the size of the cell union).\n     */\n    S2CellUnion.prototype.contains = function (id) {\n        // This function requires that Normalize has been called first.\n        //\n        // This is an exact test. Each cell occupies a linear span of the S2\n        // space-filling curve, and the cell id is simply the position at the center\n        // of this span. The cell union ids are sorted in increasing order along\n        // the space-filling curve. So we simply find the pair of cell ids that\n        // surround the given cell id (using binary search). There is containment\n        // if and only if one of these two cell ids contains this cell.\n        var pos = S2CellId_1.S2CellId.binarySearch(this.cellIds, id.id);\n        if (pos < 0) {\n            pos = -pos - 1;\n        }\n        if (pos < this.cellIds.length && this.cellIds[pos].rangeMin().lessOrEquals(id)) {\n            return true;\n        }\n        return pos != 0 && this.cellIds[pos - 1].rangeMax().greaterOrEquals(id);\n    };\n    /**\n     * Return true if the cell union intersects the given cell id. This is a fast\n     * operation (logarithmic in the size of the cell union).\n     */\n    S2CellUnion.prototype.intersects = function (id) {\n        // This function requires that Normalize has been called first.\n        // This is an exact test; see the comments for Contains() above.\n        var pos = S2CellId_1.S2CellId.binarySearch(this.cellIds, id.id);\n        if (pos < 0) {\n            pos = -pos - 1;\n        }\n        if (pos < this.cellIds.length && this.cellIds[pos].rangeMin().lessOrEquals(id.rangeMax())) {\n            return true;\n        }\n        return pos != 0 && this.cellIds[pos - 1].rangeMax().greaterOrEquals(id.rangeMin());\n    };\n    S2CellUnion.prototype.containsUnion = function (that) {\n        // A divide-and-conquer or alternating-skip-search approach\n        // may be significantly faster in both the average and worst case.\n        for (var i = 0; i < that.cellIds.length; i++) {\n            if (!this.contains(that.cellIds[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /** This is a fast operation (logarithmic in the size of the cell union). */\n    S2CellUnion.prototype.containsCell = function (cell) {\n        return this.contains(cell.id);\n    };\n    /**\n     * Return true if this cell union contain/intersects the given other cell\n     * union.\n     */\n    S2CellUnion.prototype.intersectsUnion = function (that) {\n        // A divide-and-conquer or alternating-skip-search approach\n        // may be significantly faster in both the average and worst case.\n        for (var i = 0; i < that.cellIds.length; i++) {\n            if (!this.intersects(that.cellIds[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n    S2CellUnion.prototype.getUnion = function (x, y) {\n        // assert (x != this && y != this);\n        this.cellIds = [].concat(x.cellIds).concat(y.cellIds);\n        this.normalize();\n    };\n    /**\n     * Specialized version of GetIntersection() that gets the intersection of a\n     * cell union with the given cell id. This can be useful for \"splitting\" a\n     * cell union into chunks.\n     */\n    S2CellUnion.prototype.getIntersection = function (x, id) {\n        // assert (x != this);\n        this.cellIds = [];\n        if (x.contains(id)) {\n            this.cellIds.push(id);\n        }\n        else {\n            var pos = S2CellId_1.S2CellId.binarySearch(x.cellIds, id.rangeMin().id);\n            if (pos < 0) {\n                pos = -pos - 1;\n            }\n            var idmax = id.rangeMax();\n            var size = x.cellIds.length;\n            while (pos < size && x.cellIds[pos].lessOrEquals(idmax)) {\n                this.cellIds.push(x.cellIds[(pos++)]);\n            }\n        }\n    };\n    /**\n     * Initialize this cell union to the union or intersection of the two given\n     * cell unions. Requires: x != this and y != this.\n     */\n    S2CellUnion.prototype.getIntersectionUU = function (x, y) {\n        // assert (x != this && y != this);\n        // This is a fairly efficient calculation that uses binary search to skip\n        // over sections of both input vectors. It takes constant time if all the\n        // cells of \"x\" come before or after all the cells of \"y\" in S2CellId order.\n        this.cellIds = [];\n        var i = 0;\n        var j = 0;\n        while (i < x.cellIds.length && j < y.cellIds.length) {\n            var imin = x.cellId(i).rangeMin();\n            var jmin = y.cellId(j).rangeMin();\n            if (imin.greaterThan(jmin)) {\n                // Either j->contains(*i) or the two cells are disjoint.\n                if (x.cellId(i).lessOrEquals(y.cellId(j).rangeMax())) {\n                    this.cellIds.push(x.cellId(i++));\n                }\n                else {\n                    // Advance \"j\" to the first cell possibly contained by *i.\n                    j = S2CellId_1.S2CellId.indexedBinarySearch(y.cellIds, imin, j + 1);\n                    // The previous cell *(j-1) may now contain *i.\n                    if (x.cellId(i).lessOrEquals(y.cellId(j - 1).rangeMax())) {\n                        --j;\n                    }\n                }\n            }\n            else if (jmin.greaterThan(imin)) {\n                // Identical to the code above with \"i\" and \"j\" reversed.\n                if (y.cellId(j).lessOrEquals(x.cellId(i).rangeMax())) {\n                    this.cellIds.push(y.cellId(j++));\n                }\n                else {\n                    i = S2CellId_1.S2CellId.indexedBinarySearch(x.cellIds, jmin, i + 1);\n                    if (y.cellId(j).lessOrEquals(x.cellId(i - 1).rangeMax())) {\n                        --i;\n                    }\n                }\n            }\n            else {\n                // \"i\" and \"j\" have the same range_min(), so one contains the other.\n                if (x.cellId(i).lessThan(y.cellId(j))) {\n                    this.cellIds.push(x.cellId(i++));\n                }\n                else {\n                    this.cellIds.push(y.cellId(j++));\n                }\n            }\n        }\n        // The output is generated in sorted order, and there should not be any\n        // cells that can be merged (provided that both inputs were normalized).\n        // assert (!normalize());\n    };\n    /**\n     * Expands the cell union such that it contains all cells of the given level\n     * that are adjacent to any cell of the original union. Two cells are defined\n     * as adjacent if their boundaries have any points in common, i.e. most cells\n     * have 8 adjacent cells (not counting the cell itself).\n     *\n     *  Note that the size of the output is exponential in \"level\". For example,\n     * if level == 20 and the input has a cell at level 10, there will be on the\n     * order of 4000 adjacent cells in the output. For most applications the\n     * Expand(min_fraction, min_distance) method below is easier to use.\n     */\n    S2CellUnion.prototype.expand = function (level) {\n        var output = [];\n        var levelLsb = S2CellId_1.S2CellId.lowestOnBitForLevel(level);\n        var i = this.size() - 1;\n        do {\n            var id = this.cellId(i);\n            if (id.lowestOnBit().lessThan(levelLsb)) {\n                id = id.parentL(level);\n                // Optimization: skip over any cells contained by this one. This is\n                // especially important when very small regions are being expanded.\n                while (i > 0 && id.contains(this.cellId(i - 1))) {\n                    --i;\n                }\n            }\n            output.push(id);\n            output = output.concat(id.getAllNeighbors(level));\n        } while (--i >= 0);\n        this.initSwap(output);\n    };\n    /**\n     * Expand the cell union such that it contains all points whose distance to\n     * the cell union is at most minRadius, but do not use cells that are more\n     * than maxLevelDiff levels higher than the largest cell in the input. The\n     * second parameter controls the tradeoff between accuracy and output size\n     * when a large region is being expanded by a small amount (e.g. expanding\n     * Canada by 1km).\n     *\n     *  For example, if maxLevelDiff == 4, the region will always be expanded by\n     * approximately 1/16 the width of its largest cell. Note that in the worst\n     * case, the number of cells in the output can be up to 4 * (1 + 2 **\n     * maxLevelDiff) times larger than the number of cells in the input.\n     */\n    S2CellUnion.prototype.expandA = function (minRadius, maxLevelDiff) {\n        var minLevel = S2CellId_1.S2CellId.MAX_LEVEL;\n        for (var i = 0; i < this.cellIds.length; i++) {\n            var id = this.cellId(i);\n            minLevel = Math.min(minLevel, id.level());\n        }\n        // Find the maximum level such that all cells are at least \"min_radius\"\n        // wide.\n        var radiusLevel = S2Projections_1.S2Projections.MIN_WIDTH.getMaxLevel(minRadius.radians);\n        if (radiusLevel == 0 && minRadius.radians.gt(S2Projections_1.S2Projections.MIN_WIDTH.getValue(0))) {\n            // The requested expansion is greater than the width of a face cell.\n            // The easiest way to handle this is to expand twice.\n            this.expand(0);\n        }\n        this.expand(Math.min(minLevel + maxLevelDiff, radiusLevel));\n    };\n    S2CellUnion.prototype.getCapBound = function () {\n        // Compute the approximate centroid of the region. This won't produce the\n        // bounding cap of minimal area, but it should be close enough.\n        if (this.cellIds.length == 0) {\n            return S2Cap_1.S2Cap.empty();\n        }\n        var centroid = new S2Point_1.S2Point(0, 0, 0);\n        this.cellIds.forEach(function (id) {\n            var area = S2Cell_1.S2Cell.averageArea(id.level());\n            centroid = S2Point_1.S2Point.add(centroid, S2Point_1.S2Point.mul(id.toPoint(), area));\n        });\n        if (centroid.equals(new S2Point_1.S2Point(0, 0, 0))) {\n            centroid = new S2Point_1.S2Point(1, 0, 0);\n        }\n        else {\n            centroid = S2Point_1.S2Point.normalize(centroid);\n        }\n        // Use the centroid as the cap axis, and expand the cap angle so that it\n        // contains the bounding caps of all the individual cells. Note that it is\n        // *not* sufficient to just bound all the cell vertices because the bounding\n        // cap may be concave (i.e. cover more than one hemisphere).\n        var cap = new S2Cap_1.S2Cap(centroid, 0);\n        this.cellIds.forEach(function (id) {\n            cap = cap.addCap(new S2Cell_1.S2Cell(id).getCapBound());\n        });\n        return cap;\n    };\n    S2CellUnion.prototype.getRectBound = function () {\n        var bound = S2LatLngRect_1.S2LatLngRect.empty();\n        this.cellIds.forEach(function (id) {\n            bound = bound.union(new S2Cell_1.S2Cell(id).getRectBound());\n        });\n        return bound;\n    };\n    /** This is a fast operation (logarithmic in the size of the cell union). */\n    S2CellUnion.prototype.mayIntersectCell = function (cell) {\n        return this.intersects(cell.id);\n    };\n    /**\n     * The point 'p' does not need to be normalized. This is a fast operation\n     * (logarithmic in the size of the cell union).\n     */\n    S2CellUnion.prototype.containsPoint = function (p) {\n        return this.contains(S2CellId_1.S2CellId.fromPoint(p));\n    };\n    /**\n     * The number of leaf cells covered by the union.\n     * This will be no more than 6*2^60 for the whole sphere.\n     *\n     * @return the number of leaf cells covered by the union\n     */\n    S2CellUnion.prototype.leafCellsCovered = function () {\n        var numLeaves = new Long(0);\n        this.cellIds.forEach(function (id) {\n            var invertedLevel = S2CellId_1.S2CellId.MAX_LEVEL - id.level();\n            numLeaves = numLeaves\n                .add(new Long(1).shiftLeft(invertedLevel << 1));\n        });\n        return numLeaves;\n    };\n    /**\n     * Approximate this cell union's area by summing the average area of\n     * each contained cell's average area, using {@link S2Cell#averageArea()}.\n     * This is equivalent to the number of leaves covered, multiplied by\n     * the average area of a leaf.\n     * Note that {@link S2Cell#averageArea()} does not take into account\n     * distortion of cell, and thus may be off by up to a factor of 1.7.\n     * NOTE: Since this is proportional to LeafCellsCovered(), it is\n     * always better to use the other function if all you care about is\n     * the relative average area between objects.\n     *\n     * @return the sum of the average area of each contained cell's average area\n     */\n    S2CellUnion.prototype.averageBasedArea = function () {\n        return S2_1.S2.toDecimal(this.leafCellsCovered().toString()).times(S2Projections_1.S2Projections.AVG_AREA.getValue(S2CellId_1.S2CellId.MAX_LEVEL)).toNumber();\n    };\n    /**\n     * Calculates this cell union's area by summing the approximate area for each\n     * contained cell, using {@link S2Cell#approxArea()}.\n     *\n     * @return approximate area of the cell union\n     */\n    S2CellUnion.prototype.approxArea = function () {\n        var area = S2_1.S2.toDecimal(0);\n        this.cellIds.forEach(function (id) {\n            area = area.plus(new S2Cell_1.S2Cell(id).approxArea());\n        });\n        return area.toNumber();\n    };\n    /**\n     * Calculates this cell union's area by summing the exact area for each\n     * contained cell, using the {@link S2Cell#exactArea()}.\n     *\n     * @return the exact area of the cell union\n     */\n    S2CellUnion.prototype.exactArea = function () {\n        var area = S2_1.S2.toDecimal(0);\n        this.cellIds.forEach(function (id) {\n            area = area.plus(new S2Cell_1.S2Cell(id).exactArea());\n        });\n        return area.toNumber();\n    };\n    /**\n     * Normalizes the cell union by discarding cells that are contained by other\n     * cells, replacing groups of 4 child cells by their parent cell whenever\n     * possible, and sorting all the cell ids in increasing order. Returns true if\n     * the number of cells was reduced.\n     *\n     *  This method *must* be called before doing any calculations on the cell\n     * union, such as Intersects() or Contains().\n     *\n     * @return true if the normalize operation had any effect on the cell union,\n     *         false if the union was already normalized\n     */\n    S2CellUnion.prototype.normalize = function () {\n        // Optimize the representation by looking for cases where all subcells\n        // of a parent cell are present.\n        var output = [];\n        // ArrayList<S2CellId> output = new ArrayList<>(this.cellIds.size());\n        // output.ensureCapacity(this.cellIds.size());\n        this.cellIds.sort(function (a, b) { return a.compareTo(b); });\n        // Collections.sort(this.cellIds);\n        this.cellIds.forEach(function (id) {\n            var size = output.length;\n            // Check whether this cell is contained by the previous cell.\n            if (output.length !== 0 && output[size - 1].contains(id)) {\n                return;\n            }\n            // Discard any previous cells contained by this cell.\n            while (output.length !== 0 && id.contains(output[output.length - 1])) {\n                output.splice(output.length - 1, 1);\n            }\n            // Check whether the last 3 elements of \"output\" plus \"id\" can be\n            // collapsed into a single parent cell.\n            while (output.length >= 3) {\n                size = output.length;\n                // A necessary (but not sufficient) condition is that the XOR of the\n                // four cells must be zero. This is also very fast to test.\n                if ((output[size - 3].id.and(output[size - 2].id).and(output[size - 1].id)).notEquals(id.id)) {\n                    break;\n                }\n                // Now we do a slightly more expensive but exact test. First, compute a\n                // mask that blocks out the two bits that encode the child position of\n                // \"id\" with respect to its parent, then check that the other three\n                // children all agree with \"mask.\n                var mask = id.lowestOnBit().shiftLeft(1);\n                mask = mask.add(mask.shiftLeft(1)).not();\n                // mask = ~(mask + (mask << 1));\n                var idMasked = id.id.and(mask);\n                if ((output[size - 3].id.and(mask)).notEquals(idMasked)\n                    || (output[size - 2].id.and(mask)).notEquals(idMasked)\n                    || (output[size - 1].id.and(mask)).notEquals(idMasked) || id.isFace()) {\n                    break;\n                }\n                // Replace four children by their parent cell.\n                output.splice(size - 3);\n                // output.remove(size - 1);\n                // output.remove(size - 2);\n                // output.remove(size - 3);\n                id = id.parent();\n            }\n            output.push(id);\n        });\n        if (output.length < this.size()) {\n            this.initRawSwap(output);\n            return true;\n        }\n        return false;\n    };\n    return S2CellUnion;\n}());\nexports.S2CellUnion = S2CellUnion;\n//# sourceMappingURL=S2CellUnion.js.map","/*\n * Copyright 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar S2Point_1 = require(\"./S2Point\");\nvar S2_1 = require(\"./S2\");\nvar S1Angle_1 = require(\"./S1Angle\");\nvar decimal_1 = require('./decimal');\n/**\n * This class contains various utility functions related to edges. It collects\n * together common code that is needed to implement polygonal geometry such as\n * polylines, loops, and general polygons.\n *\n */\nvar S2EdgeUtil = (function () {\n    function S2EdgeUtil() {\n    }\n    //   /**\n    //    * IEEE floating-point operations have a maximum error of 0.5 ULPS (units in\n    //    * the last place). For double-precision numbers, this works out to 2**-53\n    //    * (about 1.11e-16) times the magnitude of the result. It is possible to\n    //    * analyze the calculation done by getIntersection() and work out the\n    //    * worst-case rounding error. I have done a rough version of this, and my\n    //    * estimate is that the worst case distance from the intersection point X to\n    //    * the great circle through (a0, a1) is about 12 ULPS, or about 1.3e-15. This\n    //    * needs to be increased by a factor of (1/0.866) to account for the\n    //    * edgeSpliceFraction() in S2PolygonBuilder. Note that the maximum error\n    //    * measured by the unittest in 1,000,000 trials is less than 3e-16.\n    //    */\n    //   public static final S1Angle DEFAULT_INTERSECTION_TOLERANCE = S1Angle.radians(1.5e-15);\n    //\n    //   /**\n    //    * This class allows a vertex chain v0, v1, v2, ... to be efficiently tested\n    //    * for intersection with a given fixed edge AB.\n    //    */\n    //   public static class EdgeCrosser {\n    //   // The fields below are all constant.\n    //\n    //   private final S2Point a;\n    //   private final S2Point b;\n    //   private final S2Point aCrossB;\n    //\n    //   // The fields below are updated for each vertex in the chain.\n    //\n    //   // Previous vertex in the vertex chain.\n    //   private S2Point c;\n    //   // The orientation of the triangle ACB.\n    //   private int acb;\n    //\n    //   /**\n    //    * AB is the given fixed edge, and C is the first vertex of the vertex\n    //    * chain. All parameters must point to fixed storage that persists for the\n    //    * lifetime of the EdgeCrosser object.\n    //    */\n    //   public EdgeCrosser(S2Point a, S2Point b, S2Point c) {\n    //   this.a = a;\n    //   this.b = b;\n    //   this.aCrossB = S2Point.crossProd(a, b);\n    //   restartAt(c);\n    // }\n    //\n    // /**\n    //  * Call this function when your chain 'jumps' to a new place.\n    //  */\n    // public void restartAt(S2Point c) {\n    //   this.c = c;\n    //   this.acb = -S2.robustCCW(this.a, this.b, c, this.aCrossB);\n    // }\n    //\n    // /**\n    //  * This method is equivalent to calling the S2EdgeUtil.robustCrossing()\n    //  * function (defined below) on the edges AB and CD. It returns +1 if there\n    //  * is a crossing, -1 if there is no crossing, and 0 if two points from\n    //  * different edges are the same. Returns 0 or -1 if either edge is\n    //  * degenerate. As a side effect, it saves vertex D to be used as the next\n    //  * vertex C.\n    //  */\n    // public int robustCrossing(S2Point d) {\n    //   // For there to be an edge crossing, the triangles ACB, CBD, BDA, DAC must\n    //   // all be oriented the same way (CW or CCW). We keep the orientation\n    //   // of ACB as part of our state. When each new point D arrives, we\n    //   // compute the orientation of BDA and check whether it matches ACB.\n    //   // This checks whether the points C and D are on opposite sides of the\n    //   // great circle through AB.\n    //\n    //   // Recall that robustCCW is invariant with respect to rotating its\n    //   // arguments, i.e. ABC has the same orientation as BDA.\n    //   int bda = S2.robustCCW(this.a, this.b, d, this.aCrossB);\n    //   int result;\n    //\n    //   if (bda == -this.acb && bda != 0) {\n    //     // Most common case -- triangles have opposite orientations.\n    //     result = -1;\n    //   } else if ((bda & this.acb) == 0) {\n    //     // At least one value is zero -- two vertices are identical.\n    //     result = 0;\n    //   } else {\n    //     // assert (bda == acb && bda != 0);\n    //     result = robustCrossingInternal(d); // Slow path.\n    //   }\n    //   // Now save the current vertex D as the next vertex C, and also save the\n    //   // orientation of the new triangle ACB (which is opposite to the current\n    //   // triangle BDA).\n    //   this.c = d;\n    //   this.acb = -bda;\n    //   return result;\n    // }\n    //\n    // /**\n    //  * This method is equivalent to the S2EdgeUtil.edgeOrVertexCrossing() method\n    //  * defined below. It is similar to robustCrossing, but handles cases where\n    //  * two vertices are identical in a way that makes it easy to implement\n    //  * point-in-polygon containment tests.\n    //  */\n    // public boolean edgeOrVertexCrossing(S2Point d) {\n    //   // We need to copy c since it is clobbered by robustCrossing().\n    //   S2Point c2 = new S2Point(this.c.get(0), this.c.get(1), this.c.get(2));\n    //\n    //   int crossing = robustCrossing(d);\n    //   if (crossing < 0) {\n    //     return false;\n    //   }\n    //   if (crossing > 0) {\n    //     return true;\n    //   }\n    //\n    //   return vertexCrossing(this.a, this.b, c2, d);\n    // }\n    //\n    // /**\n    //  * This function handles the \"slow path\" of robustCrossing().\n    //  */\n    // private int robustCrossingInternal(S2Point d) {\n    //   // ACB and BDA have the appropriate orientations, so now we check the\n    //   // triangles CBD and DAC.\n    //   S2Point cCrossD = S2Point.crossProd(this.c, d);\n    //   int cbd = -S2.robustCCW(this.c, d, this.b, cCrossD);\n    //   if (cbd != this.acb) {\n    //     return -1;\n    //   }\n    //\n    //   int dac = S2.robustCCW(this.c, d, this.a, cCrossD);\n    //   return (dac == this.acb) ? 1 : -1;\n    // }\n    // }\n    //\n    // /**\n    //  * This class computes a bounding rectangle that contains all edges defined by\n    //  * a vertex chain v0, v1, v2, ... All vertices must be unit length. Note that\n    //  * the bounding rectangle of an edge can be larger than the bounding rectangle\n    //  * of its endpoints, e.g. consider an edge that passes through the north pole.\n    //  */\n    // public static class RectBounder {\n    //   // The previous vertex in the chain.\n    //   private S2Point a;\n    //\n    //   // The corresponding latitude-longitude.\n    //   private S2LatLng aLatLng;\n    //\n    //   // The current bounding rectangle.\n    //   private S2LatLngRect bound;\n    //\n    //   public RectBounder() {\n    //     this.bound = S2LatLngRect.empty();\n    //   }\n    //\n    //   /**\n    //    * This method is called to add each vertex to the chain. 'b' must point to\n    //    * fixed storage that persists for the lifetime of the RectBounder.\n    //    */\n    //   public void addPoint(S2Point b) {\n    //   // assert (S2.isUnitLength(b));\n    //\n    //   S2LatLng bLatLng = new S2LatLng(b);\n    //\n    //   if (this.bound.isEmpty()) {\n    //   this.bound = this.bound.addPoint(bLatLng);\n    // } else {\n    //   // We can't just call bound.addPoint(bLatLng) here, since we need to\n    //   // ensure that all the longitudes between \"a\" and \"b\" are included.\n    //   this.bound = this.bound.union(S2LatLngRect.fromPointPair(this.aLatLng, bLatLng));\n    //\n    //   // Check whether the min/max latitude occurs in the edge interior.\n    //   // We find the normal to the plane containing AB, and then a vector\n    //   // \"dir\" in this plane that also passes through the equator. We use\n    //   // RobustCrossProd to ensure that the edge normal is accurate even\n    //   // when the two points are very close together.\n    //   S2Point aCrossB = S2.robustCrossProd(this.a, b);\n    //   S2Point dir = S2Point.crossProd(aCrossB, new S2Point(0, 0, 1));\n    //   double da = dir.dotProd(this.a);\n    //   double db = dir.dotProd(b);\n    //\n    //   if (da * db < 0) {\n    //     // Minimum/maximum latitude occurs in the edge interior. This affects\n    //     // the latitude bounds but not the longitude bounds.\n    //     double absLat = Math.acos(Math.abs(aCrossB.get(2) / aCrossB.norm()));\n    //     R1Interval lat = this.bound.lat();\n    //     if (da < 0) {\n    //       // It's possible that absLat < lat.lo() due to numerical errors.\n    //       lat = new R1Interval(lat.lo(), Math.max(absLat, this.bound.lat().hi()));\n    //     } else {\n    //       lat = new R1Interval(Math.min(-absLat, this.bound.lat().lo()), lat.hi());\n    //     }\n    //     this.bound = new S2LatLngRect(lat, this.bound.lng());\n    //   }\n    // }\n    // this.a = b;\n    // this.aLatLng = bLatLng;\n    // }\n    //\n    // /**\n    //  * Return the bounding rectangle of the edge chain that connects the\n    //  * vertices defined so far.\n    //  */\n    // public S2LatLngRect getBound() {\n    //   return this.bound;\n    // }\n    //\n    // }\n    //\n    // /**\n    //  * The purpose of this class is to find edges that intersect a given XYZ\n    //  * bounding box. It can be used as an efficient rejection test when attempting to\n    //  * find edges that intersect a given region. It accepts a vertex chain v0, v1,\n    //  * v2, ... and returns a boolean value indicating whether each edge intersects\n    //  * the specified bounding box.\n    //  *\n    //  * We use XYZ intervals instead of something like longitude intervals because\n    //  * it is cheap to collect from S2Point lists and any slicing strategy should\n    //  * give essentially equivalent results.  See S2Loop for an example of use.\n    //  */\n    // public static class XYZPruner {\n    //   private S2Point lastVertex;\n    //\n    //   // The region to be tested against.\n    //   private boolean boundSet;\n    //   private double xmin;\n    //   private double ymin;\n    //   private double zmin;\n    //   private double xmax;\n    //   private double ymax;\n    //   private double zmax;\n    //   private double maxDeformation;\n    //\n    //   public XYZPruner() {\n    //     this.boundSet = false;\n    //   }\n    //\n    //   /**\n    //    * Accumulate a bounding rectangle from provided edges.\n    //    *\n    //    * @param from start of edge\n    //    * @param to end of edge.\n    //    */\n    //   public void addEdgeToBounds(S2Point from, S2Point to) {\n    //   if (!this.boundSet) {\n    //   this.boundSet = true;\n    //   this.xmin = this.xmax = from.x;\n    //   this.ymin = this.ymax = from.y;\n    //   this.zmin = this.zmax = from.z;\n    // }\n    // this.xmin = Math.min(this.xmin, Math.min(to.x, from.x));\n    // this.ymin = Math.min(this.ymin, Math.min(to.y, from.y));\n    // this.zmin = Math.min(this.zmin, Math.min(to.z, from.z));\n    // this.xmax = Math.max(this.xmax, Math.max(to.x, from.x));\n    // this.ymax = Math.max(this.ymax, Math.max(to.y, from.y));\n    // this.zmax = Math.max(this.zmax, Math.max(to.z, from.z));\n    //\n    // // Because our arcs are really geodesics on the surface of the earth\n    // // an edge can have intermediate points outside the xyz bounds implicit\n    // // in the end points.  Based on the length of the arc we compute a\n    // // generous bound for the maximum amount of deformation.  For small edges\n    // // it will be very small but for some large arcs (ie. from (1N,90W) to\n    // // (1N,90E) the path can be wildly deformed.  I did a bunch of\n    // // experiments with geodesics to get safe bounds for the deformation.\n    // double approxArcLen =\n    //     Math.abs(from.x - to.x) + Math.abs(from.y - to.y) + Math.abs(from.z - to.z);\n    // if (approxArcLen < 0.025) { // less than 2 degrees\n    //   this.maxDeformation = Math.max(this.maxDeformation, approxArcLen * 0.0025);\n    // } else if (approxArcLen < 1.0) { // less than 90 degrees\n    //   this.maxDeformation = Math.max(this.maxDeformation, approxArcLen * 0.11);\n    // } else {\n    //   this.maxDeformation = approxArcLen * 0.5;\n    // }\n    // }\n    //\n    // public void setFirstIntersectPoint(S2Point v0) {\n    //   this.xmin = this.xmin - this.maxDeformation;\n    //   this.ymin = this.ymin - this.maxDeformation;\n    //   this.zmin = this.zmin - this.maxDeformation;\n    //   this.xmax = this.xmax + this.maxDeformation;\n    //   this.ymax = this.ymax + this.maxDeformation;\n    //   this.zmax = this.zmax + this.maxDeformation;\n    //   this.lastVertex = v0;\n    // }\n    //\n    // /**\n    //  * Returns true if the edge going from the last point to this point passes\n    //  * through the pruner bounding box, otherwise returns false.  So the\n    //  * method returns false if we are certain there is no intersection, but it\n    //  * may return true when there turns out to be no intersection.\n    //  */\n    // public boolean intersects(S2Point v1) {\n    //   boolean result = true;\n    //\n    //   if ((v1.x < this.xmin && this.lastVertex.x < this.xmin) || (v1.x > this.xmax && this.lastVertex.x > this.xmax)) {\n    //     result = false;\n    //   } else if ((v1.y < this.ymin && this.lastVertex.y < this.ymin) || (v1.y > this.ymax && this.lastVertex.y > this.ymax)) {\n    //     result = false;\n    //   } else if ((v1.z < this.zmin && this.lastVertex.z < this.zmin) || (v1.z > this.zmax && this.lastVertex.z > this.zmax)) {\n    //     result = false;\n    //   }\n    //\n    //   this.lastVertex = v1;\n    //   return result;\n    // }\n    // }\n    //\n    // /**\n    //  * The purpose of this class is to find edges that intersect a given longitude\n    //  * interval. It can be used as an efficient rejection test when attempting to\n    //  * find edges that intersect a given region. It accepts a vertex chain v0, v1,\n    //  * v2, ... and returns a boolean value indicating whether each edge intersects\n    //  * the specified longitude interval.\n    //  *\n    //  * This class is not currently used as the XYZPruner is preferred for\n    //  * S2Loop, but this should be usable in similar circumstances.  Be wary\n    //  * of the cost of atan2() in conversions from S2Point to longitude!\n    //  */\n    // public static class LongitudePruner {\n    //   // The interval to be tested against.\n    //   private S1Interval interval;\n    //\n    //   // The longitude of the next v0.\n    //   private double lng0;\n    //\n    //   /**\n    //    *'interval' is the longitude interval to be tested against, and 'v0' is\n    //    * the first vertex of edge chain.\n    //    */\n    //   public LongitudePruner(S1Interval interval, S2Point v0) {\n    //   this.interval = interval;\n    //   this.lng0 = S2LatLng.longitude(v0).radians();\n    // }\n    //\n    // /**\n    //  * Returns true if the edge (v0, v1) intersects the given longitude\n    //  * interval, and then saves 'v1' to be used as the next 'v0'.\n    //  */\n    // public boolean intersects(S2Point v1) {\n    //   double lng1 = S2LatLng.longitude(v1).radians();\n    //   boolean result = this.interval.intersects(S1Interval.fromPointPair(this.lng0, lng1));\n    //   this.lng0 = lng1;\n    //   return result;\n    // }\n    // }\n    //\n    // /**\n    //  * A wedge relation's test method accepts two edge chains A=(a0,a1,a2) and\n    //  * B=(b0,b1,b2) where a1==b1, and returns either -1, 0, or 1 to indicate the\n    //  * relationship between the region to the left of A and the region to the left\n    //  * of B. Wedge relations are used to determine the local relationship between\n    //  * two polygons that share a common vertex.\n    //  *\n    //  *  All wedge relations require that a0 != a2 and b0 != b2. Other degenerate\n    //  * cases (such as a0 == b2) are handled as expected. The parameter \"ab1\"\n    //  * denotes the common vertex a1 == b1.\n    //  */\n    // public interface WedgeRelation {\n    //   int test(S2Point a0, S2Point ab1, S2Point a2, S2Point b0, S2Point b2);\n    // }\n    //\n    // public static class WedgeContains implements WedgeRelation {\n    //   /**\n    //    * Given two edge chains (see WedgeRelation above), this function returns +1\n    //    * if the region to the left of A contains the region to the left of B, and\n    //    * 0 otherwise.\n    //    */\n    //   @Override\n    //   public int test(S2Point a0, S2Point ab1, S2Point a2, S2Point b0, S2Point b2) {\n    //   // For A to contain B (where each loop interior is defined to be its left\n    //   // side), the CCW edge order around ab1 must be a2 b2 b0 a0. We split\n    //   // this test into two parts that test three vertices each.\n    //   return S2.orderedCCW(a2, b2, b0, ab1) && S2.orderedCCW(b0, a0, a2, ab1) ? 1 : 0;\n    // }\n    // }\n    //\n    // public static class WedgeIntersects implements WedgeRelation {\n    //   /**\n    //    * Given two edge chains (see WedgeRelation above), this function returns -1\n    //    * if the region to the left of A intersects the region to the left of B,\n    //    * and 0 otherwise. Note that regions are defined such that points along a\n    //    * boundary are contained by one side or the other, not both. So for\n    //    * example, if A,B,C are distinct points ordered CCW around a vertex O, then\n    //    * the wedges BOA, AOC, and COB do not intersect.\n    //    */\n    //   @Override\n    //   public int test(S2Point a0, S2Point ab1, S2Point a2, S2Point b0, S2Point b2) {\n    //   // For A not to intersect B (where each loop interior is defined to be\n    //   // its left side), the CCW edge order around ab1 must be a0 b2 b0 a2.\n    //   // Note that it's important to write these conditions as negatives\n    //   // (!OrderedCCW(a,b,c,o) rather than Ordered(c,b,a,o)) to get correct\n    //   // results when two vertices are the same.\n    //   return (S2.orderedCCW(a0, b2, b0, ab1) && S2.orderedCCW(b0, a2, a0, ab1) ? 0 : -1);\n    // }\n    // }\n    //\n    // public static class WedgeContainsOrIntersects implements WedgeRelation {\n    //   /**\n    //    * Given two edge chains (see WedgeRelation above), this function returns +1\n    //    * if A contains B, 0 if A and B are disjoint, and -1 if A intersects but\n    //    * does not contain B.\n    //    */\n    //   @Override\n    //   public int test(S2Point a0, S2Point ab1, S2Point a2, S2Point b0, S2Point b2) {\n    //   // This is similar to WedgeContainsOrCrosses, except that we want to\n    //   // distinguish cases (1) [A contains B], (3) [A and B are disjoint],\n    //   // and (2,4,5,6) [A intersects but does not contain B].\n    //\n    //   if (S2.orderedCCW(a0, a2, b2, ab1)) {\n    //   // We are in case 1, 5, or 6, or case 2 if a2 == b2.\n    //   return S2.orderedCCW(b2, b0, a0, ab1) ? 1 : -1; // Case 1 vs. 2,5,6.\n    // }\n    // // We are in cases 2, 3, or 4.\n    // if (!S2.orderedCCW(a2, b0, b2, ab1)) {\n    //   return 0; // Case 3.\n    // }\n    //\n    // // We are in case 2 or 4, or case 3 if a2 == b0.\n    // return (a2.equals(b0)) ? 0 : -1; // Case 3 vs. 2,4.\n    // }\n    // }\n    //\n    // public static class WedgeContainsOrCrosses implements WedgeRelation {\n    //   /**\n    //    * Given two edge chains (see WedgeRelation above), this function returns +1\n    //    * if A contains B, 0 if B contains A or the two wedges do not intersect,\n    //    * and -1 if the edge chains A and B cross each other (i.e. if A intersects\n    //    * both the interior and exterior of the region to the left of B). In\n    //    * degenerate cases where more than one of these conditions is satisfied,\n    //    * the maximum possible result is returned. For example, if A == B then the\n    //    * result is +1.\n    //    */\n    //   @Override\n    //   public int test(S2Point a0, S2Point ab1, S2Point a2, S2Point b0, S2Point b2) {\n    //   // There are 6 possible edge orderings at a shared vertex (all\n    //   // of these orderings are circular, i.e. abcd == bcda):\n    //   //\n    //   // (1) a2 b2 b0 a0: A contains B\n    //   // (2) a2 a0 b0 b2: B contains A\n    //   // (3) a2 a0 b2 b0: A and B are disjoint\n    //   // (4) a2 b0 a0 b2: A and B intersect in one wedge\n    //   // (5) a2 b2 a0 b0: A and B intersect in one wedge\n    //   // (6) a2 b0 b2 a0: A and B intersect in two wedges\n    //   //\n    //   // In cases (4-6), the boundaries of A and B cross (i.e. the boundary\n    //   // of A intersects the interior and exterior of B and vice versa).\n    //   // Thus we want to distinguish cases (1), (2-3), and (4-6).\n    //   //\n    //   // Note that the vertices may satisfy more than one of the edge\n    //   // orderings above if two or more vertices are the same. The tests\n    //   // below are written so that we take the most favorable\n    //   // interpretation, i.e. preferring (1) over (2-3) over (4-6). In\n    //   // particular note that if orderedCCW(a,b,c,o) returns true, it may be\n    //   // possible that orderedCCW(c,b,a,o) is also true (if a == b or b == c).\n    //\n    //   if (S2.orderedCCW(a0, a2, b2, ab1)) {\n    //   // The cases with this vertex ordering are 1, 5, and 6,\n    //   // although case 2 is also possible if a2 == b2.\n    //   if (S2.orderedCCW(b2, b0, a0, ab1)) {\n    //   return 1; // Case 1 (A contains B)\n    // }\n    //\n    // // We are in case 5 or 6, or case 2 if a2 == b2.\n    // return (a2.equals(b2)) ? 0 : -1; // Case 2 vs. 5,6.\n    // }\n    // // We are in case 2, 3, or 4.\n    // return S2.orderedCCW(a0, b0, a2, ab1) ? 0 : -1; // Case 2,3 vs. 4.\n    // }\n    // }\n    //\n    // /**\n    //  * Return true if edge AB crosses CD at a point that is interior to both\n    //  * edges. Properties:\n    //  *\n    //  *  (1) simpleCrossing(b,a,c,d) == simpleCrossing(a,b,c,d) (2)\n    //  * simpleCrossing(c,d,a,b) == simpleCrossing(a,b,c,d)\n    //  */\n    // public static boolean simpleCrossing(S2Point a, S2Point b, S2Point c, S2Point d) {\n    //   // We compute simpleCCW() for triangles ACB, CBD, BDA, and DAC. All\n    //   // of these triangles need to have the same orientation (CW or CCW)\n    //   // for an intersection to exist. Note that this is slightly more\n    //   // restrictive than the corresponding definition for planar edges,\n    //   // since we need to exclude pairs of line segments that would\n    //   // otherwise \"intersect\" by crossing two antipodal points.\n    //\n    //   S2Point ab = S2Point.crossProd(a, b);\n    //   double acb = -(ab.dotProd(c));\n    //   double bda = ab.dotProd(d);\n    //   if (acb * bda <= 0) {\n    //     return false;\n    //   }\n    //\n    //   S2Point cd = S2Point.crossProd(c, d);\n    //   double cbd = -(cd.dotProd(b));\n    //   double dac = cd.dotProd(a);\n    //   return (acb * cbd > 0) && (acb * dac > 0);\n    // }\n    //\n    // /**\n    //  * Like SimpleCrossing, except that points that lie exactly on a line are\n    //  * arbitrarily classified as being on one side or the other (according to the\n    //  * rules of S2.robustCCW). It returns +1 if there is a crossing, -1 if there\n    //  * is no crossing, and 0 if any two vertices from different edges are the\n    //  * same. Returns 0 or -1 if either edge is degenerate. Properties of\n    //  * robustCrossing:\n    //  *\n    //  *  (1) robustCrossing(b,a,c,d) == robustCrossing(a,b,c,d) (2)\n    //  * robustCrossing(c,d,a,b) == robustCrossing(a,b,c,d) (3)\n    //  * robustCrossing(a,b,c,d) == 0 if a==c, a==d, b==c, b==d (3)\n    //  * robustCrossing(a,b,c,d) <= 0 if a==b or c==d\n    //  *\n    //  *  Note that if you want to check an edge against a *chain* of other edges,\n    //  * it is much more efficient to use an EdgeCrosser (above).\n    //  */\n    // public static int robustCrossing(S2Point a, S2Point b, S2Point c, S2Point d) {\n    //   // For there to be a crossing, the triangles ACB, CBD, BDA, DAC must\n    //   // all have the same orientation (clockwise or counterclockwise).\n    //   //\n    //   // First we compute the orientation of ACB and BDA. We permute the\n    //   // arguments to robustCCW so that we can reuse the cross-product of A and B.\n    //   // Recall that when the arguments to robustCCW are permuted, the sign of the\n    //   // result changes according to the sign of the permutation. Thus ACB and\n    //   // ABC are oppositely oriented, while BDA and ABD are the same.\n    //   S2Point aCrossB = S2Point.crossProd(a, b);\n    //   int acb = -S2.robustCCW(a, b, c, aCrossB);\n    //   int bda = S2.robustCCW(a, b, d, aCrossB);\n    //\n    //   // If any two vertices are the same, the result is degenerate.\n    //   if ((bda & acb) == 0) {\n    //     return 0;\n    //   }\n    //\n    //   // If ABC and BDA have opposite orientations (the most common case),\n    //   // there is no crossing.\n    //   if (bda != acb) {\n    //     return -1;\n    //   }\n    //\n    //   // Otherwise we compute the orientations of CBD and DAC, and check whether\n    //   // their orientations are compatible with the other two triangles.\n    //   S2Point cCrossD = S2Point.crossProd(c, d);\n    //   int cbd = -S2.robustCCW(c, d, b, cCrossD);\n    //   if (cbd != acb) {\n    //     return -1;\n    //   }\n    //\n    //   int dac = S2.robustCCW(c, d, a, cCrossD);\n    //   return (dac == acb) ? 1 : -1;\n    // }\n    //\n    // /**\n    //  * Given two edges AB and CD where at least two vertices are identical (i.e.\n    //  * robustCrossing(a,b,c,d) == 0), this function defines whether the two edges\n    //  * \"cross\" in a such a way that point-in-polygon containment tests can be\n    //  * implemented by counting the number of edge crossings. The basic rule is\n    //  * that a \"crossing\" occurs if AB is encountered after CD during a CCW sweep\n    //  * around the shared vertex starting from a fixed reference point.\n    //  *\n    //  *  Note that according to this rule, if AB crosses CD then in general CD does\n    //  * not cross AB. However, this leads to the correct result when counting\n    //  * polygon edge crossings. For example, suppose that A,B,C are three\n    //  * consecutive vertices of a CCW polygon. If we now consider the edge\n    //  * crossings of a segment BP as P sweeps around B, the crossing number changes\n    //  * parity exactly when BP crosses BA or BC.\n    //  *\n    //  *  Useful properties of VertexCrossing (VC):\n    //  *\n    //  *  (1) VC(a,a,c,d) == VC(a,b,c,c) == false (2) VC(a,b,a,b) == VC(a,b,b,a) ==\n    //  * true (3) VC(a,b,c,d) == VC(a,b,d,c) == VC(b,a,c,d) == VC(b,a,d,c) (3) If\n    //  * exactly one of a,b equals one of c,d, then exactly one of VC(a,b,c,d) and\n    //  * VC(c,d,a,b) is true\n    //  *\n    //  * It is an error to call this method with 4 distinct vertices.\n    //  */\n    // public static boolean vertexCrossing(S2Point a, S2Point b, S2Point c, S2Point d) {\n    //   // If A == B or C == D there is no intersection. We need to check this\n    //   // case first in case 3 or more input points are identical.\n    //   if (a.equals(b) || c.equals(d)) {\n    //     return false;\n    //   }\n    //\n    //   // If any other pair of vertices is equal, there is a crossing if and only\n    //   // if orderedCCW() indicates that the edge AB is further CCW around the\n    //   // shared vertex than the edge CD.\n    //   if (a.equals(d)) {\n    //     return S2.orderedCCW(S2.ortho(a), c, b, a);\n    //   }\n    //   if (b.equals(c)) {\n    //     return S2.orderedCCW(S2.ortho(b), d, a, b);\n    //   }\n    //   if (a.equals(c)) {\n    //     return S2.orderedCCW(S2.ortho(a), d, b, a);\n    //   }\n    //   if (b.equals(d)) {\n    //     return S2.orderedCCW(S2.ortho(b), c, a, b);\n    //   }\n    //\n    //   // assert (false);\n    //   return false;\n    // }\n    //\n    // /**\n    //  * A convenience function that calls robustCrossing() to handle cases where\n    //  * all four vertices are distinct, and VertexCrossing() to handle cases where\n    //  * two or more vertices are the same. This defines a crossing function such\n    //  * that point-in-polygon containment tests can be implemented by simply\n    //  * counting edge crossings.\n    //  */\n    // public static boolean edgeOrVertexCrossing(S2Point a, S2Point b, S2Point c, S2Point d) {\n    //   int crossing = robustCrossing(a, b, c, d);\n    //   if (crossing < 0) {\n    //     return false;\n    //   }\n    //   if (crossing > 0) {\n    //     return true;\n    //   }\n    //   return vertexCrossing(a, b, c, d);\n    // }\n    //\n    // static class CloserResult {\n    //   private double dmin2;\n    //   private S2Point vmin;\n    //\n    //   public double getDmin2() {\n    //   return this.dmin2;\n    // }\n    //\n    //   public S2Point getVmin() {\n    //   return this.vmin;\n    // }\n    //\n    //   public CloserResult(double dmin2, S2Point vmin) {\n    //   this.dmin2 = dmin2;\n    //   this.vmin = vmin;\n    // }\n    //\n    // public void replaceIfCloser(S2Point x, S2Point y) {\n    //   // If the squared distance from x to y is less than dmin2, then replace\n    //   // vmin by y and update dmin2 accordingly.\n    //   double d2 = S2Point.minus(x, y).norm2();\n    //   if (d2 < this.dmin2 || (d2 == this.dmin2 && y.lessThan(this.vmin))) {\n    //     this.dmin2 = d2;\n    //     this.vmin = y;\n    //   }\n    // }\n    // }\n    //\n    // /*\n    //  * Given two edges AB and CD such that robustCrossing() is true, return their\n    //  * intersection point. Useful properties of getIntersection (GI):\n    //  *\n    //  * (1) GI(b,a,c,d) == GI(a,b,d,c) == GI(a,b,c,d) (2) GI(c,d,a,b) ==\n    //  * GI(a,b,c,d)\n    //  *\n    //  * The returned intersection point X is guaranteed to be close to the edges AB\n    //  * and CD, but if the edges intersect at a very small angle then X may not be\n    //  * close to the true mathematical intersection point P. See the description of\n    //  * \"DEFAULT_INTERSECTION_TOLERANCE\" below for details.\n    //  */\n    // public static S2Point getIntersection(S2Point a0, S2Point a1, S2Point b0, S2Point b1) {\n    //   Preconditions.checkArgument(robustCrossing(a0, a1, b0, b1) > 0,\n    //       \"Input edges a0a1 and b0b1 muct have a true robustCrossing.\");\n    //\n    //   // We use robustCrossProd() to get accurate results even when two endpoints\n    //   // are close together, or when the two line segments are nearly parallel.\n    //   S2Point aNorm = S2Point.normalize(S2.robustCrossProd(a0, a1));\n    //   S2Point bNorm = S2Point.normalize(S2.robustCrossProd(b0, b1));\n    //   S2Point x = S2Point.normalize(S2.robustCrossProd(aNorm, bNorm));\n    //\n    //   // Make sure the intersection point is on the correct side of the sphere.\n    //   // Since all vertices are unit length, and edges are less than 180 degrees,\n    //   // (a0 + a1) and (b0 + b1) both have positive dot product with the\n    //   // intersection point. We use the sum of all vertices to make sure that the\n    //   // result is unchanged when the edges are reversed or exchanged.\n    //   if (x.dotProd(S2Point.add(S2Point.add(a0, a1), S2Point.add(b0, b1))) < 0) {\n    //     x = S2Point.neg(x);\n    //   }\n    //\n    //   // The calculation above is sufficient to ensure that \"x\" is within\n    //   // DEFAULT_INTERSECTION_TOLERANCE of the great circles through (a0,a1) and\n    //   // (b0,b1).\n    //   // However, if these two great circles are very close to parallel, it is\n    //   // possible that \"x\" does not lie between the endpoints of the given line\n    //   // segments. In other words, \"x\" might be on the great circle through\n    //   // (a0,a1) but outside the range covered by (a0,a1). In this case we do\n    //   // additional clipping to ensure that it does.\n    //\n    //   if (S2.orderedCCW(a0, x, a1, aNorm) && S2.orderedCCW(b0, x, b1, bNorm)) {\n    //     return x;\n    //   }\n    //\n    //   // Find the acceptable endpoint closest to x and return it. An endpoint is\n    //   // acceptable if it lies between the endpoints of the other line segment.\n    //   CloserResult r = new CloserResult(10, x);\n    //   if (S2.orderedCCW(b0, a0, b1, bNorm)) {\n    //     r.replaceIfCloser(x, a0);\n    //   }\n    //   if (S2.orderedCCW(b0, a1, b1, bNorm)) {\n    //     r.replaceIfCloser(x, a1);\n    //   }\n    //   if (S2.orderedCCW(a0, b0, a1, aNorm)) {\n    //     r.replaceIfCloser(x, b0);\n    //   }\n    //   if (S2.orderedCCW(a0, b1, a1, aNorm)) {\n    //     r.replaceIfCloser(x, b1);\n    //   }\n    //   return r.getVmin();\n    // }\n    //\n    // /**\n    //  * Given a point X and an edge AB, return the distance ratio AX / (AX + BX).\n    //  * If X happens to be on the line segment AB, this is the fraction \"t\" such\n    //  * that X == Interpolate(A, B, t). Requires that A and B are distinct.\n    //  */\n    // public static double getDistanceFraction(S2Point x, S2Point a0, S2Point a1) {\n    //   Preconditions.checkArgument(!a0.equals(a1));\n    //   double d0 = x.angle(a0);\n    //   double d1 = x.angle(a1);\n    //   return d0 / (d0 + d1);\n    // }\n    //\n    // /**\n    //  * Return the minimum distance from X to any point on the edge AB. The result\n    //  * is very accurate for small distances but may have some numerical error if\n    //  * the distance is large (approximately Pi/2 or greater). The case A == B is\n    //  * handled correctly. Note: x, a and b must be of unit length. Throws\n    //  * IllegalArgumentException if this is not the case.\n    //  */\n    // public static getDistance(x:S2Point , a:S2Point , b:S2Point ):S1Angle  {\n    //   return this.getDistance(x, a, b, S2.robustCrossProd(a, b));\n    // }\n    /**\n     * A slightly more efficient version of getDistance() where the cross product\n     * of the two endpoints has been precomputed. The cross product does not need\n     * to be normalized, but should be computed using S2.robustCrossProd() for the\n     * most accurate results.\n     */\n    S2EdgeUtil.getDistance = function (x, a, b, aCrossB) {\n        // Preconditions.checkArgument(S2.isUnitLength(x));\n        // Preconditions.checkArgument(S2.isUnitLength(a));\n        // Preconditions.checkArgument(S2.isUnitLength(b));\n        if (aCrossB === void 0) { aCrossB = S2_1.S2.robustCrossProd(a, b); }\n        // There are three cases. If X is located in the spherical wedge defined by\n        // A, B, and the axis A x B, then the closest point is on the segment AB.\n        // Otherwise the closest point is either A or B; the dividing line between\n        // these two cases is the great circle passing through (A x B) and the\n        // midpoint of AB.\n        if (S2_1.S2.simpleCCW(aCrossB, a, x) && S2_1.S2.simpleCCW(x, b, aCrossB)) {\n            // The closest point to X lies on the segment AB. We compute the distance\n            // to the corresponding great circle. The result is accurate for small\n            // distances but not necessarily for large distances (approaching Pi/2).\n            var sinDist = x.dotProd(aCrossB).abs().dividedBy(aCrossB.norm());\n            return new S1Angle_1.S1Angle(decimal_1.Decimal.asin(decimal_1.Decimal.min(1.0, sinDist)));\n        }\n        // Otherwise, the closest point is either A or B. The cheapest method is\n        // just to compute the minimum of the two linear (as opposed to spherical)\n        // distances and convert the result to an angle. Again, this method is\n        // accurate for small but not large distances (approaching Pi).\n        var linearDist2 = decimal_1.Decimal.min(S2Point_1.S2Point.minus(x, a).norm2(), S2Point_1.S2Point.minus(x, b).norm2());\n        return new S1Angle_1.S1Angle(decimal_1.Decimal.asin(decimal_1.Decimal.min(1.0, linearDist2.sqrt().times(0.5))).times(2));\n    };\n    return S2EdgeUtil;\n}());\nexports.S2EdgeUtil = S2EdgeUtil;\n//# sourceMappingURL=S2EdgeUtil.js.map","/*\n * Copyright 2005 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar S1Angle_1 = require(\"./S1Angle\");\nvar S2Point_1 = require(\"./S2Point\");\nvar S2_1 = require(\"./S2\");\nvar decimal_1 = require('./decimal');\n/**\n * This class represents a point on the unit sphere as a pair of\n * latitude-longitude coordinates. Like the rest of the \"geometry\" package, the\n * intent is to represent spherical geometry as a mathematical abstraction, so\n * functions that are specifically related to the Earth's geometry (e.g.\n * easting/northing conversions) should be put elsewhere.\n *\n */\nvar S2LatLng = (function () {\n    function S2LatLng(latRadians, lngRadians) {\n        this.latRadians = S2_1.S2.toDecimal(latRadians);\n        this.lngRadians = S2_1.S2.toDecimal(lngRadians);\n    }\n    Object.defineProperty(S2LatLng.prototype, \"latDegrees\", {\n        get: function () {\n            return new S1Angle_1.S1Angle(this.latRadians).degrees();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(S2LatLng.prototype, \"lngDegrees\", {\n        get: function () {\n            return new S1Angle_1.S1Angle(this.lngRadians).degrees();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Clamps the latitude to the range [-90, 90] degrees, and adds or subtracts\n    // a multiple of 360 degrees to the longitude if necessary to reduce it to\n    // the range [-180, 180].\n    /** Convert an S2LatLng to the equivalent unit-length vector (S2Point). */\n    S2LatLng.prototype.toPoint = function () {\n        var phi = this.latRadians;\n        var theta = this.lngRadians;\n        var cosphi = decimal_1.Decimal.cos(phi);\n        return new S2Point_1.S2Point(decimal_1.Decimal.cos(theta).times(cosphi), decimal_1.Decimal.sin(theta).times(cosphi), decimal_1.Decimal.sin(phi));\n    };\n    /**\n     * Returns a new S2LatLng based on this instance for which {@link #isValid()}\n     * will be {@code true}.\n     * <ul>\n     * <li>Latitude is clipped to the range {@code [-90, 90]}\n     * <li>Longitude is normalized to be in the range {@code [-180, 180]}\n     * </ul>\n     * <p>If the current point is valid then the returned point will have the same\n     * coordinates.\n     */\n    S2LatLng.prototype.normalized = function () {\n        // drem(x, 2 * S2.M_PI) reduces its argument to the range\n        // [-S2.M_PI, S2.M_PI] inclusive, which is what we want here.\n        return new S2LatLng(decimal_1.Decimal.max(-S2_1.S2.M_PI_2, decimal_1.Decimal.min(S2_1.S2.M_PI_2, this.latRadians)), S2_1.S2.IEEEremainder(this.lngRadians, S2_1.S2.toDecimal(2).times(S2_1.S2.M_PI)));\n        // return new S2LatLng(Math.max(-S2.M_PI_2, Math.min(S2.M_PI_2, this.latRadians)),\n        //     S2.IEEEremainder(this.lngRadians, 2 * S2.M_PI));\n    };\n    S2LatLng.fromDegrees = function (latDegrees, lngDegrees) {\n        return new S2LatLng(S1Angle_1.S1Angle.degrees(latDegrees).radians, S1Angle_1.S1Angle.degrees(lngDegrees).radians);\n    };\n    S2LatLng.fromPoint = function (p) {\n        return new S2LatLng(S2LatLng.latitude(p).radians, S2LatLng.longitude(p).radians);\n    };\n    /**\n     * Return true if the latitude is between -90 and 90 degrees inclusive and the\n     * longitude is between -180 and 180 degrees inclusive.\n     */\n    S2LatLng.prototype.isValid = function () {\n        return this.latRadians.abs().lte(S2_1.S2.M_PI_2) &&\n            this.lngRadians.abs().lte(S2_1.S2.M_PI);\n    };\n    /**\n     * Scales this point by the given scaling factor.\n     * Note that there is no guarantee that the new point will be <em>valid</em>.\n     */\n    S2LatLng.prototype.mul = function (m) {\n        return new S2LatLng(this.latRadians.times(m), this.lngRadians.times(m));\n    };\n    S2LatLng.latitude = function (p) {\n        // We use atan2 rather than asin because the input vector is not necessarily\n        // unit length, and atan2 is much more accurate than asin near the poles.\n        return new S1Angle_1.S1Angle(decimal_1.Decimal.atan2(p.z, p.x.pow(2)\n            .plus(p.y.pow(2))\n            .sqrt()));\n    };\n    S2LatLng.longitude = function (p) {\n        // Note that atan2(0, 0) is defined to be zero.\n        return new S1Angle_1.S1Angle(decimal_1.Decimal.atan2(p.y, p.x));\n    };\n    S2LatLng.prototype.equals = function (other) {\n        return other.latRadians === this.latRadians && other.lngRadians === this.lngRadians;\n    };\n    S2LatLng.prototype.pointAtDistance = function (_distanceInKm, _bearingRadians) {\n        var distanceInM = S2_1.S2.toDecimal(_distanceInKm).times(1000);\n        var distanceToRadius = distanceInM.dividedBy(S2LatLng.EARTH_RADIUS_METERS);\n        var bearingRadians = S2_1.S2.toDecimal(_bearingRadians);\n        this.latRadians.sin();\n        distanceToRadius.cos();\n        var newLat = this.latRadians.sin()\n            .times(distanceToRadius.cos())\n            .plus(this.latRadians.cos()\n            .times(distanceToRadius.sin())\n            .times(bearingRadians.cos())).asin();\n        var newLng = this.lngRadians\n            .plus(decimal_1.Decimal.atan2(bearingRadians.sin()\n            .times(distanceToRadius.sin())\n            .times(this.latRadians.cos()), distanceToRadius.cos()\n            .minus(this.latRadians.sin().times(newLat.sin()))));\n        return new S2LatLng(newLat, newLng);\n    };\n    /**\n     * Generates n LatLngs given a distance in km and the number of points wanted.\n     * Generated points will be returned in a Clockwise order starting from North.\n     * @param _distanceInKm\n     * @param nPoints\n     * @returns {S2LatLng[]}\n     */\n    S2LatLng.prototype.pointsAtDistance = function (_distanceInKm, nPoints) {\n        var _this = this;\n        if (nPoints === void 0) { nPoints = 4; }\n        return Array.apply(null, new Array(nPoints)) // create an array filled of undefined!\n            .map(function (p, idx) {\n            return S2_1.S2.toDecimal(360).dividedBy(nPoints).times(idx);\n        })\n            .map(function (bearingDegree) { return S1Angle_1.S1Angle.degrees(bearingDegree).radians; })\n            .map(function (bearingRadians) { return _this.pointAtDistance(_distanceInKm, bearingRadians); });\n    };\n    S2LatLng.prototype.getEarthDistance = function (other) {\n        return this.getDistance(other).radians.times(S2LatLng.EARTH_RADIUS_METERS);\n    };\n    S2LatLng.prototype.getDistance = function (other) {\n        // This implements the Haversine formula, which is numerically stable for\n        // small distances but only gets about 8 digits of precision for very large\n        // distances (e.g. antipodal points). Note that 8 digits is still accurate\n        // to within about 10cm for a sphere the size of the Earth.\n        //\n        // This could be fixed with another sin() and cos() below, but at that point\n        // you might as well just convert both arguments to S2Points and compute the\n        // distance that way (which gives about 15 digits of accuracy for all\n        // distances).\n        var dLat = other.latRadians.minus(this.latRadians).times(0.5).sin();\n        var dLng = other.lngRadians.minus(this.lngRadians).times(0.5).sin();\n        var x = dLat.pow(2)\n            .plus(dLng.pow(2)\n            .times(this.latRadians.cos())\n            .times(other.latRadians.cos()));\n        // double x = dlat * dlat + dlng * dlng * Math.cos(lat1) * Math.cos(lat2);\n        return new S1Angle_1.S1Angle(S2_1.S2.toDecimal(2)\n            .times(decimal_1.Decimal.atan2(x.sqrt(), decimal_1.Decimal.max(0, x.neg().plus(1))\n            .sqrt())));\n        // Return the distance (measured along the surface of the sphere) to the\n        // given S2LatLng. This is mathematically equivalent to:\n        //\n        // S1Angle::FromRadians(ToPoint().Angle(o.ToPoint())\n        //\n        // but this implementation is slightly more efficient.\n    };\n    S2LatLng.prototype.toString = function () {\n        return \"(\" + this.latRadians + \", \" + this.lngRadians + \")\";\n    };\n    S2LatLng.prototype.toStringDegrees = function () {\n        return \"(\" + this.latDegrees + \", \" + this.lngDegrees + \")\";\n    };\n    S2LatLng.prototype.toGEOJSON = function () {\n        return {\n            type: 'Feature',\n            geometry: {\n                type: \"Point\",\n                coordinates: [this.lngDegrees.toNumber(), this.latDegrees.toNumber()]\n            },\n            properties: {}\n        };\n    };\n    /**\n     * Approximate \"effective\" radius of the Earth in meters.\n     */\n    S2LatLng.EARTH_RADIUS_METERS = 6367000.0;\n    /** The center point the lat/lng coordinate system. */\n    S2LatLng.CENTER = new S2LatLng(0.0, 0.0);\n    return S2LatLng;\n}());\nexports.S2LatLng = S2LatLng;\n//# sourceMappingURL=S2LatLng.js.map","\"use strict\";\nvar S1Interval_1 = require(\"./S1Interval\");\nvar R1Interval_1 = require(\"./R1Interval\");\nvar S2LatLng_1 = require(\"./S2LatLng\");\nvar S2_1 = require(\"./S2\");\nvar S2Point_1 = require(\"./S2Point\");\nvar S1Angle_1 = require(\"./S1Angle\");\nvar S2EdgeUtil_1 = require(\"./S2EdgeUtil\");\nvar S2Cap_1 = require(\"./S2Cap\");\nvar decimal_1 = require('./decimal');\nvar S2LatLngRect = (function () {\n    function S2LatLngRect(lat, lng) {\n        this.lat = lat;\n        this.lng = lng;\n    }\n    S2LatLngRect.fromLatLng = function (lo, hi) {\n        return new S2LatLngRect(new R1Interval_1.R1Interval(lo.latRadians, hi.latRadians), new S1Interval_1.S1Interval(lo.lngRadians, hi.lngRadians));\n    };\n    /** The canonical empty rectangle */\n    S2LatLngRect.empty = function () {\n        return new S2LatLngRect(R1Interval_1.R1Interval.empty(), S1Interval_1.S1Interval.empty());\n    };\n    /** The canonical full rectangle. */\n    S2LatLngRect.full = function () {\n        return new S2LatLngRect(S2LatLngRect.fullLat(), S1Interval_1.S1Interval.full());\n    };\n    /** The full allowable range of latitudes. */\n    S2LatLngRect.fullLat = function () {\n        return new R1Interval_1.R1Interval(-S2_1.S2.M_PI_2, S2_1.S2.M_PI_2);\n    };\n    /**\n     * Construct a rectangle from a center point (in lat-lng space) and size in\n     * each dimension. If size.lng is greater than 360 degrees it is clamped,\n     * and latitudes greater than +/- 90 degrees are also clamped. So for example,\n     * FromCenterSize((80,170),(20,20)) -> (lo=(60,150),hi=(90,-170)).\n     */\n    S2LatLngRect.fromCenterSize = function (center, size) {\n        return S2LatLngRect.fromPoint(center).expanded(size.mul(0.5));\n    };\n    /** Convenience method to construct a rectangle containing a single point. */\n    S2LatLngRect.fromPoint = function (p) {\n        // assert (p.isValid());\n        return S2LatLngRect.fromLatLng(p, p);\n    };\n    /**\n     * Convenience method to construct the minimal bounding rectangle containing\n     * the two given points. This is equivalent to starting with an empty\n     * rectangle and calling AddPoint() twice. Note that it is different than the\n     * S2LatLngRect(lo, hi) constructor, where the first point is always used as\n     * the lower-left corner of the resulting rectangle.\n     */\n    S2LatLngRect.fromPointPair = function (p1, p2) {\n        // assert (p1.isValid() && p2.isValid());\n        return new S2LatLngRect(R1Interval_1.R1Interval.fromPointPair(p1.latRadians, p2\n            .latRadians), S1Interval_1.S1Interval.fromPointPair(p1.lngRadians, p2.lngRadians));\n    };\n    /**\n     * Return a latitude-longitude rectangle that contains the edge from \"a\" to\n     * \"b\". Both points must be unit-length. Note that the bounding rectangle of\n     * an edge can be larger than the bounding rectangle of its endpoints.\n     */\n    S2LatLngRect.fromEdge = function (a, b) {\n        // assert (S2.isUnitLength(a) && S2.isUnitLength(b));\n        var r = S2LatLngRect.fromPointPair(S2LatLng_1.S2LatLng.fromPoint(a), S2LatLng_1.S2LatLng.fromPoint(b));\n        // Check whether the min/max latitude occurs in the edge interior.\n        // We find the normal to the plane containing AB, and then a vector \"dir\" in\n        // this plane that also passes through the equator. We use RobustCrossProd\n        // to ensure that the edge normal is accurate even when the two points are\n        // very close together.\n        var ab = S2_1.S2.robustCrossProd(a, b);\n        var dir = S2Point_1.S2Point.crossProd(ab, new S2Point_1.S2Point(0, 0, 1));\n        var da = dir.dotProd(a);\n        var db = dir.dotProd(b);\n        if (da.times(db).gte(0)) {\n            // Minimum and maximum latitude are attained at the vertices.\n            return r;\n        }\n        // Minimum/maximum latitude occurs in the edge interior. This affects the\n        // latitude bounds but not the longitude bounds.\n        var absLat = decimal_1.Decimal.acos(ab.z.dividedBy(ab.norm()).abs());\n        if (da.lt(0)) {\n            return new S2LatLngRect(new R1Interval_1.R1Interval(r.lat.lo, absLat), r.lng);\n        }\n        else {\n            return new S2LatLngRect(new R1Interval_1.R1Interval(-absLat, r.lat.hi), r.lng);\n        }\n    };\n    /**\n     * Return true if the rectangle is valid, which essentially just means that\n     * the latitude bounds do not exceed Pi/2 in absolute value and the longitude\n     * bounds do not exceed Pi in absolute value.\n     *\n     */\n    S2LatLngRect.prototype.isValid = function () {\n        // The lat/lng ranges must either be both empty or both non-empty.\n        return (this.lat.lo.abs().lte(S2_1.S2.M_PI_2) && this.lat.hi.abs().lte(S2_1.S2.M_PI_2)\n            && this.lng.isValid() && this.lat.isEmpty() == this.lng.isEmpty());\n    };\n    S2LatLngRect.prototype.lo = function () {\n        return new S2LatLng_1.S2LatLng(this.lat.lo, this.lng.lo);\n    };\n    S2LatLngRect.prototype.hi = function () {\n        return new S2LatLng_1.S2LatLng(this.lat.hi, this.lng.hi);\n    };\n    /**\n     * Return true if the rectangle is empty, i.e. it contains no points at all.\n     */\n    S2LatLngRect.prototype.isEmpty = function () {\n        return this.lat.isEmpty();\n    };\n    // Return true if the rectangle is full, i.e. it contains all points.\n    S2LatLngRect.prototype.isFull = function () {\n        // console.log(this.lat.toString());\n        // console.log(S2LatLngRect.fullLat().toString());\n        return this.lat.equals(S2LatLngRect.fullLat()) && this.lng.isFull();\n    };\n    /**\n     * Return true if lng_.lo() > lng_.hi(), i.e. the rectangle crosses the 180\n     * degree latitude line.\n     */\n    S2LatLngRect.prototype.isInverted = function () {\n        return this.lng.isInverted();\n    };\n    /** Return the k-th vertex of the rectangle (k = 0,1,2,3) in CCW order. */\n    S2LatLngRect.prototype.getVertex = function (k) {\n        // Return the points in CCW order (SW, SE, NE, NW).\n        switch (k) {\n            case 0:\n                return this.lo();\n            case 1:\n                return new S2LatLng_1.S2LatLng(this.lat.lo, this.lng.hi);\n            case 2:\n                return this.hi();\n            case 3:\n                return new S2LatLng_1.S2LatLng(this.lat.hi, this.lng.lo);\n            default:\n                throw new Error(\"Invalid vertex index.\");\n        }\n    };\n    /**\n     * Return the center of the rectangle in latitude-longitude space (in general\n     * this is not the center of the region on the sphere).\n     */\n    S2LatLngRect.prototype.getCenter = function () {\n        return new S2LatLng_1.S2LatLng(this.lat.getCenter(), this.lng.getCenter());\n    };\n    /**\n     * Return the minimum distance (measured along the surface of the sphere)\n     * from a given point to the rectangle (both its boundary and its interior).\n     * The latLng must be valid.\n     */\n    S2LatLngRect.prototype.getDistanceLL = function (p) {\n        // The algorithm here is the same as in getDistance(S2LagLngRect), only\n        // with simplified calculations.\n        var a = this;\n        if (a.isEmpty()) {\n            throw new Error();\n        }\n        if (!p.isValid()) {\n            throw new Error('point is not valid');\n        }\n        if (a.lng.contains(p.lngRadians)) {\n            return new S1Angle_1.S1Angle(decimal_1.Decimal.max(0.0, decimal_1.Decimal.max(p.latRadians.minus(a.lat.hi), a.lat.lo.minus(p.latRadians))));\n        }\n        var interval = new S1Interval_1.S1Interval(a.lng.hi, a.lng.complement().getCenter());\n        var aLng = a.lng.lo;\n        if (interval.contains(p.lngRadians)) {\n            aLng = a.lng.hi;\n        }\n        var lo = new S2LatLng_1.S2LatLng(a.lat.lo, aLng).toPoint();\n        var hi = new S2LatLng_1.S2LatLng(a.lat.hi, aLng).toPoint();\n        var loCrossHi = new S2LatLng_1.S2LatLng(0, aLng.minus(S2_1.S2.M_PI_2)).normalized().toPoint();\n        return S2EdgeUtil_1.S2EdgeUtil.getDistance(p.toPoint(), lo, hi, loCrossHi);\n    };\n    /**\n     * Return the minimum distance (measured along the surface of the sphere) to\n     * the given S2LatLngRect. Both S2LatLngRects must be non-empty.\n     */\n    S2LatLngRect.prototype.getDistanceLLR = function (other) {\n        var a = this;\n        var b = other;\n        if (a.isEmpty()) {\n            throw new Error();\n        }\n        if (b.isEmpty()) {\n            throw new Error();\n        }\n        // First, handle the trivial cases where the longitude intervals overlap.\n        if (a.lng.intersects(b.lng)) {\n            if (a.lat.intersects(b.lat)) {\n                return new S1Angle_1.S1Angle(0); // Intersection between a and b.\n            }\n            // We found an overlap in the longitude interval, but not in the latitude\n            // interval. This means the shortest path travels along some line of\n            // longitude connecting the high-latitude of the lower rect with the\n            // low-latitude of the higher rect.\n            var lo = void 0, hi = void 0;\n            if (a.lat.lo.gt(b.lat.hi)) {\n                lo = b.lat.hi;\n                hi = a.lat.lo;\n            }\n            else {\n                lo = a.lat.hi;\n                hi = b.lat.lo;\n            }\n            return new S1Angle_1.S1Angle(hi.radians().minus(lo.radians()));\n        }\n        // The longitude intervals don't overlap. In this case, the closest points\n        // occur somewhere on the pair of longitudinal edges which are nearest in\n        // longitude-space.\n        var aLng, bLng;\n        var loHi = S1Interval_1.S1Interval.fromPointPair(a.lng.lo, b.lng.hi);\n        var hiLo = S1Interval_1.S1Interval.fromPointPair(a.lng.hi, b.lng.lo);\n        if (loHi.getLength().lt(hiLo.getLength())) {\n            aLng = a.lng.lo;\n            bLng = b.lng.hi;\n        }\n        else {\n            aLng = a.lng.hi;\n            bLng = b.lng.lo;\n        }\n        // The shortest distance between the two longitudinal segments will include\n        // at least one segment endpoint. We could probably narrow this down further\n        // to a single point-edge distance by comparing the relative latitudes of the\n        // endpoints, but for the sake of clarity, we'll do all four point-edge\n        // distance tests.\n        var aLo = new S2LatLng_1.S2LatLng(a.lat.lo, aLng).toPoint();\n        var aHi = new S2LatLng_1.S2LatLng(a.lat.hi, aLng).toPoint();\n        var aLoCrossHi = new S2LatLng_1.S2LatLng(0, aLng.radians().minus(S2_1.S2.M_PI_2)).normalized().toPoint();\n        var bLo = new S2LatLng_1.S2LatLng(b.lat.lo, bLng).toPoint();\n        var bHi = new S2LatLng_1.S2LatLng(b.lat.hi, bLng).toPoint();\n        var bLoCrossHi = new S2LatLng_1.S2LatLng(0, bLng.radians().minus(S2_1.S2.M_PI_2)).normalized().toPoint();\n        return S1Angle_1.S1Angle.min(S2EdgeUtil_1.S2EdgeUtil.getDistance(aLo, bLo, bHi, bLoCrossHi), S1Angle_1.S1Angle.min(S2EdgeUtil_1.S2EdgeUtil.getDistance(aHi, bLo, bHi, bLoCrossHi), S1Angle_1.S1Angle.min(S2EdgeUtil_1.S2EdgeUtil.getDistance(bLo, aLo, aHi, aLoCrossHi), S2EdgeUtil_1.S2EdgeUtil.getDistance(bHi, aLo, aHi, aLoCrossHi))));\n    };\n    /**\n     * Return the width and height of this rectangle in latitude-longitude space.\n     * Empty rectangles have a negative width and height.\n     */\n    S2LatLngRect.prototype.getSize = function () {\n        return new S2LatLng_1.S2LatLng(this.lat.getLength(), this.lng.getLength());\n    };\n    /**\n     * More efficient version of Contains() that accepts a S2LatLng rather than an\n     * S2Point.\n     */\n    S2LatLngRect.prototype.containsLL = function (ll) {\n        // assert (ll.isValid());\n        return (this.lat.contains(ll.latRadians) && this.lng.contains(ll.lngRadians));\n    };\n    /**\n     * Return true if and only if the given point is contained in the interior of\n     * the region (i.e. the region excluding its boundary). The point 'p' does not\n     * need to be normalized.\n     */\n    S2LatLngRect.prototype.interiorContainsP = function (p) {\n        return this.interiorContainsLL(S2LatLng_1.S2LatLng.fromPoint(p));\n    };\n    /**\n     * More efficient version of InteriorContains() that accepts a S2LatLng rather\n     * than an S2Point.\n     */\n    S2LatLngRect.prototype.interiorContainsLL = function (ll) {\n        // assert (ll.isValid());\n        return (this.lat.interiorContains(ll.latRadians) && this.lng\n            .interiorContains(ll.lngRadians));\n    };\n    /**\n     * Return true if and only if the rectangle contains the given other\n     * rectangle.\n     */\n    S2LatLngRect.prototype.containsLLR = function (other) {\n        return this.lat.containsI(other.lat) && this.lng.containsI(other.lng);\n    };\n    /**\n     * Return true if and only if the interior of this rectangle contains all\n     * points of the given other rectangle (including its boundary).\n     */\n    S2LatLngRect.prototype.interiorContainsLLR = function (other) {\n        return (this.lat.interiorContainsI(other.lat) && this.lng\n            .interiorContainsI(other.lng));\n    };\n    /** Return true if this rectangle and the given other rectangle have any\n     points in common. */\n    S2LatLngRect.prototype.intersectsLLR = function (other) {\n        return this.lat.intersects(other.lat) && this.lng.intersects(other.lng);\n    };\n    /**\n     * Returns true if this rectangle intersects the given cell. (This is an exact\n     * test and may be fairly expensive, see also MayIntersect below.)\n     */\n    S2LatLngRect.prototype.intersects = function (cell) {\n        // First we eliminate the cases where one region completely contains the\n        // other. Once these are disposed of, then the regions will intersect\n        // if and only if their boundaries intersect.\n        if (this.isEmpty()) {\n            return false;\n        }\n        if (this.containsP(cell.getCenter())) {\n            return true;\n        }\n        if (cell.contains(this.getCenter().toPoint())) {\n            return true;\n        }\n        // Quick rejection test (not required for correctness).\n        if (!this.intersectsLLR(cell.getRectBound())) {\n            return false;\n        }\n        // Now check whether the boundaries intersect. Unfortunately, a\n        // latitude-longitude rectangle does not have straight edges -- two edges\n        // are curved, and at least one of them is concave.\n        // Precompute the cell vertices as points and latitude-longitudes.\n        var cellV = new Array(4);\n        var cellLl = new Array(4);\n        for (var i = 0; i < 4; ++i) {\n            cellV[i] = cell.getVertex(i); // Must be normalized.\n            cellLl[i] = S2LatLng_1.S2LatLng.fromPoint(cellV[i]);\n            if (this.containsLL(cellLl[i])) {\n                return true; // Quick acceptance test.\n            }\n        }\n        for (var i = 0; i < 4; ++i) {\n            var edgeLng = S1Interval_1.S1Interval.fromPointPair(cellLl[i].lngRadians, cellLl[(i + 1) & 3].lngRadians);\n            if (!this.lng.intersects(edgeLng)) {\n                continue;\n            }\n            var a = cellV[i];\n            var b = cellV[(i + 1) & 3];\n            if (edgeLng.contains(this.lng.lo)) {\n                if (S2LatLngRect.intersectsLngEdge(a, b, this.lat, this.lng.lo)) {\n                    return true;\n                }\n            }\n            if (edgeLng.contains(this.lng.hi)) {\n                if (S2LatLngRect.intersectsLngEdge(a, b, this.lat, this.lng.hi)) {\n                    return true;\n                }\n            }\n            if (S2LatLngRect.intersectsLatEdge(a, b, this.lat.lo, this.lng)) {\n                return true;\n            }\n            if (S2LatLngRect.intersectsLatEdge(a, b, this.lat.hi, this.lng)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Return true if and only if the interior of this rectangle intersects any\n     * point (including the boundary) of the given other rectangle.\n     */\n    S2LatLngRect.prototype.interiorIntersects = function (other) {\n        return (this.lat.interiorIntersects(other.lat) && this.lng\n            .interiorIntersects(other.lng));\n    };\n    S2LatLngRect.prototype.addPoint = function (p) {\n        return this.addPointLL(S2LatLng_1.S2LatLng.fromPoint(p));\n    };\n    // Increase the size of the bounding rectangle to include the given point.\n    // The rectangle is expanded by the minimum amount possible.\n    S2LatLngRect.prototype.addPointLL = function (ll) {\n        var newLat = this.lat.addPoint(ll.latRadians);\n        var newLng = this.lng.addPoint(ll.lngRadians);\n        return new S2LatLngRect(newLat, newLng);\n    };\n    /**\n     * Return a rectangle that contains all points whose latitude distance from\n     * this rectangle is at most margin.lat, and whose longitude distance from\n     * this rectangle is at most margin.lng. In particular, latitudes are\n     * clamped while longitudes are wrapped. Note that any expansion of an empty\n     * interval remains empty, and both components of the given margin must be\n     * non-negative.\n     *\n     * NOTE: If you are trying to grow a rectangle by a certain *distance* on the\n     * sphere (e.g. 5km), use the ConvolveWithCap() method instead.\n     */\n    S2LatLngRect.prototype.expanded = function (margin) {\n        // assert (margin.latRadians >= 0 && margin.lngRadians >= 0);\n        if (this.isEmpty()) {\n            return this;\n        }\n        return new S2LatLngRect(this.lat\n            .expanded(margin.latRadians)\n            .intersection(S2LatLngRect.fullLat()), this.lng.expanded(margin.lngRadians));\n    };\n    /**\n     * Return the smallest rectangle containing the union of this rectangle and\n     * the given rectangle.\n     */\n    S2LatLngRect.prototype.union = function (other) {\n        return new S2LatLngRect(this.lat.union(other.lat), this.lng.union(other.lng));\n    };\n    /**\n     * Return the smallest rectangle containing the intersection of this rectangle\n     * and the given rectangle. Note that the region of intersection may consist\n     * of two disjoint rectangles, in which case a single rectangle spanning both\n     * of them is returned.\n     */\n    S2LatLngRect.prototype.intersection = function (other) {\n        var intersectLat = this.lat.intersection(other.lat);\n        var intersectLng = this.lng.intersection(other.lng);\n        if (intersectLat.isEmpty() || intersectLng.isEmpty()) {\n            // The lat/lng ranges must either be both empty or both non-empty.\n            return S2LatLngRect.empty();\n        }\n        return new S2LatLngRect(intersectLat, intersectLng);\n    };\n    //\n    // /**\n    //  * Return a rectangle that contains the convolution of this rectangle with a\n    //  * cap of the given angle. This expands the rectangle by a fixed distance (as\n    //  * opposed to growing the rectangle in latitude-longitude space). The returned\n    //  * rectangle includes all points whose minimum distance to the original\n    //  * rectangle is at most the given angle.\n    //  */\n    // public S2LatLngRect convolveWithCap(/*S1Angle*/ angle) {\n    //   // The most straightforward approach is to build a cap centered on each\n    //   // vertex and take the union of all the bounding rectangles (including the\n    //   // original rectangle; this is necessary for very large rectangles).\n    //\n    //   // Optimization: convert the angle to a height exactly once.\n    //   S2Cap cap = S2Cap.fromAxisAngle(new S2Point(1, 0, 0), angle);\n    //\n    //   S2LatLngRect r = this;\n    //   for (int k = 0; k < 4; ++k) {\n    //     S2Cap vertexCap = S2Cap.fromAxisHeight(getVertex(k).toPoint(), cap\n    //         .height());\n    //     r = r.union(vertexCap.getRectBound());\n    //   }\n    //   return r;\n    // }\n    /** Return the surface area of this rectangle on the unit sphere. */\n    S2LatLngRect.prototype.area = function () {\n        if (this.isEmpty()) {\n            return S2_1.S2.toDecimal(0);\n        }\n        // This is the size difference of the two spherical caps, multiplied by\n        // the longitude ratio.\n        //TODO: check if this.lat.hi & this.lat.lo is radians. \n        return this.lng.getLength().times(decimal_1.Decimal.sin(this.lat.hi).minus(decimal_1.Decimal.sin(this.lat.lo)).abs());\n    };\n    /** Return true if two rectangles contains the same set of points. */\n    S2LatLngRect.prototype.equals = function (that) {\n        if (!(that instanceof S2LatLngRect)) {\n            return false;\n        }\n        return this.lat.equals(that.lat) && this.lng.equals(that.lng);\n    };\n    /**\n     * Return true if the latitude and longitude intervals of the two rectangles\n     * are the same up to the given tolerance (see r1interval.h and s1interval.h\n     * for details).\n     */\n    S2LatLngRect.prototype.approxEquals = function (other, maxError) {\n        if (maxError === void 0) { maxError = 1e-15; }\n        return (this.lat.approxEquals(other.lat, maxError) && this.lng.approxEquals(other.lng, maxError));\n    };\n    // //////////////////////////////////////////////////////////////////////\n    // S2Region interface (see {@code S2Region} for details):\n    S2LatLngRect.prototype.clone = function () {\n        return new S2LatLngRect(this.lat, this.lng);\n    };\n    S2LatLngRect.prototype.getCapBound = function () {\n        // We consider two possible bounding caps, one whose axis passes\n        // through the center of the lat-long rectangle and one whose axis\n        // is the north or south pole. We return the smaller of the two caps.\n        if (this.isEmpty()) {\n            return S2Cap_1.S2Cap.empty();\n        }\n        var poleZ, poleAngle;\n        if (this.lat.lo.plus(this.lat.hi).lt(0)) {\n            // South pole axis yields smaller cap.\n            poleZ = -1;\n            poleAngle = this.lat.hi.plus(S2_1.S2.M_PI_2);\n        }\n        else {\n            poleZ = 1;\n            poleAngle = this.lat.lo.neg().plus(S2_1.S2.M_PI_2);\n        }\n        var poleCap = S2Cap_1.S2Cap.fromAxisAngle(new S2Point_1.S2Point(0, 0, poleZ), new S1Angle_1.S1Angle(poleAngle));\n        // For bounding rectangles that span 180 degrees or less in longitude, the\n        // maximum cap size is achieved at one of the rectangle vertices. For\n        // rectangles that are larger than 180 degrees, we punt and always return a\n        // bounding cap centered at one of the two poles.\n        var lngSpan = this.lng.hi.minus(this.lng.lo);\n        if (S2_1.S2.IEEEremainder(lngSpan, 2 * S2_1.S2.M_PI).gte(0)) {\n            if (lngSpan.lt(2 * S2_1.S2.M_PI)) {\n                var midCap = S2Cap_1.S2Cap.fromAxisAngle(this.getCenter().toPoint(), new S1Angle_1.S1Angle(0));\n                for (var k = 0; k < 4; ++k) {\n                    midCap = midCap.addPoint(this.getVertex(k).toPoint());\n                }\n                if (midCap.height.lt(poleCap.height)) {\n                    return midCap;\n                }\n            }\n        }\n        return poleCap;\n    };\n    S2LatLngRect.prototype.getRectBound = function () {\n        return this;\n    };\n    S2LatLngRect.prototype.containsC = function (cell) {\n        // A latitude-longitude rectangle contains a cell if and only if it contains\n        // the cell's bounding rectangle. (This is an exact test.)\n        return this.containsLLR(cell.getRectBound());\n    };\n    /**\n     * This test is cheap but is NOT exact. Use Intersects() if you want a more\n     * accurate and more expensive test. Note that when this method is used by an\n     * S2RegionCoverer, the accuracy isn't all that important since if a cell may\n     * intersect the region then it is subdivided, and the accuracy of this method\n     * goes up as the cells get smaller.\n     */\n    S2LatLngRect.prototype.mayIntersectC = function (cell) {\n        // This test is cheap but is NOT exact (see s2latlngrect.h).\n        return this.intersectsLLR(cell.getRectBound());\n    };\n    /** The point 'p' does not need to be normalized. */\n    S2LatLngRect.prototype.containsP = function (p) {\n        return this.containsLL(S2LatLng_1.S2LatLng.fromPoint(p));\n    };\n    /**\n     * Return true if the edge AB intersects the given edge of constant longitude.\n     */\n    S2LatLngRect.intersectsLngEdge = function (a, b, lat, lng) {\n        // Return true if the segment AB intersects the given edge of constant\n        // longitude. The nice thing about edges of constant longitude is that\n        // they are straight lines on the sphere (geodesics).\n        return S2_1.S2.simpleCrossing(a, b, new S2LatLng_1.S2LatLng(lat.lo, lng)\n            .toPoint(), new S2LatLng_1.S2LatLng(lat.hi, lng).toPoint());\n    };\n    /**\n     * Return true if the edge AB intersects the given edge of constant latitude.\n     */\n    S2LatLngRect.intersectsLatEdge = function (a, b, lat, lng) {\n        // Return true if the segment AB intersects the given edge of constant\n        // latitude. Unfortunately, lines of constant latitude are curves on\n        // the sphere. They can intersect a straight edge in 0, 1, or 2 points.\n        // assert (S2.isUnitLength(a) && S2.isUnitLength(b));\n        // First, compute the normal to the plane AB that points vaguely north.\n        var z = S2Point_1.S2Point.normalize(S2_1.S2.robustCrossProd(a, b));\n        if (z.z.lt(0)) {\n            z = S2Point_1.S2Point.neg(z);\n        }\n        // Extend this to an orthonormal frame (x,y,z) where x is the direction\n        // where the great circle through AB achieves its maximium latitude.\n        var y = S2Point_1.S2Point.normalize(S2_1.S2.robustCrossProd(z, new S2Point_1.S2Point(0, 0, 1)));\n        var x = S2Point_1.S2Point.crossProd(y, z);\n        // assert (S2.isUnitLength(x) && x.z >= 0);\n        // Compute the angle \"theta\" from the x-axis (in the x-y plane defined\n        // above) where the great circle intersects the given line of latitude.\n        var sinLat = decimal_1.Decimal.sin(lat);\n        if (sinLat.abs().gte(x.z)) {\n            return false; // The great circle does not reach the given latitude.\n        }\n        // assert (x.z > 0);\n        var cosTheta = sinLat.dividedBy(x.z);\n        var sinTheta = cosTheta.pow(2).neg().plus(1).sqrt(); // Math.sqrt(1 - cosTheta * cosTheta);\n        var theta = decimal_1.Decimal.atan2(sinTheta, cosTheta);\n        // Math.atan2(sinTheta, cosTheta);\n        // The candidate intersection points are located +/- theta in the x-y\n        // plane. For an intersection to be valid, we need to check that the\n        // intersection point is contained in the interior of the edge AB and\n        // also that it is contained within the given longitude interval \"lng\".\n        // Compute the range of theta values spanned by the edge AB.\n        var abTheta = S1Interval_1.S1Interval.fromPointPair(decimal_1.Decimal.atan2(a.dotProd(y), a.dotProd(x)), decimal_1.Decimal.atan2(b.dotProd(y), b.dotProd(x)));\n        if (abTheta.contains(theta)) {\n            // Check if the intersection point is also in the given \"lng\" interval.\n            var isect = S2Point_1.S2Point.add(S2Point_1.S2Point.mul(x, cosTheta), S2Point_1.S2Point.mul(y, sinTheta));\n            if (lng.contains(decimal_1.Decimal.atan2(isect.y, isect.x))) {\n                return true;\n            }\n        }\n        if (abTheta.contains(theta.neg())) {\n            // Check if the intersection point is also in the given \"lng\" interval.\n            var intersection = S2Point_1.S2Point.sub(S2Point_1.S2Point.mul(x, cosTheta), S2Point_1.S2Point.mul(y, sinTheta));\n            if (lng.contains(decimal_1.Decimal.atan2(intersection.y, intersection.x))) {\n                return true;\n            }\n        }\n        return false;\n    };\n    S2LatLngRect.prototype.allVertex = function () {\n        return [\n            this.getVertex(0),\n            this.getVertex(1),\n            this.getVertex(2),\n            this.getVertex(3)\n        ];\n    };\n    S2LatLngRect.prototype.toGEOJSON = function () {\n        return {\n            type: 'Feature',\n            geometry: {\n                type: 'Polygon',\n                coordinates: [this.allVertex().concat(this.getVertex(0)).map(function (v) { return [parseFloat(v.lngDegrees.toFixed(5)), parseFloat(v.latDegrees.toFixed(5))]; })],\n            },\n            properties: {}\n        };\n    };\n    S2LatLngRect.prototype.toString = function () {\n        return \"[Lo=\" + this.lo().toString() + \", Hi=\" + this.hi().toString() + \"]\";\n    };\n    return S2LatLngRect;\n}());\nexports.S2LatLngRect = S2LatLngRect;\n//# sourceMappingURL=S2LatLngRect.js.map","\"use strict\";\nvar S2_1 = require(\"./S2\");\n/**\n * Defines an area or a length cell metric.\n */\nvar S2Metric = (function () {\n    /**\n     * Defines a cell metric of the given dimension (1 == length, 2 == area).\n     */\n    function S2Metric(_dim, _deriv) {\n        this._dim = S2_1.S2.toDecimal(_dim).toNumber();\n        this._deriv = S2_1.S2.toDecimal(_deriv);\n    }\n    S2Metric.prototype.deriv = function () {\n        return this._deriv;\n    };\n    S2Metric.prototype.dim = function () {\n        return this._dim;\n    };\n    /** Return the value of a metric for cells at the given level. */\n    S2Metric.prototype.getValue = function (level) {\n        return 0;\n        // return StrictMath.scalb(deriv, dim * (1 - level));\n    };\n    /**\n     * Return the level at which the metric has approximately the given value.\n     * For example, S2::kAvgEdge.GetClosestLevel(0.1) returns the level at which\n     * the average cell edge length is approximately 0.1. The return value is\n     * always a valid level.\n     */\n    S2Metric.prototype.getClosestLevel = function (/*double*/ value) {\n        return this.getMinLevel(S2_1.S2.M_SQRT2 * value);\n    };\n    /**\n     * Return the minimum level such that the metric is at most the given value,\n     * or S2CellId::kMaxLevel if there is no such level. For example,\n     * S2::kMaxDiag.GetMinLevel(0.1) returns the minimum level such that all\n     * cell diagonal lengths are 0.1 or smaller. The return value is always a\n     * valid level.\n     */\n    S2Metric.prototype.getMinLevel = function (value /*double*/) {\n        if (value <= 0) {\n            return S2_1.S2.MAX_LEVEL;\n        }\n        // This code is equivalent to computing a floating-point \"level\"\n        // value and rounding up.\n        var exponent = S2_1.S2.exp(value / ((1 << this.dim()) * this.deriv().toNumber()));\n        var level = Math.max(0, Math.min(S2_1.S2.MAX_LEVEL, -((exponent - 1) >> (this.dim() - 1))));\n        // assert (level == S2CellId.MAX_LEVEL || getValue(level) <= value);\n        // assert (level == 0 || getValue(level - 1) > value);\n        return level;\n    };\n    /**\n     * Return the maximum level such that the metric is at least the given\n     * value, or zero if there is no such level. For example,\n     * S2.kMinWidth.GetMaxLevel(0.1) returns the maximum level such that all\n     * cells have a minimum width of 0.1 or larger. The return value is always a\n     * valid level.\n     */\n    S2Metric.prototype.getMaxLevel = function (_value /*double*/) {\n        var value = S2_1.S2.toDecimal(_value).toNumber();\n        if (value <= 0) {\n            return S2_1.S2.MAX_LEVEL;\n        }\n        // This code is equivalent to computing a floating-point \"level\"\n        // value and rounding down.\n        var exponent = S2_1.S2.exp((1 << this.dim()) * this.deriv().toNumber() / value);\n        var level = Math.max(0, Math.min(S2_1.S2.MAX_LEVEL, ((exponent - 1) >> (this.dim() - 1))));\n        // assert (level == 0 || getValue(level) >= value);\n        // assert (level == S2CellId.MAX_LEVEL || getValue(level + 1) < value);\n        return level;\n    };\n    return S2Metric;\n}());\nexports.S2Metric = S2Metric;\n//# sourceMappingURL=S2Metric.js.map","/*\n * Copyright 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar R2Vector_1 = require(\"./R2Vector\");\nvar Decimal = require('decimal.js');\nvar S2_1 = require(\"./S2\");\n///re\n/**\n * An S2Point represents a point on the unit sphere as a 3D vector. Usually\n * points are normalized to be unit length, but some methods do not require\n * this.\n *\n */\nvar S2Point = (function () {\n    function S2Point(x, y, z) {\n        this.x = new Decimal(x);\n        this.y = new Decimal(y);\n        this.z = new Decimal(z);\n        // this.y = typeof(y) === 'number'?new decimal.Decimal(y):y as decimal.Decimal;\n        // this.z = typeof(z) === 'number'?new decimal.Decimal(z):z as decimal.Decimal;\n    }\n    S2Point.minus = function (p1, p2) {\n        return S2Point.sub(p1, p2);\n    };\n    S2Point.neg = function (p) {\n        return new S2Point(p.x.negated(), p.y.negated(), p.z.negated());\n    };\n    S2Point.prototype.norm2 = function () {\n        return this.x.pow(2).plus(this.y.pow(2)).plus(this.z.pow(2));\n    };\n    S2Point.prototype.norm = function () {\n        return this.norm2().sqrt();\n    };\n    S2Point.crossProd = function (p1, p2) {\n        return new S2Point(p1.y.times(p2.z).minus(p1.z.times(p2.y)), p1.z.times(p2.x).minus(p1.x.times(p2.z)), \n        // p1.z * p2.x - p1.x * p2.z,\n        p1.x.times(p2.y).minus(p1.y.times(p2.x)));\n    };\n    S2Point.add = function (p1, p2) {\n        return new S2Point(p1.x.add(p2.x), p1.y.add(p2.y), p1.z.add(p2.z));\n    };\n    S2Point.sub = function (p1, p2) {\n        return new S2Point(p1.x.sub(p2.x), p1.y.sub(p2.y), p1.z.sub(p2.z));\n    };\n    S2Point.prototype.dotProd = function (that) {\n        return this.x.times(that.x).plus(this.y.times(that.y)).plus(this.z.times(that.z));\n    };\n    S2Point.mul = function (p, m) {\n        var mD = new Decimal(m);\n        return new S2Point(mD.times(p.x), mD.times(p.y), mD.times(p.z));\n    };\n    S2Point.div = function (p, m) {\n        return new S2Point(p.x.div(m), p.y.div(m), p.z.div(m));\n    };\n    /** return a vector orthogonal to this one */\n    S2Point.prototype.ortho = function () {\n        var k = this.largestAbsComponent();\n        var temp;\n        if (k == 1) {\n            temp = new S2Point(1, 0, 0);\n        }\n        else if (k == 2) {\n            temp = new S2Point(0, 1, 0);\n        }\n        else {\n            temp = new S2Point(0, 0, 1);\n        }\n        return S2Point.normalize(S2Point.crossProd(this, temp));\n    };\n    /** Return the index of the largest component fabs */\n    S2Point.prototype.largestAbsComponent = function () {\n        var temp = S2Point.fabs(this);\n        if (temp.x.greaterThan(temp.y)) {\n            if (temp.x.greaterThan(temp.z)) {\n                return 0;\n            }\n            else {\n                return 2;\n            }\n        }\n        else {\n            if (temp.y.greaterThan(temp.z)) {\n                return 1;\n            }\n            else {\n                return 2;\n            }\n        }\n    };\n    S2Point.fabs = function (p) {\n        return new S2Point(p.x.abs(), p.y.abs(), p.z.abs());\n    };\n    S2Point.normalize = function (p) {\n        var norm = p.norm();\n        if (!norm.eq(0)) {\n            norm = S2_1.S2.toDecimal(1).dividedBy(norm);\n        }\n        return S2Point.mul(p, norm);\n    };\n    S2Point.prototype.axis = function (axis) {\n        return (axis == 0) ? this.x : (axis == 1) ? this.y : this.z;\n    };\n    /** Return the angle between two vectors in radians */\n    S2Point.prototype.angle = function (va) {\n        return Decimal.atan2(S2Point.crossProd(this, va).norm(), this.dotProd(va));\n    };\n    /**\n     * Compare two vectors, return true if all their components are within a\n     * difference of margin.\n     */\n    S2Point.prototype.aequal = function (that, margin) {\n        return this.x.minus(that.x).abs().lessThan(margin) &&\n            this.y.minus(that.y).abs().lessThan(margin) &&\n            this.z.minus(that.z).abs().lessThan(margin);\n    };\n    S2Point.prototype.equals = function (that) {\n        if (!(that instanceof S2Point)) {\n            return false;\n        }\n        return this.x.eq(that.x) && this.y.eq(that.y) && this.z.eq(that.z);\n    };\n    S2Point.prototype.lessThan = function (vb) {\n        if (this.x.lt(vb.x)) {\n            return true;\n        }\n        if (vb.x.lt(this.x)) {\n            return false;\n        }\n        if (this.y.lt(vb.y)) {\n            return true;\n        }\n        if (vb.y.lt(this.y)) {\n            return false;\n        }\n        if (this.z.lt(vb.z)) {\n            return true;\n        }\n        return false;\n    };\n    S2Point.prototype.compareTo = function (other) {\n        return (this.lessThan(other) ? -1 : (this.equals(other) ? 0 : 1));\n    };\n    S2Point.prototype.toFace = function () {\n        var face = this.largestAbsComponent();\n        if (this.axis(face).lt(0)) {\n            face += 3;\n        }\n        return face;\n    };\n    S2Point.prototype.toR2Vector = function (face) {\n        if (face === void 0) { face = this.toFace(); }\n        var u;\n        var v;\n        switch (face) {\n            case 0:\n                u = this.y.div(this.x);\n                v = this.z.div(this.x);\n                break;\n            case 1:\n                u = this.x.neg().div(this.y);\n                v = this.z.div(this.y);\n                break;\n            case 2:\n                u = this.x.neg().div(this.z);\n                v = this.y.neg().div(this.z);\n                break;\n            case 3:\n                u = this.z.div(this.x);\n                v = this.y.div(this.x);\n                break;\n            case 4:\n                u = this.z.div(this.y);\n                v = this.x.neg().div(this.y);\n                break;\n            case 5:\n                u = this.y.neg().div(this.z);\n                v = this.x.neg().div(this.z);\n                break;\n            default:\n                throw new Error('Invalid face');\n        }\n        return new R2Vector_1.R2Vector(u, v);\n    };\n    S2Point.prototype.toString = function () {\n        return \"Point(\" + this.x.toNumber() + \", \" + this.y.toNumber() + \", \" + this.z.toNumber() + \")\";\n    };\n    return S2Point;\n}());\nexports.S2Point = S2Point;\n//# sourceMappingURL=S2Point.js.map","/*\n * Copyright 2005 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\n/**\n * This class specifies the details of how the cube faces are projected onto the\n * unit sphere. This includes getting the face ordering and orientation correct\n * so that sequentially increasing cell ids follow a continuous space-filling\n * curve over the entire sphere, and defining the transformation from cell-space\n * to cube-space (see s2.h) in order to make the cells more uniform in size.\n *\n *\n *  We have implemented three different projections from cell-space (s,t) to\n * cube-space (u,v): linear, quadratic, and tangent. They have the following\n * tradeoffs:\n *\n *  Linear - This is the fastest transformation, but also produces the least\n * uniform cell sizes. Cell areas vary by a factor of about 5.2, with the\n * largest cells at the center of each face and the smallest cells in the\n * corners.\n *\n *  Tangent - Transforming the coordinates via atan() makes the cell sizes more\n * uniform. The areas vary by a maximum ratio of 1.4 as opposed to a maximum\n * ratio of 5.2. However, each call to atan() is about as expensive as all of\n * the other calculations combined when converting from points to cell ids, i.e.\n * it reduces performance by a factor of 3.\n *\n *  Quadratic - This is an approximation of the tangent projection that is much\n * faster and produces cells that are almost as uniform in size. It is about 3\n * times faster than the tangent projection for converting cell ids to points,\n * and 2 times faster for converting points to cell ids. Cell areas vary by a\n * maximum ratio of about 2.1.\n *\n *  Here is a table comparing the cell uniformity using each projection. \"Area\n * ratio\" is the maximum ratio over all subdivision levels of the largest cell\n * area to the smallest cell area at that level, \"edge ratio\" is the maximum\n * ratio of the longest edge of any cell to the shortest edge of any cell at the\n * same level, and \"diag ratio\" is the ratio of the longest diagonal of any cell\n * to the shortest diagonal of any cell at the same level. \"ToPoint\" and\n * \"FromPoint\" are the times in microseconds required to convert cell ids to and\n * from points (unit vectors) respectively.\n *\n *  Area Edge Diag ToPoint FromPoint Ratio Ratio Ratio (microseconds)\n * ------------------------------------------------------- Linear: 5.200 2.117\n * 2.959 0.103 0.123 Tangent: 1.414 1.414 1.704 0.290 0.306 Quadratic: 2.082\n * 1.802 1.932 0.116 0.161\n *\n *  The worst-case cell aspect ratios are about the same with all three\n * projections. The maximum ratio of the longest edge to the shortest edge\n * within the same cell is about 1.4 and the maximum ratio of the diagonals\n * within the same cell is about 1.7.\n *\n * This data was produced using s2cell_unittest and s2cellid_unittest.\n *\n */\nvar S2_1 = require(\"./S2\");\nvar S2Point_1 = require(\"./S2Point\");\nvar R2Vector_1 = require(\"./R2Vector\");\n(function (Projections) {\n    Projections[Projections[\"S2_LINEAR_PROJECTION\"] = 0] = \"S2_LINEAR_PROJECTION\";\n    Projections[Projections[\"S2_TAN_PROJECTION\"] = 1] = \"S2_TAN_PROJECTION\";\n    Projections[Projections[\"S2_QUADRATIC_PROJECTION\"] = 2] = \"S2_QUADRATIC_PROJECTION\";\n})(exports.Projections || (exports.Projections = {}));\nvar Projections = exports.Projections;\nvar S2Projections = (function () {\n    function S2Projections() {\n    }\n    S2Projections.getUNorm = function (face, u) {\n        switch (face) {\n            case 0:\n                return new S2Point_1.S2Point(u, -1, 0);\n            case 1:\n                return new S2Point_1.S2Point(1, u, 0);\n            case 2:\n                return new S2Point_1.S2Point(1, 0, u);\n            case 3:\n                return new S2Point_1.S2Point(-u, 0, 1);\n            case 4:\n                return new S2Point_1.S2Point(0, -u, 1);\n            default:\n                return new S2Point_1.S2Point(0, -1, -u);\n        }\n    };\n    S2Projections.getVNorm = function (face, v) {\n        switch (face) {\n            case 0:\n                return new S2Point_1.S2Point(-v, 0, 1);\n            case 1:\n                return new S2Point_1.S2Point(0, -v, 1);\n            case 2:\n                return new S2Point_1.S2Point(0, -1, -v);\n            case 3:\n                return new S2Point_1.S2Point(v, -1, 0);\n            case 4:\n                return new S2Point_1.S2Point(1, v, 0);\n            default:\n                return new S2Point_1.S2Point(1, 0, v);\n        }\n    };\n    S2Projections.getUAxis = function (face) {\n        switch (face) {\n            case 0:\n                return new S2Point_1.S2Point(0, 1, 0);\n            case 1:\n                return new S2Point_1.S2Point(-1, 0, 0);\n            case 2:\n                return new S2Point_1.S2Point(-1, 0, 0);\n            case 3:\n                return new S2Point_1.S2Point(0, 0, -1);\n            case 4:\n                return new S2Point_1.S2Point(0, 0, -1);\n            default:\n                return new S2Point_1.S2Point(0, 1, 0);\n        }\n    };\n    S2Projections.getVAxis = function (face) {\n        switch (face) {\n            case 0:\n                return new S2Point_1.S2Point(0, 0, 1);\n            case 1:\n                return new S2Point_1.S2Point(0, 0, 1);\n            case 2:\n                return new S2Point_1.S2Point(0, -1, 0);\n            case 3:\n                return new S2Point_1.S2Point(0, -1, 0);\n            case 4:\n                return new S2Point_1.S2Point(1, 0, 0);\n            default:\n                return new S2Point_1.S2Point(1, 0, 0);\n        }\n    };\n    S2Projections.faceUvToXyz = function (face, u, v) {\n        return new R2Vector_1.R2Vector(u, v).toPoint(face);\n    };\n    S2Projections.MIN_WIDTH = new S2_1.S2Metric(1, S2_1.S2.M_SQRT2 / 3);\n    S2Projections.AVG_AREA = new S2_1.S2Metric(2, S2_1.S2.M_PI / 6); // 0.524)\n    return S2Projections;\n}());\nexports.S2Projections = S2Projections;\n//# sourceMappingURL=S2Projections.js.map","/*\n * Copyright 2005 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\nvar S2Cell_1 = require(\"./S2Cell\");\nvar S2CellId_1 = require(\"./S2CellId\");\nvar S2CellUnion_1 = require(\"./S2CellUnion\");\nvar S2Projections_1 = require(\"./S2Projections\");\nvar decimal_1 = require('./decimal');\n/**\n * An S2RegionCoverer is a class that allows arbitrary regions to be\n * approximated as unions of cells (S2CellUnion). This is useful for\n * implementing various sorts of search and precomputation operations.\n *\n * Typical usage: {@code S2RegionCoverer coverer; coverer.setMaxCells(5); S2Cap\n * cap = S2Cap.fromAxisAngle(...); S2CellUnion covering;\n * coverer.getCovering(cap, covering); * }\n *\n * This yields a cell union of at most 5 cells that is guaranteed to cover the\n * given cap (a disc-shaped region on the sphere).\n *\n *  The approximation algorithm is not optimal but does a pretty good job in\n * practice. The output does not always use the maximum number of cells allowed,\n * both because this would not always yield a better approximation, and because\n * max_cells() is a limit on how much work is done exploring the possible\n * covering as well as a limit on the final output size.\n *\n *  One can also generate interior coverings, which are sets of cells which are\n * entirely contained within a region. Interior coverings can be empty, even for\n * non-empty regions, if there are no cells that satisfy the provided\n * constraints and are contained by the region. Note that for performance\n * reasons, it is wise to specify a max_level when computing interior coverings\n * - otherwise for regions with small or zero area, the algorithm may spend a\n * lot of time subdividing cells all the way to leaf level to try to find\n * contained cells.\n *\n *  This class is thread-unsafe. Simultaneous calls to any of the getCovering\n * methods will conflict and produce unpredictable results.\n *\n */\nvar S2RegionCoverer = (function () {\n    /**\n     * Default constructor, sets all fields to default values.\n     */\n    function S2RegionCoverer() {\n        this.minLevel = 0;\n        this.maxLevel = S2CellId_1.S2CellId.MAX_LEVEL;\n        this.levelMod = 1;\n        this.maxCells = S2RegionCoverer.DEFAULT_MAX_CELLS;\n        this.region = null;\n        this.result = [];\n        this.candidateQueue = new PriorityQueue();\n    }\n    // Set the minimum and maximum cell level to be used. The default is to use\n    // all cell levels. Requires: max_level() >= min_level().\n    //\n    // To find the cell level corresponding to a given physical distance, use\n    // the S2Cell metrics defined in s2.h. For example, to find the cell\n    // level that corresponds to an average edge length of 10km, use:\n    //\n    // int level = S2::kAvgEdge.GetClosestLevel(\n    // geostore::S2Earth::KmToRadians(length_km));\n    //\n    // Note: min_level() takes priority over max_cells(), i.e. cells below the\n    // given level will never be used even if this causes a large number of\n    // cells to be returned.\n    /**\n     * Sets the minimum level to be used.\n     */\n    S2RegionCoverer.prototype.setMinLevel = function (minLevel) {\n        // assert (minLevel >= 0 && minLevel <= S2CellId.MAX_LEVEL);\n        this.minLevel = Math.max(0, Math.min(S2CellId_1.S2CellId.MAX_LEVEL, minLevel));\n        return this;\n    };\n    /**\n     * Sets the maximum level to be used.\n     */\n    S2RegionCoverer.prototype.setMaxLevel = function (maxLevel) {\n        // assert (maxLevel >= 0 && maxLevel <= S2CellId.MAX_LEVEL);\n        this.maxLevel = Math.max(0, Math.min(S2CellId_1.S2CellId.MAX_LEVEL, maxLevel));\n        return this;\n    };\n    /**\n     * If specified, then only cells where (level - min_level) is a multiple of\n     * \"level_mod\" will be used (default 1). This effectively allows the branching\n     * factor of the S2CellId hierarchy to be increased. Currently the only\n     * parameter values allowed are 1, 2, or 3, corresponding to branching factors\n     * of 4, 16, and 64 respectively.\n     */\n    S2RegionCoverer.prototype.setLevelMod = function (levelMod) {\n        // assert (levelMod >= 1 && levelMod <= 3);\n        this.levelMod = Math.max(1, Math.min(3, levelMod));\n        return this;\n    };\n    /**\n     * Sets the maximum desired number of cells in the approximation (defaults to\n     * kDefaultMaxCells). Note the following:\n     *\n     * <ul>\n     * <li>For any setting of max_cells(), up to 6 cells may be returned if that\n     * is the minimum number of cells required (e.g. if the region intersects all\n     * six face cells). Up to 3 cells may be returned even for very tiny convex\n     * regions if they happen to be located at the intersection of three cube\n     * faces.\n     *\n     * <li>For any setting of max_cells(), an arbitrary number of cells may be\n     * returned if min_level() is too high for the region being approximated.\n     *\n     * <li>If max_cells() is less than 4, the area of the covering may be\n     * arbitrarily large compared to the area of the original region even if the\n     * region is convex (e.g. an S2Cap or S2LatLngRect).\n     * </ul>\n     *\n     * Accuracy is measured by dividing the area of the covering by the area of\n     * the original region. The following table shows the median and worst case\n     * values for this area ratio on a test case consisting of 100,000 spherical\n     * caps of random size (generated using s2regioncoverer_unittest):\n     *\n     * <pre>\n     * max_cells: 3 4 5 6 8 12 20 100 1000\n     * median ratio: 5.33 3.32 2.73 2.34 1.98 1.66 1.42 1.11 1.01\n     * worst case: 215518 14.41 9.72 5.26 3.91 2.75 1.92 1.20 1.02\n     * </pre>\n     */\n    S2RegionCoverer.prototype.setMaxCells = function (maxCells) {\n        this.maxCells = maxCells;\n        return this;\n    };\n    /**\n     * Computes a list of cell ids that covers the given region and satisfies the\n     * various restrictions specified above.\n     *\n     * @param region The region to cover\n     * @param covering The list filled in by this method\n     */\n    S2RegionCoverer.prototype.getCoveringCells = function (region) {\n        // Rather than just returning the raw list of cell ids generated by\n        // GetCoveringInternal(), we construct a cell union and then denormalize it.\n        // This has the effect of replacing four child cells with their parent\n        // whenever this does not violate the covering parameters specified\n        // (min_level, level_mod, etc). This strategy significantly reduces the\n        // number of cells returned in many cases, and it is cheap compared to\n        // computing the covering in the first place.\n        var tmp = this.getCoveringUnion(region);\n        return tmp.denormalize(this.minLevel, this.levelMod);\n    };\n    /**\n     * Computes a list of cell ids that is contained within the given region and\n     * satisfies the various restrictions specified above.\n     *\n     * @param region The region to fill\n     * @param interior The list filled in by this method\n     */\n    S2RegionCoverer.prototype.getInteriorCoveringCells = function (region) {\n        var tmp = this.getInteriorCoveringUnion(region);\n        return tmp.denormalize(this.minLevel, this.levelMod);\n    };\n    /**\n     * Return a normalized cell union that covers the given region and satisfies\n     * the restrictions *EXCEPT* for min_level() and level_mod(). These criteria\n     * cannot be satisfied using a cell union because cell unions are\n     * automatically normalized by replacing four child cells with their parent\n     * whenever possible. (Note that the list of cell ids passed to the cell union\n     * constructor does in fact satisfy all the given restrictions.)\n     */\n    S2RegionCoverer.prototype.getCoveringUnion = function (region, covering) {\n        if (covering === void 0) { covering = new S2CellUnion_1.S2CellUnion(); }\n        this.interiorCovering = false;\n        this.getCoveringInternal(region);\n        covering.initSwap(this.result);\n        return covering;\n    };\n    /**\n     * Return a normalized cell union that is contained within the given region\n     * and satisfies the restrictions *EXCEPT* for min_level() and level_mod().\n     */\n    S2RegionCoverer.prototype.getInteriorCoveringUnion = function (region, covering) {\n        if (covering === void 0) { covering = new S2CellUnion_1.S2CellUnion(); }\n        this.interiorCovering = true;\n        this.getCoveringInternal(region);\n        covering.initSwap(this.result);\n        return covering;\n    };\n    // /**\n    //  * Given a connected region and a starting point, return a set of cells at the\n    //  * given level that cover the region.\n    //  */\n    // public static getSimpleCovering(\n    //     region:S2Region , start:S2Point , level:number):S2CellId[] {\n    //   S2RegionCoverer.floodFill(region, S2CellId.fromPoint(start).parentL(level));\n    // }\n    /**\n     * If the cell intersects the given region, return a new candidate with no\n     * children, otherwise return null. Also marks the candidate as \"terminal\" if\n     * it should not be expanded further.\n     */\n    S2RegionCoverer.prototype.newCandidate = function (cell) {\n        if (!this.region.mayIntersectC(cell)) {\n            // console.log(\"NOT INTERSECTING\",this.region);\n            return null;\n        }\n        var isTerminal = false;\n        if (cell.level >= this.minLevel) {\n            if (this.interiorCovering) {\n                if (this.region.containsC(cell)) {\n                    isTerminal = true;\n                }\n                else if (cell.level + this.levelMod > this.maxLevel) {\n                    return null;\n                }\n            }\n            else {\n                if (cell.level + this.levelMod > this.maxLevel || this.region.containsC(cell)) {\n                    isTerminal = true;\n                }\n            }\n        }\n        var candidate = new Candidate();\n        candidate.cell = cell;\n        candidate.isTerminal = isTerminal;\n        candidate.numChildren = 0;\n        if (!isTerminal) {\n            candidate.children = Array.apply(null, new Array(1 << this.maxChildrenShift()));\n        }\n        this.candidatesCreatedCounter++;\n        return candidate;\n    };\n    /** Return the log base 2 of the maximum number of children of a candidate. */\n    S2RegionCoverer.prototype.maxChildrenShift = function () {\n        return 2 * this.levelMod;\n    };\n    /**\n     * Process a candidate by either adding it to the result list or expanding its\n     * children and inserting it into the priority queue. Passing an argument of\n     * NULL does nothing.\n     */\n    S2RegionCoverer.prototype.addCandidate = function (candidate) {\n        if (candidate == null) {\n            return;\n        }\n        if (candidate.isTerminal) {\n            this.result.push(candidate.cell.id);\n            return;\n        }\n        // assert (candidate.numChildren == 0);\n        // Expand one level at a time until we hit min_level_ to ensure that\n        // we don't skip over it.\n        var numLevels = (candidate.cell.level < this.minLevel) ? 1 : this.levelMod;\n        var numTerminals = this.expandChildren(candidate, candidate.cell, numLevels);\n        if (candidate.numChildren == 0) {\n        }\n        else if (!this.interiorCovering && numTerminals == 1 << this.maxChildrenShift()\n            && candidate.cell.level >= this.minLevel) {\n            // Optimization: add the parent cell rather than all of its children.\n            // We can't do this for interior coverings, since the children just\n            // intersect the region, but may not be contained by it - we need to\n            // subdivide them further.\n            candidate.isTerminal = true;\n            this.addCandidate(candidate);\n        }\n        else {\n            // We negate the priority so that smaller absolute priorities are returned\n            // first. The heuristic is designed to refine the largest cells first,\n            // since those are where we have the largest potential gain. Among cells\n            // at the same level, we prefer the cells with the smallest number of\n            // intersecting children. Finally, we prefer cells that have the smallest\n            // number of children that cannot be refined any further.\n            var priority = -((((candidate.cell.level << this.maxChildrenShift()) + candidate.numChildren)\n                << this.maxChildrenShift()) + numTerminals);\n            this.candidateQueue.add(new QueueEntry(priority, candidate));\n        }\n    };\n    /**\n     * Populate the children of \"candidate\" by expanding the given number of\n     * levels from the given cell. Returns the number of children that were marked\n     * \"terminal\".\n     */\n    S2RegionCoverer.prototype.expandChildren = function (candidate, cell, numLevels) {\n        numLevels--;\n        var childCells = cell.subdivide();\n        var numTerminals = 0;\n        for (var i = 0; i < 4; ++i) {\n            if (numLevels > 0) {\n                if (this.region.mayIntersectC(childCells[i])) {\n                    numTerminals += this.expandChildren(candidate, childCells[i], numLevels);\n                }\n                continue;\n            }\n            var child = this.newCandidate(childCells[i]);\n            if (child != null) {\n                candidate.children[candidate.numChildren++] = child;\n                if (child.isTerminal) {\n                    ++numTerminals;\n                }\n            }\n        }\n        return numTerminals;\n    };\n    /** Computes a set of initial candidates that cover the given region. */\n    S2RegionCoverer.prototype.getInitialCandidates = function () {\n        // Optimization: if at least 4 cells are desired (the normal case),\n        // start with a 4-cell covering of the region's bounding cap. This\n        // lets us skip quite a few levels of refinement when the region to\n        // be covered is relatively small.\n        if (this.maxCells >= 4) {\n            // Find the maximum level such that the bounding cap contains at most one\n            // cell vertex at that level.\n            var cap = this.region.getCapBound();\n            var level = decimal_1.Decimal.min(S2Projections_1.S2Projections.MIN_WIDTH.getMaxLevel(cap.angle().radians.times(2)), decimal_1.Decimal.min(this.maxLevel, S2CellId_1.S2CellId.MAX_LEVEL - 1)).toNumber();\n            if (this.levelMod > 1 && level > this.minLevel) {\n                level -= (level - this.minLevel) % this.levelMod;\n            }\n            // We don't bother trying to optimize the level == 0 case, since more than\n            // four face cells may be required.\n            if (level > 0) {\n                // Find the leaf cell containing the cap axis, and determine which\n                // subcell of the parent cell contains it.\n                // ArrayList<S2CellId> base = new ArrayList<>(4);\n                var id = S2CellId_1.S2CellId.fromPoint(cap.axis);\n                var base = id.getVertexNeighbors(level);\n                for (var i = 0; i < base.length; ++i) {\n                    this.addCandidate(this.newCandidate(new S2Cell_1.S2Cell(base[i])));\n                }\n                return;\n            }\n        }\n        // Default: start with all six cube faces.\n        for (var face = 0; face < 6; ++face) {\n            this.addCandidate(this.newCandidate(S2RegionCoverer.FACE_CELLS[face]));\n        }\n    };\n    /** Generates a covering and stores it in result. */\n    S2RegionCoverer.prototype.getCoveringInternal = function (region) {\n        // Strategy: Start with the 6 faces of the cube. Discard any\n        // that do not intersect the shape. Then repeatedly choose the\n        // largest cell that intersects the shape and subdivide it.\n        //\n        // result contains the cells that will be part of the output, while the\n        // priority queue contains cells that we may still subdivide further. Cells\n        // that are entirely contained within the region are immediately added to\n        // the output, while cells that do not intersect the region are immediately\n        // discarded.\n        // Therefore pq_ only contains cells that partially intersect the region.\n        // Candidates are prioritized first according to cell size (larger cells\n        // first), then by the number of intersecting children they have (fewest\n        // children first), and then by the number of fully contained children\n        // (fewest children first).\n        if (!(this.candidateQueue.size() == 0 && this.result.length == 0)) {\n            throw new Error('preconditions are not satisfied');\n        }\n        // Preconditions.checkState(this.candidateQueue.isEmpty() && this.result.isEmpty());\n        this.region = region;\n        this.candidatesCreatedCounter = 0;\n        this.getInitialCandidates();\n        while (this.candidateQueue.size() !== 0 && (!this.interiorCovering || this.result.length < this.maxCells)) {\n            var candidate = this.candidateQueue.poll().candidate;\n            // logger.info(\"Pop: \" + candidate.cell.id());\n            if (candidate.cell.level < this.minLevel || candidate.numChildren == 1\n                || this.result.length + (this.interiorCovering ? 0 : this.candidateQueue.size()) + candidate.numChildren\n                    <= this.maxCells) {\n                // Expand this candidate into its children.\n                for (var i = 0; i < candidate.numChildren; ++i) {\n                    this.addCandidate(candidate.children[i]);\n                }\n            }\n            else if (this.interiorCovering) {\n            }\n            else {\n                candidate.isTerminal = true;\n                this.addCandidate(candidate);\n            }\n        }\n        this.candidateQueue.clear();\n        this.region = null;\n    };\n    /**\n     * By default, the covering uses at most 8 cells at any level. This gives a\n     * reasonable tradeoff between the number of cells used and the accuracy of\n     * the approximation (see table below).\n     */\n    S2RegionCoverer.DEFAULT_MAX_CELLS = 8;\n    S2RegionCoverer.FACE_CELLS = new Array(6).map(function (face) { return S2Cell_1.S2Cell.fromFacePosLevel(face, 0, 0); });\n    return S2RegionCoverer;\n}());\nexports.S2RegionCoverer = S2RegionCoverer;\nvar Candidate = (function () {\n    function Candidate() {\n    }\n    // elements.\n    Candidate.prototype.toString = function () {\n        return \"isTermina: \" + this.isTerminal + \" - Cell: \" + this.cell.toString();\n    };\n    return Candidate;\n}());\nvar PriorityQueue = (function () {\n    function PriorityQueue() {\n        this.clear();\n    }\n    PriorityQueue.prototype.add = function (item) {\n        this.items.push(item);\n        this.items.sort(function (a, b) { return a.compare(b); });\n    };\n    PriorityQueue.prototype.clear = function () {\n        this.items = [];\n    };\n    PriorityQueue.prototype.size = function () {\n        return this.items.length;\n    };\n    PriorityQueue.prototype.poll = function () {\n        return this.items.splice(0, 1)[0];\n    };\n    return PriorityQueue;\n}());\nvar QueueEntry = (function () {\n    function QueueEntry(id, candidate) {\n        this.id = id;\n        this.candidate = candidate;\n    }\n    QueueEntry.prototype.compare = function (other) {\n        return this.id < other.id ? 1 : (this.id > other.id ? -1 : 0);\n    };\n    return QueueEntry;\n}());\n//# sourceMappingURL=S2RegionCoverer.js.map","\"use strict\";\nrequire('./decimal_augmentation');\nexports.Decimal = require('decimal.js');\n//# sourceMappingURL=decimal.js.map","\"use strict\";\n//# sourceMappingURL=decimal_augmentation.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar S2Cap_1 = require(\"./S2Cap\");\n__export(require('./Interval'));\n__export(require('./MutableInteger'));\n__export(require('./R1Interval'));\n__export(require('./R2Vector'));\n__export(require('./S1Angle'));\n__export(require('./S1Interval'));\n__export(require('./S2'));\n__export(require('./S2Cap'));\n__export(require('./S2Cell'));\n__export(require('./S2CellId'));\n__export(require('./S2CellUnion'));\n// export * from './S2EdgeIndex';\n// export * from './S2EdgeUtil';\n__export(require('./S2LatLng'));\n__export(require('./S2LatLngRect'));\n// export * from './S2Loop';\n__export(require('./S2Point'));\n__export(require('./S2Projections'));\n__export(require('./S2RegionCoverer'));\nvar Utils = (function () {\n    function Utils() {\n    }\n    /**\n     * Calculates a region covering a circle\n     * NOTE: The current implementation uses S2Cap while S2Loop would be better (S2Loop is not implemented yet)\n     * @param center\n     * @param radiusInKM\n     * @param points the number of points to calculate. The higher the better precision\n     * @returns {S2Region}\n     */\n    Utils.calcRegionFromCenterRadius = function (center, radiusInKM, points) {\n        if (points === void 0) { points = 16; }\n        var pointsAtDistance = center.pointsAtDistance(radiusInKM, points);\n        var s2Cap = S2Cap_1.S2Cap.empty().addPoint(center.toPoint());\n        // It would be probably enough to add one of the points/2 pair of opposite points in the circle such\n        // as (0, points/2). but since this is just a temporary solution lets stick with this as it\n        // will come handy when implementing S2Loop.\n        pointsAtDistance\n            .map(function (p) { return p.toPoint(); })\n            .forEach(function (p) {\n            s2Cap = s2Cap.addPoint(p);\n        });\n        return s2Cap;\n    };\n    return Utils;\n}());\nexports.Utils = Utils;\n//# sourceMappingURL=export.js.map","module.exports = require(\"aws-sdk\");"],"sourceRoot":""}